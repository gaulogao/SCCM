##################################################################################################
# Author: Andy GAO (Lei GAO)
# Organization: Microsoft CSS
# Contact: lega@microsoft.com
# Version: 10.1
# Last updated: 2022-07-01
##################################################################################################

# ------------------------------------------------------ Client-Info.ps1 ------------------------------------------------------ #
##################################################################################################
####################################### Begin - Functions definitions ####################################
##################################################################################################

# Begin - CSS definition
$header = @"
		<style>
			body {
				font-family: "Open Sans","Clear Sans", "Helvetica Neue", Helvetica, Arial, 'Segoe UI Emoji', sans-serif;
				color: rgb(51, 51, 51);
				/* line-height: 1.6; */
			}
			
			h1 {
				font-size: 2.25em;
				/* line-height: 1.2; */
				border-bottom: 1px solid #eee;
			}
			
			h2 {
				font-size: 1.75em;
				/* line-height: 1.225; */
				border-bottom: 1px solid #eee;
			}
									
			h3 {
				font-size: 1.5em;
				line-height: 0.3;
			}
		 
		   table {
				font-size: 12px;
				border: 0px; 
				font-family: Arial, Helvetica, sans-serif;
			} 
			
			table tr {
			border: 1px solid #dfe2e5;
			margin: 0;
			padding: 0;
			}
			
			table td {
				border: 1px solid #dfe2e5;
				margin: 0;
				padding: 6px 13px;
			}
				
			td.hr {
				height: 2px;
				padding: 10;
				margin: 16px 0;
				background-color: #e7e7e7;
				border: 0 none;
				overflow: hidden;
				box-sizing: content-box;
			}
			
			td:first-child { font-weight: bold }
			
			table th {
				font-weight: bold;
				background-color: #f8f8f8;
				border: 1px solid #dfe2e5;
				border-bottom: 0;
				margin: 0;
				padding: 6px 13px;
			}

			table th:first-child,
			table td:first-child {
				margin-top: 0;
			}
			
			table th:last-child,
			table td:last-child {
				margin-bottom: 0;
			}

			table tr:hover {background: azure;}
			
			.GreenStatus {
				color: #32CD32;
				font-weight: bold;
			}
	
			.RedStatus {
				color: #ff0000;
				font-weight: bold;
			}
			
			.OrangeStatus {
				color: #D28140;
				font-weight: bold;
			}
			
			#CreationDate {
				font-family: Arial, Helvetica, sans-serif;
				color: #0000FF;
				font-size: 12px;
			}
			
			textarea {
				width: 700px;
				height: 200px;
				background-color: beige;
			}
			
			/* Side Menu */
			#mySidenav ul {
			  position: fixed;
			  left: -270px;
			  transition: 0.3s;
			  padding: 15px;
			  top:10%;
			  width: 250px;
			  text-decoration: none;
			  font-size: 1.2em;
			  color: white;
			  border-radius: 0 5px 5px 0;
			  list-style-type: none;
			  background-color:rgb(51 51 51);
			  
			}
			
			#mySidenav ul li {
			  color: #000;
			  padding: 8px 16px;
			  text-decoration: none;
			}

			#mySidenav ul li a {
			  display: block;
			  color: #000;
			  
			  text-decoration: none;
			}
			
			#mySidenav ul li a:hover:not(.active) {
			  background-color: #555;
			  color: white;
			}

			#mySidenav ul:hover {
			  left: 0;
			  background-color: #e5e2df;
			}
			
			/* Main index page */
			#index table {
				width: 100%;
			} 
			#index table td table {
				width: 100%;
			}
			
			#index td table td {
				font-size: 1.2em;
			    border-bottom: 1px solid #e5e2df;
				border-top: none;
				border-right: none;
				border-left: none;
				/*border-collapse: collapse;*/
				/*background-color: #edeff0;*/
				font-family: Arial, Helvetica, sans-serif;
			} 
			
			#index td table td:nth-child(1) {
                width: 50%;
            }
			
			#index td table tr:hover {background: #e5e2df;}
			
			/* Main index page - html/txt file review in an overlay page*/
						
			.overlay {
			  height: 100%;
			  width: 0;
			  position: fixed;
			  z-index: 2;
			  top: 0;
			  left: 0;
			  background-color: #f8f8f8;
			  background-color: #f8f8f8;
			  overflow-x: hidden;
			  transition: 0.5s;
			}

			.overlay-content {
			  position: relative;
			  top: 5%;
			  width: 100%;
			  height: 100%;
			}

			.overlay-content  iframe {
				width: 100%;
				height: 100%;
				border:none;
			}
			.overlay a {
			  text-decoration: none;
			  font-size: 1.2em;
			  color: #818181;
			  display: block;
			  transition: 0.3s;
			}

			.overlay a:hover, .overlay a:focus {
			  color: red;
			}

			.overlay .closebtn {
			  position: absolute;
			  top: 0px;
			  right: 0px;
			  font-size: 30px;
			}
			
		</style>
		
		<script>
			function openPeek(file) {
			  document.getElementById("innerframe").setAttribute("src", file);
			  document.getElementById("peekContent").style.width = "100%";
			}

			function closePeek() {
			  document.getElementById("peekContent").style.width = "0%";
			}
		</script>
"@
# End - CSS definition

##====================================================================================================================================##
## Client Windows Update part goes here
##====================================================================================================================================##

# Print declaration
Function Print-Declaration {
	# Main function interface
	Write-Host "<<+++++++++++++++++++++++++++++++++++++++ DECLARATION ++++++++++++++++++++++++++++++++++++++>>" -ForegroundColor Red -BackgroundColor White
	Write-Host "<<This executive program is used for troubleshooting Configuration Manager..................>>" -ForegroundColor Red
	Write-Host "<<It will not bring any changes or harms to your computer...................................>>" -ForegroundColor Red
	Write-Host "<<Do not distribute this program without the authorization from Microsoft...................>>" -ForegroundColor Red
	Write-Host "<<..........................................................................................>>" -ForegroundColor Red -BackgroundColor White
}

#############################
# Verify if a command exists
#############################
Function Check-Command {
	    Param( 
		[Parameter(Mandatory = $true, Position = 0)][String] $CMD
		)
	return ! ((Get-Command $CMD -ErrorAction SilentlyContinue) -eq $Null)
}

#######################################################
# Format XML
# https://devblogs.microsoft.com/powershell/format-xml/
#######################################################
Function Format-XML ([xml]$xml, $indent=2)
{
    $StringWriter = New-Object System.IO.StringWriter
    $XmlWriter = New-Object System.XMl.XmlTextWriter $StringWriter
    $xmlWriter.Formatting = "indented"
    $xmlWriter.Indentation = $Indent
    $xml.WriteContentTo($XmlWriter)
    $XmlWriter.Flush()
    $StringWriter.Flush()
    Write-Output $StringWriter.ToString()
}

############################################################################################
# Generate footer
# eg. Creation Date: 2022-02-11 15:04:29 +08:00 - China Standard Time (legacomgmt.lega5.lab)
############################################################################################
Function Generate-Footer {
	return "Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))"
}

##################
# Print a message
##################
Function Print-Message {
    Param( 
		[Parameter(Mandatory = $true, Position = 0)][Int] $Width,
        [Parameter(Mandatory = $true, Position = 1)][String] $Msg,
        [Parameter(Mandatory = $false, Position = 2)][String] $FontColor = "DarkCyan",
        [Parameter(Mandatory = $false, Position = 3)][String] $BGColor = "White",
		[Parameter(Mandatory = $false, Position = 4)][Switch] $MoreInfo
	)
    Write-Host ("{0, $Width}" -f $Msg) -ForegroundColor $FontColor -BackgroundColor $BGColor
}

# SMS Client version list
$ClientVersionList = @{
 2203 = @{version = "5.00.9078"; build = "9078"; baseline = "Yes"}
 2111 = @{version = "5.00.9068"; build = "9068"; baseline = "No"}
 2107 = @{version = "5.00.9058"; build = "9058"; baseline = "No"}
 2103 = @{version = "5.00.9049"; build = "9049"; baseline = "Yes"}
 2010 = @{version = "5.00.9040"; build = "9040"; baseline = "No"}
 2006 = @{version = "5.00.9012"; build = "9012"; baseline = "No"}
 2002 = @{version = "5.00.8968"; build = "8968"; baseline = "Yes"}
 1910 = @{version = "5.00.8913"; build = "8913"; baseline = "No"}
 1906 = @{version = "5.00.8853"; build = "8853"; baseline = "No"}
 1902 = @{version = "5.00.8790"; build = "8790"; baseline = "Yes"}
 1810 = @{version = "5.00.8740"; build = "8740"; baseline = "No"}
 1806 = @{version = "5.00.8692"; build = "8692"; baseline = "No"}
 1802 = @{version = "5.00.8634"; build = "8634"; baseline = "Yes/No"}
 1710 = @{version = "5.00.8577"; build = "8577"; baseline = "No"}
 1706 = @{version = "5.00.8540"; build = "8540"; baseline = "No"}
 1702 = @{version = "5.00.8498"; build = "8498"; baseline = "Yes"}
 1610 = @{version = "5.00.8458"; build = "8458"; baseline = "No"}
 1606 = @{version = "5.00.8412"; build = "8412"; baseline = "Yes/No"}
 1602 = @{version = "5.00.8355"; build = "8355"; baseline = "No"}
 1511 = @{version = "5.00.8325"; build = "8325"; baseline = "Yes"}
}

# Get SMS Client version
Function Get-ClientVersion {
	Param( 
		[Parameter(Mandatory = $true, Position = 0)][String] $Ver
	)
	if ($Ver) {
		$Build = ($Ver -split "\.")[2]
		foreach ($Key in $ClientVersionList.Keys) {
			if ($Build -eq $ClientVersionList[$Key]['build']) { Return "$Key - $Ver"}
		}
		Return $Ver
	} else {Return $Null}
}


#####################################################################################################
# Decode ConfigMgr certificates
# https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/certutil#-decodehex
#####################################################################################################
Function Decode-Cert
{
	Param(
        [Parameter(Mandatory = $true)][String] $InputHex,
		[Parameter(Mandatory = $false)][String] $InputFileName = "input.txt",
        [Parameter(Mandatory = $true)][String] $OutputFileName,
        [Parameter(Mandatory = $false)][String] $toLocation = (Get-Location)
	)
	# Subdirectory to hold the certificate file
	$ChildDir = "SMSAgent\Certificates"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	$InputFile = "${toLocation}\${ChildDir}" + "\" +  $InputFileName
	$OutputFile = "${toLocation}\${ChildDir}" + "\" +  $OutputFileName
	
	$InputHex | Out-File $InputFile
	cmd.exe /c certutil /f -decodehex $InputFile $OutputFile > $NULL
	return $OutputFile	
}

############################################
# Fetch WindowsUpdate and AU registry info
############################################
Function Get-WUReg {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $WUFileName = "WindowsUpdateRegistry.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	$ChildDir = "General"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $WUFileName = "WindowsUpdateRegistry.txt"}
	$WUFile = "${toLocation}\${ChildDir}" + "\" +  $WUFileName
	
	$Title = "Windows Update Registry"
	$TitleWUReg = "Windows Update"
	$TitleWUSusClientReg = "Windows Update SusClient"
	$TitleWUAUReg = "Windows Update AU"
	$OutMsgWUReg = "  *** Read - HKLM:Software\Policies\Microsoft\Windows\WindowsUpdate *** "
	$OutMsgWUSusClient = "  *** Read - HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate *** "
	$OutMsgWUAUReg = "  *** Read - HKLM:Software\Policies\Microsoft\Windows\WindowsUpdate\AU *** "
	$WURegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate' | Select-Object -Property WUServer, WUStatusServer, DisableDualScan, DisableWindowsUpdateAccess, @{Name="RegPath";Expression={($_.PSPath -split "::")[1]}}
	$WUSusClientInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate' | Select-Object -Property SusClientId, LastDownloadsPurgeTime, LastTaskOperationHandle, UpdateDesiredVisibility, @{Name="SusClientIdValidation";Expression={$_.SusClientIdValidation -join ""}}, @{Name="RegPath";Expression={($_.PSPath -split "::")[1]}}
	$WUAURegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate\AU' | Select-Object -Property IncludeRecommendedUpdates, @{Name="NoAutoUpdate";Expression={switch ($_.NoAutoUpdate) {0 {"0 - Automatic Updates is enabled (default)"}; 1 {"1 - Automatic Updates is disabled"}}}}, @{Name="AUOptions";Expression={switch ($_.AUOptions) {1 {"1 - Keep my computer up to date is disabled in Automatic Updates"}; 2 {"2 - Notify of download and installation"}; 3 {"3 - Automatically download and notify of installation"}; 4 {"4 - Automatically download and scheduled installation"}}}}, ScheduledInstallDay, ScheduledInstallTime, UseWUServer, @{Name="RegPath";Expression={($_.PSPath -split "::")[1]}}
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<div id='mySidenav'><ul><li><a href='#WURegInfo'>$TitleWUReg</a></li><li><a href='#WUSusClientInfo'>$TitleWUSusClientReg</a></li><li><a href='#WUAURegInfo'>$TitleWUAUReg</a></li></ul></div>"
		if ($WURegInfo) {
			$WURegInfo = $WURegInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='WURegInfo'>Windows Update Registry</h2>" -as List
		}
		if ($WUSusClientInfo) {
			$WUSusClientInfo = $WUSusClientInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='WUSusClientInfo'>Windows Update SusClient</h2>" -as List
		}			
		if (Test-Path 'HKLM:Software\Policies\Microsoft\Windows\WindowsUpdate\AU' ) {
			$WUAURegInfo = $WUAURegInfo | ConvertTo-Html  -Fragment -PreContent "<h2 id='WUAURegInfo'>Windows Update AU Registry</h2>" -as List
		}
		
		$ReportParams = @{
			Body = "$TopicName $ContentTable $WURegInfo $WUSusClientInfo $WUAURegInfo"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		
		#$Report = ConvertTo-HTML -Body "$TopicName $ContentTable $WURegInfo $WUAURegInfo" -Head $header -Title $Title -PostContent "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $WUFile
	} else {
		"=== $TitleWUReg ===" | Out-File $WUFile
		if ($WURegInfo) {
			$WURegInfo | Out-File -Append $WUFile
			
		}
		"=== $TitleWUSusClientReg===" | Out-File -Append $WUFile
		if ($WUSusClientInfo) {
			$WUSusClientInfo | Out-File -Append $WUFile
			
		}
		"=== $TitleWUAUReg===" | Out-File -Append $WUFile
		if ($WUAURegInfo) {
			$WUAURegInfo | Out-File -Append $WUFile
		}
		Generate-Footer | Out-File -Append $WUFile
	}
	Write-Verbose -Message $OutMsgWUReg
	Write-Verbose -Message $OutMsgWUSusClient
	Write-Verbose -Message $OutMsgWUAUReg
}

###############################################################
# Copy WindowsUpdate etl logs, ReportingEvents.log and CBS.log
###############################################################
Function Get-WUFiles {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location)
	)

	# Copy ${ENV:windir}\SoftwareDistribution\ReportingEvents.log
	if (Test-Path "${ENV:windir}\SoftwareDistribution\ReportingEvents.log") {
		if (! (Test-Path "${toLocation}\SoftwareDistribution")) { New-Item -ItemType "Directory" "${toLocation}\SoftwareDistribution" | Out-Null }
		Copy-Item "${ENV:windir}\SoftwareDistribution\*" -Destination "${toLocation}\SoftwareDistribution" -Recurse -Filter "ReportingEvents*.log"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\SoftwareDistribution\ReportingEvents.log *** " 
	}

	# Copy ${ENV:windir}\Logs\WindowsUpdate\* for Windows 10 and Windows Server 2016 and later
	if (Test-Path "${ENV:windir}\Logs\WindowsUpdate") {
		Copy-Item "${ENV:windir}\Logs\WindowsUpdate" -Destination "${toLocation}\WindowsUpdate\Logs" -Recurse
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\Logs\WindowsUpdate *** "
	}

	# Copy ${ENV:windir}\WindowsUpdate.log for Windows 7, 8, 2012
	if (Test-Path "${ENV:windir}\WindowsUpdate.log") {
		Copy-Item "${ENV:windir}\WindowsUpdate.log" -Destination "${toLocation}\WindowsUpdate\Logs\WindowsUpdate.log"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\WindowsUpdate.log *** "
	}

	# Copy ${ENV:windir}\Logs\CBS\CBS.log
	if (Test-Path "${ENV:windir}\Logs\CBS\CBS.log") {
		Copy-Item "${ENV:windir}\Logs\CBS" -Destination "${toLocation}" -Recurse -Filter "CBS*.log"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\Logs\CBS\CBS*.log *** "
	}
	
	# Copy ${ENV:windir}\Logs\DISM\dism.log
	if (Test-Path "${ENV:windir}\Logs\DISM\dism.log") {
		Copy-Item "${ENV:windir}\Logs\DISM" -Destination "${toLocation}" -Recurse -Filter "dism*.log"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\Logs\DISM\dism*.log *** "
	}
	
	# Copy ${ENV:SystemDrive}\WindowsUpdateVerbose.etl
	if (Test-Path "${ENV:SystemDrive}\WindowsUpdateVerbose.etl") {
		Copy-Item "${ENV:SystemDrive}\WindowsUpdateVerbose.etl" -Destination "${toLocation}\WindowsUpdate\Logs\WindowsUpdateVerbose.etl"
		Write-Verbose -Message "  *** Copied -  ${ENV:SystemDrive}\WindowsUpdateVerbose.etl *** "
	}

}

###########################################
# Copy event logs - Application and System
###########################################
Function Get-EvtxLogs {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location)
	)

	if (! (Test-Path "${toLocation}\winevt")) { New-Item -ItemType "Directory" "${toLocation}\winevt" | Out-Null }

	if (Test-Path "${ENV:windir}\System32\winevt\Logs\Application.evtx") {
		Copy-Item "${ENV:windir}\System32\winevt\Logs\Application.evtx" -Destination "${toLocation}\winevt\Application.evtx"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\System32\winevt\Logs\Application.evtx *** "
	}
	
	if (Test-Path "${ENV:windir}\System32\winevt\Logs\System.evtx") {
		Copy-Item "${ENV:windir}\System32\winevt\Logs\System.evtx" -Destination "${toLocation}\winevt\System.evtx"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\System32\winevt\Logs\System.evtx *** "
	}
	if (Test-Path "${ENV:windir}\System32\winevt\Logs\Security.evtx") {
		Copy-Item "${ENV:windir}\System32\winevt\Logs\Security.evtx" -Destination "${toLocation}\winevt\Security.evtx"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\System32\winevt\Logs\Security.evtx *** "
	}

	if (Test-Path "${ENV:windir}\System32\winevt\Logs\Setup.evtx") {
		Copy-Item "${ENV:windir}\System32\winevt\Logs\Setup.evtx" -Destination "${toLocation}\winevt\Setup.evtx"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\System32\winevt\Logs\Setup.evtx *** "
	}
	
	if (Test-Path "${ENV:windir}\System32\winevt\Logs\Microsoft-Windows-WindowsUpdateClient%4Operational.evtx") {
		Copy-Item "${ENV:windir}\System32\winevt\Logs\Microsoft-Windows-WindowsUpdateClient%4Operational.evtx" -Destination "${toLocation}\winevt\Microsoft-Windows-WindowsUpdateClient%4Operational.evtx"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\System32\winevt\Logs\Microsoft-Windows-WindowsUpdateClient%4Operational.evtx *** "
	}

	if (Test-Path "${ENV:windir}\System32\winevt\Logs\Microsoft-Windows-Bits-Client%4Operational.evtx") {
		Copy-Item "${ENV:windir}\System32\winevt\Logs\Microsoft-Windows-Bits-Client%4Operational.evtx" -Destination "${toLocation}\winevt\Microsoft-Windows-Bits-Client%4Operational.evtx"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\System32\winevt\Logs\Microsoft-Windows-Bits-Client%4Operational.evtx *** "
	}
	
	if (Test-Path "${ENV:windir}\System32\winevt\Logs\Microsoft-Windows-CAPI2%4Operational.evtx") {
		Copy-Item "${ENV:windir}\System32\winevt\Logs\Microsoft-Windows-CAPI2%4Operational.evtx" -Destination "${toLocation}\winevt\Microsoft-Windows-CAPI2%4Operational.evtx"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\System32\winevt\Logs\Microsoft-Windows-CAPI2%4Operational.evtx *** "
	}

}

###############################
# Retrieve Group Policy result
###############################
Function Get-GPResult {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $GPResultFileName = "GPResult.html"
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "General"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	GPResult /H "${toLocation}\${ChildDir}\${GPResultFileName}"
	Write-Verbose -Message "  *** Generated -  Group Policy Result *** " 
}

########################
# Collect Computer Info
########################
Function Get-SysInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][Switch] $Text,
		[Parameter(Mandatory = $false)][String] $SysInfoFileName = "CompInfo.html"
	)
	
	$ChildDir = "General"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	if ($Text) { $SysInfoFileName = "CompInfo.txt" }
	$SysInfoFile = ("${toLocation}\${ChildDir}" + "\" + $SysInfoFileName)
	
	# Get system info
	$Title = "Computer Information"
	$TitleClientEnv = "Client Environment"
	$TitleSysInfo = "System Information"
	$TitleIPInfo = "Network IP Information"
	$TitleServicesInfo = "Services Information"
	$TitleDualScanInfo = "Dual Scan Verification"
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<div id='mySidenav'><ul><li><a href='#ClientEnv'>$TitleClientEnv</a></li><li><a href='#SysInfo'>$TitleSysInfo</a></li><li><a href='#IPInfo'>$TitleIPInfo</a></li><li><a href='#ServicesInfo'>$TitleServicesInfo</a></li><li><a href='#DualScanCheck'>$TitleDualScanInfo</a></li></ul></div>"
		
		# Get client environment information
		$ClientEnv = Get-Childitem -Path Env:* | Select-Object Name, Value  | ConvertTo-Html -Fragment -PreContent "<h2 id='ClientEnv'>$TitleClientEnv</h2>"
		
		# Computer Sys Information
		# Get-ComputerInfo does not work for Windows Server 2012
		$SysInfo = $Null
		if (Check-Command "Get-ComputerInfo") {
			$SysInfo = Get-ComputerInfo  | ConvertTo-Html -Fragment -PreContent "<h2 id='SysInfo'>$TitleSysInfo</h2>" -as List
			SystemInfo | Out-File "${toLocation}\${ChildDir}\CompInfo.txt"
		} else {
			SystemInfo | Out-File "${toLocation}\${ChildDir}\CompInfo.txt"
			# Create a PowerShell object
			$Props = @{
				File = "${toLocation}\${ChildDir}\CompInfo.txt"
				Location = "<a href=CompInfo.txt>${toLocation}\${ChildDir}\CompInfo.txt</a>"
			}
			$Object = (New-Object PSObject -Property $Props) | ConvertTo-Html -Fragment -PreContent "<h2 id='SysInfo'>$TitleSysInfo</h2>" -as List
			$SysInfo = $Object -replace '&gt;','>' -replace '&lt;','<' -replace '&#39;',"'"
		}
		
		# Network IP
		$IPInfo = Get-NetIPAddress | ConvertTo-Html -Fragment -PreContent "<h2 id='IPInfo'>$TitleIPInfo</h2>" -as List
		$IPInfo = $IPInfo-replace '<td><hr></td>','<td class="hr" colspan="2"></td>'
		# Services Information
		$wmiServices = Get-CimInstance -ClassName win32_service -Property Name,PathName
		$ServicesInfo = Get-Service WUAUServ, BITS, appidsvc, cryptsvc | Select-Object Name, Status, @{Name = 'PathName'; Expression = { $serviceName = $_.Name; (@($wmiServices).Where({ $_.Name -eq $serviceName })).PathName }} | ConvertTo-Html -Fragment -Property Name, Status, PathName -PreContent "<h2 id='ServicesInfo'>$TitleServicesInfo</h2>"
		$ServicesInfo = $ServicesInfo -replace '<td>Running</td>','<td class="GreenStatus">Running</td>' 
		$ServicesInfo = $ServicesInfo -replace '<td>Stopped</td>','<td class="RedStatus">Stopped</td>'
		
		# Dual Scan Verification
		# Source: https://docs.microsoft.com/en-us/archive/blogs/swisspfe/win10-updates-store-gpos-dualscandisabled-sup-wsus
		$MUSM = New-Object -ComObject "Microsoft.Update.ServiceManager"
		$DuanScanCheck = $MUSM.Services | select Name, IsDefaultAUService, ServiceID, ServiceUrl | ConvertTo-Html -Fragment -PreContent "<h2 id='DualScanCheck'>$TitleDualScanInfo</h2>"
		
		$ReportParams = @{
			Body = "$TopicName $ContentTable $ClientEnv $SysInfo $IPInfo $ServicesInfo $DuanScanCheck"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		#$Report = ConvertTo-HTML -Body "$TopicName $ContentTable $ClientEnv $SysInfo $IPInfo $ServicesInfo $DuanScanCheck" -Head $header -Title $Title -PostContent "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		$Report = ConvertTo-HTML @ReportParams
		
		#The command below will generate the report to an HTML file
		$Report | Out-File $SysInfoFile
	} else {
		
		"=== $TitleClientEnv ===" | Out-File $SysInfoFile
		Get-Childitem -Path Env:* | Out-File -Append $SysInfoFile	
		
		"=== $TitleSysInfo ===" | Out-File -Append $SysInfoFile
		Get-ComputerInfo | Out-File -Append $SysInfoFile
		
		"=== $TitleIPInfo ===" | Out-File -Append $SysInfoFile
		Get-NetIPAddress | Out-File -Append $SysInfoFile
		
		"=== $TitleServicesInfo ===" | Out-File -Append $SysInfoFile
		Get-Service WUAUServ, BITS, appidsvc, cryptsvc | Out-File -Append $SysInfoFile
		
		"=== $TitleDualScanInfo ===" | Out-File -Append $SysInfoFile	
		$MUSM = New-Object -ComObject "Microsoft.Update.ServiceManager"
		$DuanScanCheck = $MUSM.Services | select Name, IsDefaultAUService, ServiceID, ServiceUrl
		$DuanScanCheck | Out-File -Append $SysInfoFile
		
		Generate-Footer | Out-File -Append $SysInfoFile
	}
	Write-Verbose -Message "  *** Fetched -  System Information: System, IP, Services, Dual Scan Verification *** "
}

############################################
# Export certificates in MY and SMS and ROOT
############################################
Function Export-Certs {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][Switch] $Text
	)

	# Subdirectory to hold the result file(s)
	$ChildDir = "General\Certificates"
	$Stores = @('Root','MY','SMS')
	Foreach ($Store in $Stores) {
		$FolderPath = "${toLocation}\${ChildDir}\${Store}"
		if (! (Test-Path "$FolderPath")) { New-Item -ItemType "Directory" "$FolderPath" | Out-Null }
		# Get certs in Stores
		$Certs = $(Get-ChildItem -Path "Cert:\LocalMachine\${Store}")
		# Export certs in each store
		Foreach ($Cert in $Certs) {
			$CertTp = $Cert.Thumbprint
			$CertPath = "${FolderPath}\$CertTp" + ".cer"
			Export-Certificate -Force -Cert $Cert -FilePath $CertPath | Out-Null 
		}
	}
	
	Write-Verbose -Message "  *** Exported -  Certificates in Root and MY and SMS *** "
}


##############################################################################################
# Get installed packages of the system
# dism /online /get-packages /format:table
##############################################################################################
Function Get-InstalledPkgs {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $installedPkgsFileName = "InstalledPackages.txt"
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "General"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	$installedPkgsFile = "${toLocation}\${ChildDir}" + "\" +  $installedPkgsFileName
	dism /online /get-packages /format:table > $installedPkgsFile
	
	$OutMsg = "  *** Queried - Get installed packages of the system *** "
	Write-Verbose -Message $OutMsg
}

#########################################
# Fetch Services information
#########################################
Function Get-ServicesInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $ServicesInfoFileName = "ServicesInfo.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	
	$ChildDir = "General"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $ServicesInfoFileName = "ServicesInfo.txt"}
	$ServicesInfoFile = "${toLocation}\${ChildDir}"+ "\" +  $ServicesInfoFileName
	
	$wmiServices = Get-CimInstance -ClassName win32_service -Property Name,PathName
	$ServicesInfo = Get-Service| Select-Object DisplayName, Name, Status, @{Name = 'PathName'; Expression = { $serviceName = $_.Name; (@($wmiServices).Where({ $_.Name -eq $serviceName })).PathName }} | Sort-Object DisplayName
	
	$Title = "Services"
	$OutMsg = "  *** Read - Services information *** "
	$Count = ($ServicesInfo | Measure-Object | Select-Object).Count
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		#$ContentTable = "<h3><a href='#ServicesInfo'>$Title</a></h3>"
		if ($ServicesInfo) {
			$ServicesInfo = $ServicesInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='ServicesInfo'>$Count Service(s)</h2>"
			$ServicesInfo = $ServicesInfo -replace '<td>Running</td>','<td class="GreenStatus">Running</td>' 
			$ServicesInfo = $ServicesInfo -replace '<td>Stopped</td>','<td class="RedStatus">Stopped</td>'
		}
		$ReportParams = @{
			Body = "$TopicName $ServicesInfo"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}

		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $ServicesInfoFile		
	} else {
		"=== $Title - $Count ===" | Out-File $ServicesInfoFile
		if ($ServicesInfo) {
			$ServicesInfo | Out-File -Append $ServicesInfoFile
		}
		Generate-Footer | Out-File -Append $ServicesInfoFile
	}
	Write-Verbose -Message $OutMsg
}

####################################################################################
# Basic communication test between the client and WSUS server
####################################################################################
Function Check-Connection2WSUS {
	Param( 
		[Parameter(Mandatory = $false, Position = 0, ParameterSetName = "Default")]
		[Parameter(Mandatory = $false, Position = 0, ParameterSetName = "Custom")]
		[String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false, ParameterSetName = "Default")]
		[Parameter(Mandatory = $false, ParameterSetName = "Custom")]
		[Switch] $Text,
		[Parameter(Mandatory = $false, ParameterSetName = "Default")][Switch] $TestFromReg, # Test connection to wsus server based on the information registered in the registry
		[Parameter(Mandatory = $true, Position = 0, ParameterSetName = "Custom")][String] $WSUSHostname,
		[Parameter(Mandatory = $true, Position = 1, ParameterSetName = "Custom")][String] $WSUSPort,
		[Parameter(Mandatory = $false,  Position = 1,ParameterSetName = "Default")]
		[Parameter(Mandatory = $false, Position = 2, ParameterSetName = "Custom")]
		[String] $TestResultFileName = "WSUSConnectionTest.html"
	)
	
	$ChildDir = "General"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	if ($Text) { $TestResultFileName = "WSUSConnectionTest.txt" }
	$TestResultFile = ("${toLocation}\${ChildDir}" + "\" + $TestResultFileName)
	if (Test-Path 'HKLM:Software\Policies\Microsoft\Windows\WindowsUpdate') {
		# Split WUServer string value in the registry, eg. http://www.contonso.com:8530, or CMG https://AZCU2CMG.CLOUDAPP.NET/CCM_Proxy_ServerAuth/360287970189640177
		$WUServer = (Get-ItemPropertyValue -ErrorAction SilentlyContinue 'Registry::HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate' -Name WUServer)
		if ($WUServer) {
			# If the client is NOT CMG, WSUS URL should be like http://www.contonso.com:8530
			if (!($WUServer -match ("CCM_Proxy_ServerAuth"))) {
				$WUServerURL = $WUServer -split "://" -split ":"
				$WSUSHostname = $WUServerURL[1]
				$WSUSPort = $WUServerURL[2]
				if ($WSUSPort -eq $Null) {$WSUSPort = "80"}
			} else { # In case of CMG, WSUS URL should be like https://AZCU2CMG.CLOUDAPP.NET/CCM_Proxy_ServerAuth/360287970189640177
				$WUServerURL = $WUServer -split "://" -split "/"
				$WSUSHostname = $WUServerURL[1]
				$WSUSPort = "443"
			}
			
			$Title = "Client to WSUS Server Connection Test"
			if (! $Text) {
				$TopicName = "<h1>$Title</h1>"
				$WSUSPort = $WSUSPort.trim("/")
				$ConnectTestResult = Test-NetConnection $WSUSHostname -Port $WSUSPort | ConvertTo-HTML -Fragment -Property ComputerName, RemoteAddress, RemotePort, InterfaceAias, TcpTestSucceeded, NameResolutionSucceeded, @{Label = "WUServer"; Expression = {$WUServer}} -as List
				$ConnectTestResult = $ConnectTestResult -replace '<td>True</td>','<td class="GreenStatus">True</td>'
				$ConnectTestResult = $ConnectTestResult -replace '<td>False</td>','<td class="RedStatus">False</td>'
				$ReportParams = @{
					Body = "$TopicName $ConnectTestResult"
					Head = $header
					Title = $Title
					PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
				}
				
				$Report = ConvertTo-HTML @ReportParams
				$Report | Out-File $TestResultFile
			} else {
				"=== $Title ===" | Out-File $TestResultFile
				Test-NetConnection $WSUSHostname -Port $WSUSPort | Out-File -Append $TestResultFile
				"WSUS Server: ${WUServer}" | Out-File -Append $TestResultFile
				Generate-Footer | Out-File -Append $TestResultFile
			}
			Write-Verbose -Message "  *** Tested -  Network Connection to WSUS server*** "
		} else {
			"WSUS not configured on this host" | Out-File $TestResultFile
			Generate-Footer | Out-File -Append $TestResultFile
			Write-Verbose -Message "  *** Tested -  Network Connection: WSUS not configured *** "
		}
	}
}

#####################################################################################################
# Get Windows Update History
# Modified based on https://gallery.technet.microsoft.com/scriptcenter/Show-Windows-Update-c7ee69bd
#####################################################################################################
Function Get-WUHistory {
		Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][Switch] $Text,
		[Parameter(Mandatory = $false)][String] $WUHistFileName = "WUHistory.html"
	)
	
	$ChildDir = "General"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	if ($Text) { $WUHistFileName = "WUHistory.txt" }
	$WUHistResultFile = ("${toLocation}\${ChildDir}" + "\" + $WUHistFileName)
	
	$objSession = new-object -com "Microsoft.Update.Session" 
	$objSearcher = $objSession.CreateupdateSearcher() 
	$intCount = $objSearcher.GetTotalHistoryCount() 
	$colHistory = $objSearcher.QueryHistory(0, $intCount) 
	if (! $Text) {
		$TopicName = "<h1>Windows Update History</h1>"
		#$Report = $colHistory | ConvertTo-HTML -PreContent "<h2>${intCount} updates</h2>" -Body $TopicName -Head $header -Property Date, HResult, Title, Description, ClientApplicationID, ServiceID, SupportURL -Title "Windows Update History" -PostContent "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		$Report = $colHistory | Select-Object Title, HResult, Date, Description, ClientApplicationID, ServiceID, SupportURL | ConvertTo-HTML -PreContent "<h2>${intCount} updates</h2>" -Body $TopicName -Head $header -Property Title, @{Label = "HResult"; Expression = {$_.HResult}} , @{Label = "Status"; Expression = {if ($_.HResult -eq 0) {return "Successfully installed"} elseif ($_.HResult -eq -2145116140) {return "Pending Reboot"} else {if (($_.Date).AddMonths(1) -gt (Get-Date)) {return "Failed to install (Error:" + $($_.HResult).ToString('X8') + ")"}}}}, @{Label = "Installation Date (GMT)"; Expression = {$_.Date}}, Description, ClientApplicationID, ServiceID, SupportURL -Title "Windows Update History" -PostContent "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>"
		$Report = $Report -replace '<td>Successfully installed</td>','<td class="GreenStatus">Successfully installed</td>'
		$Report = $Report -replace '<td>Pending Reboot</td>','<td class="OrangeStatus">Pending Reboot</td>'
		$Report = $Report -replace '<td>Failed to install (.*)</td>','<td class="RedStatus">Failed to install $1</td>'
		$Report | Out-File $WUHistResultFile
	} else {
		"=== ${intCount} updates ===" | Out-File $WUHistResultFile
		$colHistory | Out-File -Append $WUHistResultFile
		Generate-Footer | Out-File -Append $WUHistResultFile
	}
	Write-Verbose -Message "  *** Fetched -  Windows Update History *** "
}

##################################################################################################################################
# Interprete EvaluationState of Software Update information
# https://docs.microsoft.com/en-us/mem/configmgr/develop/reference/core/clients/sdk/ccm_softwareupdate-client-wmi-class#properties
##################################################################################################################################
Function Interprete-UpdEvaluationState {
	Param (
		[Parameter(Mandatory = $true)][Int] $StatNum
	)
	switch ($StatNum) {
		0	{"0 - None"}
		1	{"1 - Available"}
		2	{"2 - Submitted"}
		3	{"3 - Detecting"}
		4	{"4 - PreDownload"}
		5	{"5 - Downloading"}
		6	{"6 - WaitInstall"}
		7	{"7 - Installing"}
		8	{"8 - PendingSoftReboot"}
		9	{"9 - PendingHardReboot"}
		10	{"10 - WaitReboot"}
		11	{"11 - Verifying"}
		12	{"12 - InstallComplete"}
		13	{"13 - Error"}
		14	{"14 - WaitServiceWindow"}
		15	{"15 - WaitUserLogon"}
		16	{"16 - WaitUserLogoff"}
		17	{"17 - WaitJobUserLogon"}
		18	{"18 - WaitUserReconnect"}
		19	{"19 - PendingUserLogoff"}
		20	{"20 - PendingUpdate"}
		21	{"21 - WaitingRetry"}
		22	{"22 - WaitPresModeOff"}
		23	{"23 - WaitForOrchestration"}
	}
}

#########################################################
# Query Update Store to get installed and missing updates
#########################################################
Function Query-UpdateStore {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $UPSInfoFileName = "UpdateStore.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $UPSInfoFileName = "UpdateStore.txt"}
	$UPSInfoFile = "${toLocation}\${ChildDir}" + "\" +  $UPSInfoFileName
	
	$UPSInfo =Get-WMIObject -ErrorAction SilentlyContinue -namespace "root\ccm\SoftwareUpdates\UpdatesStore" -query "SELECT * FROM CCM_UpdateStatus" | Select-Object Title, UniqueId, RevisionNumber, Status, SourceType, @{Name="Sources"; Expression={$_.Sources.SourceUniqueId}}, ScanTime, UpdateClassification, ProductID  | Sort-Object -Property Status -Descending
	
	$Title = "Update Store Information"
	$OutMsg = "  *** Read - ROOT\CCM\SoftwareUpdates\UpdatesStore *** "
	$Count = ($UPSInfo | Measure-Object | Select-Object).Count
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<h3><a href='#UPSInfo'>$Title</a></h3>"
		if ($UPSInfo) {
			$UPSInfo = $UPSInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='UPSInfo'>$Count message(s)</h2>"
		}
		$ReportParams = @{
			Body = "$TopicName $UPSInfo"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}

		$Report = ConvertTo-HTML @ReportParams
		$Report = $Report -replace '<td>Installed</td>','<td class="GreenStatus">Installed</td>'
		$Report = $Report -replace '<td>Missing</td>','<td class="RedStatus">Missing</td>'
		#The command below will generate the report to an HTML file
		$Report | Out-File $UPSInfoFile		
	} else {
		"=== $Title - $Count ===" | Out-File $UPSInfoFile
		if ($UPSInfo) {
			$UPSInfo | Out-File -Append $UPSInfoFile
		}
		Generate-Footer | Out-File -Append $UPSInfoFile
	}
	Write-Verbose -Message $OutMsg
}


#############################
# Get client restart history
#############################

Function Get-RebootHistory {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][Switch] $Text,
		[Parameter(Mandatory = $false)][String] $RebootHistFileName = "RebootHistory.html"
	)
	
	$ChildDir = "General"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	if ($Text) { $RebootHistFileName = "RebootHistory.txt" }
	$RebootHistFile = ("${toLocation}\${ChildDir}" + "\" + $RebootHistFileName)

	$Res = Get-WinEvent -FilterHashtable @{logname='System'; id=(1074, 6005, 6006, 6008)}  | ForEach-Object {
		$rv = New-Object PSObject | Select-Object Date, User, Action, Process, Reason, ReasonCode, Comment, Message
		$rv.Date = $_.TimeCreated
		$rv.User = $_.Properties[6].Value
		$rv.Process = $_.Properties[0].Value
		$rv.Action = $_.Properties[4].Value
		$rv.Reason = $_.Properties[2].Value
		$rv.ReasonCode = $_.Properties[3].Value
		$rv.Comment = $_.Properties[5].Value
		$rv.Message = $_.Message
		$rv
		}
	
	$Title = "Reboot History"
	$OutMsg = "  *** Fetched -  Reboot History *** "
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		if ($Res) {
			$Res = $Res | ConvertTo-Html -Fragment
		}
		$ReportParams = @{
			Body = "$TopicName $Res"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		$Report = ConvertTo-HTML @ReportParams
		$Report | Out-File $RebootHistFile
	} else {
		"=== Reboot History ===" | Out-File $RebootHistFile
		$Res | Out-File $RebootHistFile
		Generate-Footer | Out-File -Append $RebootHistFile
	}
	Write-Verbose -Message $OutMsg
}

##====================================================================================================================================##
## SMS Agent part goes here
##====================================================================================================================================##

#################################
# Get accounts info: whoami /all
#################################
Function Get-Whoami {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $WhoamiFileName = "Whoami.txt"
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "General"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	$WhoamiFile = "${toLocation}\${ChildDir}" + "\" +  $WhoamiFileName
	whoami /all | Out-File $WhoamiFile
	Write-Verbose -Message "  *** Fetched - whoami ***"
}

#############################################################
# Fetch client install registry and certificates information
#############################################################
Function Get-ClientRegInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $ClientRegFileName = "ClientRegistry.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $ClientRegFileName = "ClientRegistry.txt"}
	$ClientRegFile = "${toLocation}\${ChildDir}" + "\" +  $ClientRegFileName
	
	$Title = "Configuration Manager Client Registry" 
	$TitleCCM = "CCM"
	$TitleCCMExec = "CCM/CcmExec"
	$TitleCCMSecurity = "CCM/Security"
	$TitleCCMInetFacing = "SMS\Client\Internet Facing"
	$TitleSMSMC = "SMS\Mobile Client"
	$TitleCCMSetup = "CCMSetup"
	$TitleCert = "SMS Certificate"
	$TitleO365 = "Office 365 App"
	$OutMsgCCM = "  *** Read - HKLM\SOFTWARE\Microsoft\CCM *** "
	$OutMsgCCMExec = "  *** Read - HKLM\SOFTWARE\Microsoft\CCM\CcmExec *** "
	$OutMsgCCMSecurity = "  *** Read - HKLM\SOFTWARE\Microsoft\CCM\Security *** "
	$OutMsgCCMInetFacing = "  *** Read - HKLM\SOFTWARE\Microsoft\Internet Facing *** "
	$OutMsgCCMSetup = "  *** Read - HKLM:SOFTWARE\Microsoft\CCMSetup *** "
	$OutMsgSMSMC = "  *** Read - HKLM\SOFTWARE\Microsoft\SMS\Mobile Client *** "
	$OutMsgCert = "  *** Read - cert:LocalMachine\SMS *** "
	$OutMsgO365 = "  *** Read - O365 registry *** "
	
	$CCMRegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\CCM'
	$CCMExecRegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\CCM\CcmExec'
	$CCMSecurityRegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\CCM\Security'
	if ($CCMSecurityRegInfo.SigningCertificate) {
		$FileName = "SiteServerSigningCertificate"
		$SiteSignCertPath = $(Decode-Cert -toLocation $toLocation -InputHex $CCMSecurityRegInfo.SigningCertificate -InputFileName "$FileName.txt" -OutputFileName "$FileName.cer")
	}
	$CCMSecurityRegInfo = $CCMSecurityRegInfo| Select-Object "Certificate Store", "Certificate Issuers", "Certificate Selection Criteria", "Select First Certificate", "PKICertOptions", "ClientAlwaysOnInternet", "Hash Algorithm", "Hash Algorithm Id", "Encryption Algorithm", "Encryption Algorithm Id", @{Name="SigningCertificate (Site Server Signing Certificate)";Expression={$_.SigningCertificate}}, @{Name="(Site Server Signing Certificate)";Expression={$SiteSignCertPath}}, PSPath
	
	$CCMInetFacingRegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\Software\Microsoft\SMS\Client\Internet Facing'
	$SMSMCRegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\SMS\Mobile Client'
	$CCMSetupInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\CCMSetup' 
	$SMSCertInfo = Get-ChildItem -ErrorAction SilentlyContinue 'cert:LocalMachine\SMS'
	$O365CLSIDInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKCR\CLSID\{B7F1785F-D69B-46F1-92FC-D2DE9C994F13}\InProcServer32' 
	$O365ConfigInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\Office\ClickToRun\Configuration' 
	
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<div id='mySidenav'><ul><li><a href='#CCMRegInfo'>$TitleCCM</a></li><li><a href='#CCMExecRegInfo'>$TitleCCMExec</a></li><li><a href='#CCMSecurityRegInfo'>$TitleCCMSecurity</a></li><li><a href='#CCMInetFacingRegInfo'>$TitleCCMInetFacing</a></li><li><a href='#SMSMCRegInfo'>$TitleSMSMC</a></li><li><a href='#CCMSetupInfo'>$TitleCCMSetup</a></li><li><a href='#SMSCertInfo'>$TitleCert</a></li><li><a href='#O365'>$TitleO365</a></li></ul></div>"

		if ($CCMRegInfo) {
			$CCMRegInfo = $CCMRegInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='CCMRegInfo'>$TitleCCM</h2>" -as List
		}

		if ($CCMExecRegInfo) {
			$CCMExecRegInfo = $CCMExecRegInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='CCMExecRegInfo'>$TitleCCMExec</h2>" -as List
			$CCMExecRegInfo = $CCMExecRegInfo -replace '<td>ProvisioningMode:</td><td>True</td>','<td>ProvisioningMode:</td><td class="RedStatus">True</td>'
			$CCMExecRegInfo = $CCMExecRegInfo -replace '<td>ProvisioningMode:</td><td>False</td>','<td>ProvisioningMode:</td><td class="GreenStatus">False</td>'
		}
		
		if ($CCMSecurityRegInfo) {
			$CCMSecurityRegInfo = $CCMSecurityRegInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='CCMSecurityRegInfo'>$TitleCCMSecurity</h2>" -as List
		}
		
		if ($CCMInetFacingRegInfo) {
			$CCMInetFacingRegInfo = $CCMInetFacingRegInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='CCMInetFacingRegInfo'>$TitleCCMInetFacing</h2>" -as List
		}
		
		if ($SMSMCRegInfo) {
			$SMSMCRegInfo = $SMSMCRegInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='SMSMCRegInfo'>$TitleSMSMC</h2>" -as List
		}
		
		if ($CCMSetupInfo) {
			$CCMSetupInfo = $CCMSetupInfo | ConvertTo-Html  -Fragment -PreContent "<h2 id='CCMSetupInfo'>$TitleCCMSetup</h2>" -as List
		}
		
		if ($SMSCertInfo) {
			$SMSCertInfo = $SMSCertInfo | Select-Object Subject, Version, Thumbprint, FriendlyName, SendAsTrustedIssuer, Issuer, NotAfter, NotBefore, HasPrivateKey, Archived, SerialNumber, DnsNameList, PSIsContainer, EnhancedKeyUsageList | ConvertTo-Html -Fragment -PreContent "<h2 id='SMSCertInfo'>$TitleCert</h2>"
		}

		if ($O365CLSIDInfo -or $O365ConfigInfo) {
			$O365CLSIDInfo = $O365CLSIDInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='O365'>$TitleO365</h2>" -as List
			$O365ConfigInfo = $O365ConfigInfo | ConvertTo-Html -Fragment -as List #-PreContent "<h2 id='O365'>$TitleCert</h2>"
		}		
		
		$ReportParams = @{
			Body = "$TopicName $ContentTable $CCMRegInfo $CCMExecRegInfo $CCMSecurityRegInfo $CCMInetFacingRegInfo $SMSMCRegInfo $CCMSetupInfo $SMSCertInfo $O365CLSIDInfo $O365ConfigInfo"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		
		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $ClientRegFile
	} else {
		"=== $TitleCCM ===" | Out-File $ClientRegFile
		if ($CCMRegInfo) {
			$CCMRegInfo | Out-File -Append $ClientRegFile
		}
		
		"=== $TitleCCMExec ===" | Out-File -Append $ClientRegFile
		if ($CCMExecRegInfo) {
			$CCMExecRegInfo | Out-File -Append $ClientRegFile
		}
		
		"=== $TitleCCMSecurity ===" | Out-File -Append $ClientRegFile
		if ($CCMSecurityRegInfo) {
			$CCMSecurityRegInfo | Out-File -Append $ClientRegFile
		}
		
		"=== $TitleCCMInetFacing ===" | Out-File -Append $ClientRegFile
		if ($CCMInetFacingRegInfo) {
			$CCMInetFacingRegInfo | Out-File -Append $ClientRegFile
		}
		
		"=== $TitleSMSMC ===" | Out-File -Append $ClientRegFile
		if ($SMSMCRegInfo) {
			$SMSMCRegInfo | Out-File -Append $ClientRegFile
		}
		
		"=== $TitleCCMSetup ===" | Out-File -Append $ClientRegFile
		if ($CCMSetupInfo) {
			$CCMSetupInfo | Out-File -Append $ClientRegFile
		}
		
		"=== $TitleCert ===" | Out-File -Append $ClientRegFile
		if ($SMSCertInfo) {
			$SMSCertInfo | Select-Object Subject, Version, Thumbprint, FriendlyName, SendAsTrustedIssuer, Issuer, NotAfter, NotBefore, HasPrivateKey, Archived, SerialNumber, DnsNameList, PSIsContainer, EnhancedKeyUsageList | Out-File -Append $ClientRegFile
		}
		"=== $TitleO365 ===" | Out-File -Append $ClientRegFile
		if ($O365CLSIDInfo -or $O365ConfigInfo) {
			$O365CLSIDInfo | Out-File -Append $ClientRegFile
			$O365ConfigInfo | Out-File -Append $ClientRegFile
		}
		Generate-Footer | Out-File -Append $ClientRegFile
	}
	Write-Verbose -Message $OutMsgCCM 
	Write-Verbose -Message $OutMsgCCMExec
	Write-Verbose -Message $OutMsgCCMSecurity
	Write-Verbose -Message $OutMsgCCMInetFacing
	Write-Verbose -Message $OutMsgSMSMC
	Write-Verbose -Message $OutMsgCCMSetup 
	Write-Verbose -Message $OutMsgCert
	Write-Verbose -Message $OutMsgO365 
}

####################################################################
# Fetch My certificates (LocalMachine\My) information on the client
####################################################################
Function Get-ClientMyCertInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $MyCertFileName = "MyCertificates.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $MyCertFileName = "MyCertificates.txt"}
	$MyCertFile = "${toLocation}\${ChildDir}" + "\" +  $MyCertFileName
	
	$Title = "My Certificates Information" 
	$TitleCert = "My Certificate"
	$OutMsgCert = "  *** Read - cert:LocalMachine\My *** "
	
	$MyCertInfo = Get-ChildItem -ErrorAction SilentlyContinue 'cert:LocalMachine\My'
	$Count = ($MyCertInfo | Measure-Object | Select-Object).Count
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		#$ContentTable = "<h3><h3><a href='#MyCertInfo'>$TitleCert</a></h3><hr>"

		if ($MyCertInfo) {
			$MyCertInfo = $MyCertInfo | Select-Object * | ConvertTo-Html -Fragment -PreContent "<h2 id='MyCertInfo'>$Count certificate(s)</h2>" -As List
		}	
		
		$ReportParams = @{
			Body = "$TopicName $MyCertInfo"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		
		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $MyCertFile
	} else {
		"=== $TitleCert - $Count ===" | Out-File -Append $MyCertFile
		if ($MyCertInfo) {
			$MyCertInfo | Select-Object * | Out-File -Append $MyCertFile
		}
		Generate-Footer | Out-File -Append $MyCertFile
	}
	
	Write-Verbose -Message $OutMsgCert 
}

###################################################################################################################################
# Fetch Management Point information
## That SMS_MPInformation and SMS_MPList are populated does not guarantee SMS Agent can work properly
## SMS_MPInformationEx and SMS_MPListEx must be populated for SMS Agent to work properly
## https://sccmpeek.wordpress.com/2022/04/28/sccm-agent-has-only-two-actions-after-installation-with-ccmverifymsgsignature-failed/
###################################################################################################################################
Function Get-MPInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][Switch] $Text,
		[Parameter(Mandatory = $false)][String] $MPInfoFileName = "ManagementPoints.html"
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $MPInfoFileName = "ManagementPoints.txt" }
	$MPInfoFile = ("${toLocation}\${ChildDir}" + "\" + $MPInfoFileName)
	
	# Define titles
	$Title = "Management Point(s) Information"
	$TitleMPEx = "Management Point(s) Ex"
	$TitleActiveMPInfo = "All Active Management Point(s)"
	
	# Get Management Point Ex information
	$MPEx = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\LocationServices" -Class SMS_MPInformationEx
	
	$MPEx = $MPEx | Select-Object MP, SiteCode, IsProxy, MPLastRequestTime, MPLastUpdateTime, Reserved1, Reserved2, @{Name="Thumbprint1 (MP Signing Cert)";Expression={$_.Thumbprint1}}, @{Name="(MP Signing Certificate)";Expression={if ($_.Thumbprint1) {$FileName = "SMSSigningCertificate-" + $_.MP;	$SMSSignCertPath = $(Decode-Cert -toLocation $toLocation -InputHex $_.Thumbprint1 -InputFileName "$FileName.txt" -OutputFileName "$FileName.cer"); $SMSSignCertPath}}}, @{Name="Thumbprint2 (MP Encryption Cert)";Expression={$_.Thumbprint2}}, @{Name="(MP Encryption Certificate)";Expression={if ($_.Thumbprint2) {$FileName = "SMSEncryptionCertificate-" + $_.MP; $SMSEncryptCertPath = $(Decode-Cert -toLocation $toLocation -InputHex $_.Thumbprint2 -InputFileName "$FileName.txt" -OutputFileName "$FileName.cer");$SMSEncryptCertPath}}}
	$MPExCount = ($MPEx | Measure-Object | Select-Object).Count
	
	# Get all available active Management Point(s)
	$ActiveMPInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\LocationServices" -Class SMS_ActiveMPCandidate | Select-Object MP, Type, Locality, Version, SiteCode, State, Protocol, MPFallbackTime, MasterSiteCode, Index, Capabilities, MPBGRFallbackType, Reserved1, Reserved2
	$ActiveMPInfoCount = ($ActiveMPInfo | Measure-Object | Select-Object).Count
	
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<div id='mySidenav'><ul><li><a href='#MPEx'>$TitleMPEx</a></li><li><a href='#ActiveMPInfo'>$TitleActiveMPInfo</a></li></ul></div>"
		
		# Convert Management Point Ex into HTML
		$MPEx = $MPEx  | ConvertTo-Html -Fragment -PreContent "<h2 id='MPEx'>$TitleMPEx - $MPExCount</h2>" -As List
		$MPEx = $MPEx-replace '<td><hr></td>','<td class="hr" colspan="2"></td>'
		
		# Convert Active Management Point info into HTML
		$ActiveMPInfo = $ActiveMPInfo  | ConvertTo-Html -Fragment -PreContent "<h2 id='ActiveMPInfo'>$TitleActiveMPInfo - $ActiveMPInfoCount</h2>"

		$ReportParams = @{
			Body = "$TopicName $ContentTable $MPEx $ActiveMPInfo"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}

		$Report = ConvertTo-HTML @ReportParams
		
		#The command below will generate the report to an HTML file
		$Report | Out-File $MPInfoFile
	} else {
		
		"=== $TitleMPEx - $MPExCount ===" | Out-File $MPInfoFile
		$MPEx | Out-File -Append $MPInfoFile
		
		"=== $TitleActiveMPInfo - $ActiveMPInfoCount ===" | Out-File -Append $MPInfoFile
		$ActiveMPInfo | Out-File -Append $MPInfoFile
		
		Generate-Footer | Out-File -Append $MPInfoFile
	}
	Write-Verbose -Message "  *** Fetched -  Management Point(S) Information *** "
}

#####################################
# Fetch BGB configuration
#####################################
Function Get-BGBConfig {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][Switch] $Text,
		[Parameter(Mandatory = $false)][String] $BGBConfigFileName = "BGBConfiguration.html"
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $BGBConfigFileName = "BGBConfiguration.txt" }
	$BGBConfigFile = ("${toLocation}\${ChildDir}" + "\" + $BGBConfigFileName)
	
	# Define titles
	$Title = "BGB Configuration Information"
	$TitleBGBCLIConfig = "BGB Client Configuration"
	$TitleBGBComConfig = "BGB Communication Configuration"
	
	# Get BGB client configuration
	$BGBCLIConfig = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\Policy\Machine\ActualConfig:CCM_BGBClientConfig" -Query "SELECT * FROM CCM_BGBClientConfig" | Select-Object ComponentName, Enabled
	
	# Get BGB communication configuration
	$BGBComConfig = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\Policy\Machine\ActualConfig:CCM_BGBCommunicationConfig" -Query "SELECT * FROM CCM_BGBCommunicationConfig" | Select-Object EnableHttpListener, EnableTcpListener, HttpKeepAliveInterval, TcpKeepAliveInterval, TcpPortNumber
	
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<div id='mySidenav'><ul><li><a href='#BGBCLIConfig'>$TitleBGBCLIConfig</a></li><li><a href='#BGBComConfig'>$TitleBGBComConfig</a></li></ul></div>"
		
		# Convert Management Point Ex into HTML
		$BGBCLIConfig = $BGBCLIConfig  | ConvertTo-Html -Fragment -PreContent "<h2 id='BGBCLIConfig'>$TitleBGBCLIConfig</h2>"
		$BGBCLIConfig = $BGBCLIConfig -replace '<td>True</td>','<td class="GreenStatus">True</td>'
		$BGBCLIConfig = $BGBCLIConfig -replace '<td>False</td>','<td class="RedStatus">False</td>'
		
		# Convert Active Management Point info into HTML
		$BGBComConfig = $BGBComConfig  | ConvertTo-Html -Fragment -PreContent "<h2 id='BGBComConfig'>$TitleBGBComConfig</h2>"

		$ReportParams = @{
			Body = "$TopicName $ContentTable $BGBCLIConfig $BGBComConfig"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}

		$Report = ConvertTo-HTML @ReportParams
		
		#The command below will generate the report to an HTML file
		$Report | Out-File $BGBConfigFile
	} else {
		"=== $TitleBGBCLIConfig ===" | Out-File $BGBConfigFile
		$BGBCLIConfig | Out-File -Append $BGBConfigFile
		
		"=== $TitleBGBComConfig ===" | Out-File -Append $BGBConfigFile
		$BGBComConfig | Out-File -Append $BGBConfigFile
		
		Generate-Footer | Out-File -Append $BGBConfigFile
	}
	Write-Verbose -Message "  *** Fetched -  BGB Configuration Information *** "
}

################################################################
# Fetch Software Update Point information and last scan history
################################################################
Function Get-SUPInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $SUPInfoFileName = "SoftwareUpdatePoints.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $SUPInfoFileName = "SoftwareUpdatePoints.txt"}
	$SUPInfoFile = "${toLocation}\${ChildDir}" + "\" +  $SUPInfoFileName
	
	# SUP Info
	$SUPInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\ScanAgent:CCM_SUPLocationList" -Query "SELECT * FROM CCM_SUPLocationList" | Select-Object CurrentScanPath, FirstScanFailTime, KeepSupAffinity, LastSuccessScanPath, ScanMethod, StartOver, SUPLocations
	# Last scan history
	$SUPScanHistInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\ScanAgent:CCM_ScanUpdateSourceHistory" -Query "SELECT * FROM CCM_ScanUpdateSourceHistory" | Select-Object UpdateSourceID, UpdateSourceVersion, ScanMethod, @{Name="LastCompletionTime (GMT)"; Expression={($_.LastCompletionTime.SubString(0,4), $_.LastCompletionTime.SubString(4,2),$_.LastCompletionTime.SubString(6,2), $_.LastCompletionTime.SubString(8,2), $_.LastCompletionTime.SubString(10,2), $_.LastCompletionTime.SubString(12)) -join "-"}}, ScanContentType, ChangeSUP, Valid, ValidTTL, PerformedCatScanLast
	
	$Title = "Software Update Point(s)"
	$TitleSUP = "Current Software Update Point(s)"
	$TitleSUPScanHist = "Scan Update Source History"
	$OutMsg = "  *** Read - ROOT\ccm\ScanAgent:CCM_SUPLocationList & CCM_SUPLocationList *** "
	$Count = ($SUPInfo | Measure-Object | Select-Object).Count
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<div id='mySidenav'><ul><li><a href='#SUPInfo'>$TitleSUP</a></li><li><a href='#SUPScanHistInfo'>$TitleSUPScanHist</a></li></ul></div>"
		if ($SUPInfo) {
			$SUPInfo = $SUPInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='SUPInfo'>$Count SUP(s)</h2>" -as List
		}
		
		if ($SUPScanHistInfo) {
			$SUPScanHistInfo = $SUPScanHistInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='SUPScanHistInfo'>$TitleSUPScanHist</h2>" -as List
		}
		$ReportParams = @{
			Body = "$TopicName $ContentTable $SUPInfo $SUPScanHistInfo"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}

		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $SUPInfoFile		
	} else {
		"=== $TitleSUP - $Count ===" | Out-File $SUPInfoFile
		if ($SUPInfo) {
			$SUPInfo | Out-File -Append $SUPInfoFile
		}
		
		"=== $TitleSUPScanHist ===" | Out-File -Append $SUPInfoFile
		if ($SUPScanHistInfo) {
			$SUPScanHistInfo | Out-File -Append $SUPInfoFile
		}
		Generate-Footer | Out-File -Append $SUPInfoFile
	}
	Write-Verbose -Message $OutMsg
}

##############################################################################################################################################################
# Fetch Trusted Root Key
# Locations:
## On site server, MP, DP: Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\SMS\Security: TrustedRootKey
## On the client WMI: ROOT\ccm\LocationServices:TrustedRootKey
## On site server: C:\Program Files\Microsoft Configuration Manager\bin\i386\mobileclient.tcf
# https://docs.microsoft.com/en-us/mem/configmgr/core/plan-design/security/configure-security#pre-provision-a-client-with-the-trusted-root-key-by-using-a-file
###############################################################################################################################################################
Function Get-TRKey {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $TRKeyInfoFileName = "TrustedRootkey.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $TRKeyInfoFileName = "TrustedRootkey.txt"}
	$TRKeyInfoFile = "${toLocation}\${ChildDir}" + "\" +  $TRKeyInfoFileName
	
	$TRKeyInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\LocationServices" -Class TrustedRootKey
	$FileName = "MPSignCert-TRK-" + $TRKeyInfo.MPName
	$CertName = "MPSigningCertificate-TRK-" + $TRKeyInfo.MPName
	if ($TRKeyInfo.MPCertificate) { $MPSignCertPath = $(Decode-Cert -toLocation $toLocation -InputHex $TRKeyInfo.MPCertificate -InputFileName "$FileName.txt" -OutputFileName "$CertName.cer") }
	$TRKeyInfo = $TRKeyInfo| Select-Object MPName, SiteCode, Reserved1, Reserved2, TrustedRootKey, VirtualMP, MPCertificate, @{Name="(SigningCertificate Path)";Expression={$MPSignCertPath}}
	
	$Title = "Trusted Root Key"
	$OutMsg = "  *** Read - ROOT\ccm\LocationServices:TrustedRootKey *** "

	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		#$ContentTable = "<h3><a href='#TRKeyInfo'>$Title</a></h3>"
		if ($TRKeyInfo) {
			$TRKeyInfo = $TRKeyInfo | ConvertTo-Html -Fragment -as List
		}
		$ReportParams = @{
			Body = "$TopicName $TRKeyInfo"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		#$Report = ConvertTo-HTML -Body "$TopicName $ContentTable $TRKeyInfo" -Head $header -Title "Software Update Point Information" -PostContent "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $TRKeyInfoFile		
	} else {
		"=== $Title ===" | Out-File $TRKeyInfoFile
		if ($TRKeyInfo) {
			$TRKeyInfo | Out-File -Append $TRKeyInfoFile
		}
		Generate-Footer | Out-File -Append $TRKeyInfoFile
	}
	Write-Verbose -Message $OutMsg
}

######################################################################################################################################################################
# Fetch Steate Message information
# https://docs.microsoft.com/en-us/mem/configmgr/core/plan-design/hierarchy/state-messaging-system-center-configuration-manager#402-state_topictype_sum_ci_enforcement
######################################################################################################################################################################
Function Get-StateMsgInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $StatMsgInfoFileName = "StateMessages.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $StatMsgInfoFileName = "StateMessages.txt"}
	$StatMsgInfoFile = "${toLocation}\${ChildDir}" + "\" +  $StatMsgInfoFileName
	
	$StatMsgInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\StateMsg:CCM_StateMsg" -Query "SELECT * FROM CCM_StateMsg" | Select-Object TopicID, TopicType, StateID, TopicIDType, MessageSent, @{Name="MessageTime"; Expression={($_.MessageTime.SubString(0,4), $_.MessageTime.SubString(4,2),$_.MessageTime.SubString(6,2), $_.MessageTime.SubString(8,2), $_.MessageTime.SubString(10,2), $_.MessageTime.SubString(12)) -join "-"}}, UserSID, User,UserFlags, Criticality, ParamCount, Priority,Reserved1, Reserved2, Reserved3, StateDetails, StateDetailsType, UserParameters | Sort-Object -Property MessageTime -Descending    
	
	$Title = "State Messages"
	$OutMsg = "  *** Read - ROOT\ccm\StateMsg:CCM_StateMsg *** "
	$Count = ($StatMsgInfo | Measure-Object | Select-Object).Count
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		#$ContentTable = "<h3><a href='#StatMsgInfo'>$Title</a></h3>"
		if ($StatMsgInfo) {
			$StatMsgInfo = $StatMsgInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='StatMsgInfo'>$Count message(s)</h2>"
		}
		$ReportParams = @{
			Body = "$TopicName $StatMsgInfo"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		#$Report = ConvertTo-HTML -Body "$TopicName $ContentTable $StatMsgInfo" -Head $header -Title "Software Update Point Information" -PostContent "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		$Report = ConvertTo-HTML @ReportParams
		$Report = $Report -replace '<td>True</td>','<td class="GreenStatus">True</td>'
		$Report = $Report -replace '<td>False</td>','<td class="RedStatus">False</td>'
		#The command below will generate the report to an HTML file
		$Report | Out-File $StatMsgInfoFile		
	} else {
		"=== $Title - $Count ===" | Out-File $StatMsgInfoFile
		if ($StatMsgInfo) {
			$StatMsgInfo | Out-File -Append $StatMsgInfoFile
		}
		Generate-Footer | Out-File -Append $StatMsgInfoFile
	}
	Write-Verbose -Message $OutMsg
}

#####################################################################################################################
# Fetch Service Window type details
# https://docs.microsoft.com/en-us/previous-versions/system-center/developer/jj155419(v=cmsdk.12)?redirectedfrom=MSDN
#####################################################################################################################

Function Interprete-ServiceWindowType {
	Param (
		[Parameter(Mandatory = $true)][Int] $SWNum
	)
	switch ($SWNum) {
		1	{"1 - All Programs Service Window"}
		2	{"2 - Program Service Window"}
		3	{"3 - Reboot Required Service Window"}
		4	{"4 - Software Update Service Window"}
		5	{"5 - OSD Service Window"}
		6	{"6 - Non-working hours"}
	}
}

#########################################
# Fetch Service Window information
#########################################
Function Get-ServiceWindowInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $SVCWinInfoFileName = "ServiceWindows.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $SVCWinInfoFileName = "ServiceWindows.txt"}
	$SVCWinInfoFile = "${toLocation}\${ChildDir}" + "\" +  $SVCWinInfoFileName
	
	$SVCWinInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\ClientSDK:CCM_ServiceWindow" -Query "SELECT * FROM CCM_ServiceWindow" | Select-Object @{Name="StartTime"; Expression={($_.StartTime.SubString(0,4), $_.StartTime.SubString(4,2),$_.StartTime.SubString(6,2), $_.StartTime.SubString(8,2), $_.StartTime.SubString(10,2), $_.StartTime.SubString(12)) -join "-"}}, @{Name="EndTime"; Expression={($_.EndTime.SubString(0,4), $_.EndTime.SubString(4,2),$_.EndTime.SubString(6,2), $_.EndTime.SubString(8,2), $_.EndTime.SubString(10,2), $_.EndTime.SubString(12)) -join "-"}}, Duration, @{Name="Type";Expression={Interprete-ServiceWindowType($_.Type)}}, ID
	
	$Title = "Service Window(s)"
	$OutMsg = "  *** Read - ROOT\ccm\ClietnSDK:CCM_ServiceWindow *** "
	$Count = ($SVCWinInfo | Measure-Object | Select-Object).Count
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		#$ContentTable = "<h3><a href='#SVCWinInfo'>$Title</a></h3>"
		if ($SVCWinInfo) {
			$SVCWinInfo = $SVCWinInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='SVCWinInfo'>$Count service window(s)</h2>"
		}
		$ReportParams = @{
			Body = "$TopicName $SVCWinInfo"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		#$Report = ConvertTo-HTML -Body "$TopicName $ContentTable $SVCWinInfo" -Head $header -Title "Software Update Point Information" -PostContent "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $SVCWinInfoFile		
	} else {
		"=== $Title - $Count ===" | Out-File $SVCWinInfoFile
		if ($SVCWinInfo) {
			$SVCWinInfo | Out-File -Append $SVCWinInfoFile
		}
		Generate-Footer | Out-File -Append $SVCWinInfoFile
	}
	Write-Verbose -Message $OutMsg
}


###################################################################################################################################
# Interprete Metered Network Usage
# https://docs.microsoft.com/en-us/mem/configmgr/develop/reference/core/clients/sdk/ccm_networksettings-client-wmi-class#properties
###################################################################################################################################
Function Interprete-MeteredNetworkUsage {
	Param (
		[Parameter(Mandatory = $true)][Int] $StatNum
	)
	switch ($StatNum) {
		0	{"0 - Unknown"}
		1	{"1 - Allow"}
		2	{"2 - Limit"}
		4	{"3 - Block"}
	}
}

###############################################################################################################################
# Interprete EvaluationState of Application information
# https://docs.microsoft.com/en-us/mem/configmgr/develop/reference/core/clients/sdk/ccm_application-client-wmi-class#properties
###############################################################################################################################
Function Interprete-AppEvaluationState {
	Param (
		[Parameter(Mandatory = $true)][Int] $StatNum
	)
	switch ($StatNum) {
		0	{"0 - No state information is available"}
		1	{"1 - Application is enforced to desired/resolved state"}
		2	{"2 - Application is not required on the client"}
		3	{"3 - Application is available for enforcement (install or uninstall based on resolved state). Content may/may not have been downloaded"}
		4	{"4 - Application last failed to enforce (install/uninstall)"}
		5	{"5 - Application is currently waiting for content download to complete"}
		6	{"6 - Application is currently waiting for content download to complete"}
		7	{"7 - Application is currently waiting for its dependencies to download"}
		8	{"8 - Application is currently waiting for a service (maintenance) window"}
		9	{"9 - Application is currently waiting for a previously pending reboot"}
		10	{"10 - Application is currently waiting for serialized enforcement"}
		11	{"11 - Application is currently enforcing dependencies"}
		12	{"12 - Application is currently enforcing"}
		13	{"13 - Application install/uninstall enforced and soft reboot is pending"}
		14	{"14 - Application installed/uninstalled and hard reboot is pending"}
		15	{"15 - Update is available but pending installation"}
		16	{"16 - Application failed to evaluate"}
		17	{"17 - Application is currently waiting for an active user session to enforce"}
		18	{"18 - Application is currently waiting for all users to logoff"}
		19	{"19 - Application is currently waiting for a user logon"}
		20	{"20 - Application in progress, waiting for retry"}
		21	{"21 - Application is waiting for presentation mode to be switched off"}
		22	{"22 - Application is pre-downloading content (downloading outside of install job)"}
		23	{"23 - Application is pre-downloading dependent content (downloading outside of install job)"}
		24	{"24 - Application download failed (downloading during install job)"}
		25	{"25 - Application pre-downloading failed (downloading outside of install job)"}
		26	{"26 - Download success (downloading during install job)"}
		27	{"27 - Post-enforce evaluation"}
		28	{"28 - Waiting for network connectivity"}
	}
}

##################################################
# Fetch Application Deployment deails information
##################################################
Function Get-AppDeploymentDetail {
	Param( 
		[Parameter(Mandatory = $false, Position = 0)][String] $AppID,
		[Parameter(Mandatory = $false, Position = 1)][String] $AppRevision
	)

	$Res = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\ClientSDK:CCM_ApplicationPolicy" -Query "SELECT * FROM CCM_ApplicationPolicy" | Where-Object {$_.Id -match ($AppID -split "_")[2] -and $_.Revision -eq $AppRevision} | Select-Object -Property DeploymentReport
	$Res.DeploymentReport
}

############################################
# Fetch Client Settings information
############################################
Function Get-ClientSettings {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $ClientSettingsFileName = "ClientSettings.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $ClientSettingsFileName = "ClientSettings.txt"}
	$ClientSettingsFile = "${toLocation}\${ChildDir}" + "\" +  $ClientSettingsFileName
	
	$Title = "Client Settings"
	$TitleBITS = "Background Intelligent Transfer"
	$TitleClientCache = "Client Cache"
	$TitleCloudServices = "Cloud Services"
	$TitleComputerAgent = "Computer Agent"
	$TitleComputerRestart = "Computer Restart"
	$TitleDOpt = "Delivery Optimization"
	$TitleEndProt = "Endpoint Protection"
	$TitleHardInv = "Hardware Inventory"
	$TitleMeteredNetwork = "Metered Network"
	$TitleSoftC = "Software Center"
	$TitleSoftwareUpdates = "Software Updates"
	$TitleUserDevAff = "User Device Affinity"
	$OutMsgClientSettings = "  *** Read - HKLM:Software\Policies\Microsoft\Windows\WindowsUpdate *** "
	
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#background-intelligent-transfer-service-bits
	$BITS = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_Service_BITS2Configuration" | Select-Object -Property @{Name="Limit the maximum network bandwidth for BITS background transfers";Expression={$_.EnableBitsMaxBandwidth}}, @{Name="Throttling window start time";Expression={$_.MaxBandwidthValidFrom}}, @{Name="Throttling window end time";Expression={$_.MaxBandwidthValidTo}}, @{Name="Maximum transfer rate outside the throttling window (Kbps)";Expression={$_.MaxTransferRateOffSchedule}}, @{Name="Maximum transfer rate during throttling window (Kbps)";Expression={$_.MaxTransferRateOnSchedule}}, Reserved1, Reserved2, Reserved3

	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#client-cache-settings
	$SoftDistClientConfig = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_SoftwareDistributionClientConfig"
	$TombMinDuration = $SoftDistClientConfig.CacheTombstoneContentMinDuration
	$ClientCache = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_SuperPeerClientConfig" | Select-Object -Property @{Name="Enable BranchCache";Expression={$_.BranchCacheEnabled}}, @{Name="Configure BranchCache";Expression={$_.ConfigureBranchCache}}, @{Name="Maximum BranchCache cache size (percentage of disk)";Expression={$_.MaxBranchCacheSizePercent}}, @{Name="Minimum duration before the client can remove cached content (seconds)";Expression={$TombMinDuration}}, @{Name="Configure Client Cache Size";Expression={$_.ConfigureCacheSize}}, @{Name="Maximum cache size (MB)";Expression={$_.MaxCacheSizeMB}}, @{Name="Maximum cache size (percentage of disk)";Expression={$_.MaxCacheSizePercent}}, @{Name="Enable as peer cache source";Expression={$_.CanBeSuperPeer}}, @{Name="Port for initial network broadcast";Expression={$_.BroadcastPort}}, CachePartialContent, ComponentName, Enabled, HttpPort, HttpsEnabled, MaxAvgDiskQueueLength, MaxConnectionCountOnClients, MaxConnectionCountOnServers, MaxPercentProcessorTime, RejectWhenBatteryLow, Reserved1, Reserved2, Reserved3, SiteSettingsKey, UsePartialSource
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#cloud-services
	$CloudServices = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_CloudClientConfig" | Select-Object -Property AADAuthFlags, AllowCloudDP, AllowCMG, AutoAADJoin, AutoMDMEnrollment, CoManagementFlags, ComponentName, Enabled, Reserved1, Reserved2, Reserved3, SiteSettingsKey
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#computer-agent
	$ComputerAgent = Get-WmiObject -ErrorAction SilentlyContinue -ComputerName localhost -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Query "SELECT * FROM CCM_ClientAgentConfig" | Select-Object -Property @{Name="Organization name displayed in Software Center"; Expression={$_.BrandingTitle}}, ComponentName, @{Name="Deployment deadline less than 24 hours, remind user every (seconds)"; Expression={$_.DayReminderInterval}}, DevicesHealthCollectionEnabled, @{Name="Show notifications for new deployments"; Expression={$_.DisplayNewProgramNotification}}, Enabled, EnableHealthAttestation, @{Name="Additional software manages the deployment of applications and software updates"; Expression={$_.EnableThirdPartyOrchestration}}, @{Name="Grace period for enforcement after deployment deadline (hours)"; Expression={$_.GracePeriodHours}}, @{Name="Deployment deadline less than 1 hour, remind user every (seconds)"; Expression={$_.HourReminderInterval}}, @{Name="Install permissions"; Expression={$_.InstallRestriction}}, OnPremHAServiceUrl, OSDBrandingSubTitle, @{Name="PowerShell Execution Polity";Expression={switch ($_.PowerShellExecutionPolicy) {0 {"0 - All Signed"}; 1 {"1 - Bypass"}; 2 {"2 - Restricted"}}}}, @{Name="Deployment deadline greater than 24 hours, remind user every (seconds)"; Expression={$_.ReminderInterval}}, Reserved1, Reserved2, Reserved3, SiteSettingsKey, SUMBrandingSubTitle, SuspendBitLocker, SWDBrandingSubTitle, SystemRestartTurnaroundTime, UseNewSoftwareCenter, UseOnPremHAService
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/device-restart-notifications#client-settings
	$ComputerRestart = Get-WmiObject -ErrorAction SilentlyContinue -ComputerName localhost -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Query "SELECT * FROM CCM_RebootSettings" | Select-Object -Property @{Name="Specify the frequency of reminder notifications to the user (minutes)"; Expression={$_.CountdownSnoozeInterval}}, @{Name="Configuration Manager can force a device to restart"; Expression={$_.NoEnforcement}}, @{Name="Specify the amount of time after the deadline before a device gets restarted (seconds)"; Expression={$_.RebootCountdown}}, @{Name="Specify the amount of time that a user is presented a final countdown notification before a device gets restarted (seconds)"; Expression={$_.RebootCountdownFinalWindow}}, @{Name="When a deployment requires a restart, show a dialog window to the user instead of a toast notification"; Expression={$_.RebootNotificationsDialog}}, @{Name="When a deployment requires a restart, allow low-rights users to restart a device running Windows Server";Expression={$_.LowRightsServerReboot}}, SiteSettingsKey
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#delivery-optimization
	$DOpt = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\CCM\Policy\Machine\ActualConfig" -Class "CCM_WindowsDOClientConfig" | Select-Object -Property CollectDODownloadData, DODataCollectionInterval, Enabled, @{Name="Use Configuration Manager Boundary Groups for Delivery Optimization Group ID";Expression={$_.EnableWindowsDO}}, Reserved1, Reserved2, Reserved3, @{Name="Enable devices managed by Configuration Manager to use Delivery Optimization In-Network Cache servers for content download";Expression={$_.StampDOINC}}, SiteSettingsKey
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#endpoint-protection
	$EndProt = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_EndpointProtectionClientConfig" | Select-Object -Property Enabled, DisableFirstSignatureUpdate, @{Name="Manage Endpoint Protection client on client computers";Expression={$_.EnableEP}}, @{Name="Allowed period of time users can postpone a required restart to complete the Endpoint Protection installation (hours)";Expression={$_.ForceRebootPeriod}}, InstallRetryPeriod, @{Name="Install Endpoint Protection client on client computers";Expression={$_.InstallSCEPClient}}, @{Name="Allow Endpoint Protection client installation and restarts outside maintenance windows. Maintenance windows must be at least 30 minutes long for client installation";Expression={$_.OverrideMaintenanceWindow}}, @{Name="For Windows Embedded devices with write filters, commit Endpoint Protection client installation (requires restarts)";Expression={$_.PersistInstallation}}, PolicyEnforcePeriod, @{Name="Disable alternate sources (such as Microsoft Windows Update, Microsoft Windows Server Update Services, or UNC shares) for the initial security intelligence update on client computers";Expression={$_.Remove3rdParty}}, @{Name="Suppress any required computer restarts after the Endpoint Protection client is installed";Expression={$_.SuppressReboot}}, SiteSettingsKey
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#hardware-inventory
	$HardInv = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_HardwareInventoryClientConfig" | Select-Object -Property Enabled, Reserved1, Reserved2, Reserved3, SiteSettingsKey
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#metered-internet-connections
	$MeteredNetwork = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_NetworkSettings" | Select-Object -Property @{Name="Client communication on metered internet connections";Expression={Interprete-MeteredNetworkUsage($_.MeteredNetworkUsage)}}, Reserved, SiteSettingsKey
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#software-center
	$SoftC = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_SoftwareCenterClientConfig" | Select-Object -Property ComponentName, Enabled, SCBrandingColor, SCBrandingString, SCLogo, SCShowApplicationsTab, SCShowComplianceTab, SCShowInstallationTab, SCShowOptionsTab, SCShowOSDTab, SCShowUpdatesTab, @{Name="Select these new settings to specify company information";Expression={$_.SCUseOldBranding}}, @{Name="Select the user portal";Expression={$_.SCUserPortal}}, @{Name="Software Center settings";Expression={Format-XML($_.SettingsXml)}},SiteSettingsKey
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#software-updates
	$SoftwareUpdates = Get-WmiObject -ErrorAction SilentlyContinue -ComputerName localhost -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Query "SELECT * FROM CCM_SoftwareUpdatesClientConfig" | Select-Object -Property ComponentName, @{Name="Enable software updates on clients"; Expression={$_.Enabled}}, @{Name="Enable Dynamic Update for feature updates"; Expression={$_.DynamicUpdateOption}}, @{Name="Allow clients to download delta content when available"; Expression={$_.EnableExpressUpdates}}, @{Name="Enable third party software updates"; Expression={$_.EnableThirdPartyUpdates}}, @{Name="Port that clients use to receive requests for delta content"; Expression={$_.ExpressUpdatesPort}}, @{Name="Software update scan schedule";Expression={$_."Scan Schedule"}}, @{Name="Schedule deployment re-evaluation";Expression={$_.EvaluationSchedule}}, @{Name="Enforce TLS certificate pinning for Windows Update client for detecting updates";Expression={$_.EnableWSUSCertPinning}}, @{Name="Allow user proxy for software update scans";Expression={$_.WUAUserProxy}}, @{Name="If content is unavailable from distribution points in the current boundary group, immediately fallback to a neighbor or the site default";Expression={$_.DeltaDPFallback}}, @{Name="Enable management of the Office 365 Client Agent";Expression={"Refer to Reserved2"}}, @{Name="Enable update notifications from Microsoft 365 Apps";Expression={$_.EnableO365UpdateNotification}}, ExpressVersion, ContentDownloadTimeout, ContentLocationTimeout, DayReminderInterval, GroupPolicyNotificationTimeout, HourReminderInterval, MaxScanRetryCount, @{Name="Specify thread priority for feature updates";Expression={$_.NEOPriorityOption}}, PerDPInactivityTimeout, ReminderInterval, WUfBEnabled, Reserved1, @{Name="Reserved2";Expression={Format-XML($_.Reserved2)}}, Reserved3, ScanRetryDelay, @{Name="Enable installation of software updates in All deployments maintenance window when Software Update maintenance window is available";Expression={$_.ServiceWindowManagement}}, SiteSettingsKey, WSUSLocationTimeout, AssignmentBatchingTimeout, BrandingTitle, BrandingSubTitle, UserJobPerDPInactivityTimeout, UserJobTotalInactivityTimeout, TotalInactivityTimeout
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#user-and-device-affinity
	$UserDevAff = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\CCM\Policy\Machine\ActualConfig" -Class "CCM_TargetingSettings" | Select-Object -Property @{Name="Allow user to define their primary devices";Expression={$_.AllowUserAffinity}}, AllowUserAffinityAfterMinutes, @{Name="Automatically configure user device affinity from usage data";Expression={$_.AutoApproveAffinity}}, ComponentName, @{Name="User device affinity usage threshold (minutes)";Expression={$_.ConsoleMinutes}}, Enabled, @{Name="User device affinity usage threshold (days)";Expression={$_.IntervalDays}}, Reserved1, Reserved2, Reserved3, SiteSettingsKey
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<div id='mySidenav'><ul><li><a href='#BITS'>$TitleBITS</a></li><li><a href='#ClientCache'>$TitleClientCache</a></li><li><a href='#CloudServices'>$TitleCloudServices</a></li><li><a href='#ComputerAgent'>$TitleComputerAgent</a></li><li><a href='#ComputerRestart'>$TitleComputerRestart</a></li><li><a href='#DOpt'>$TitleDOpt</a></li><li><a href='#EndProt'>$TitleEndProt</a></li><li><a href='#HardInv'>$TitleHardInv</a></li><li><a href='#MeteredNetwork'>$TitleMeteredNetwork</a></li><li><a href='#SoftC'>$TitleSoftC</a></li><li><a href='#SoftwareUpdates'>$TitleSoftwareUpdates</a></li><li><a href='#UserDevAff'>$TitleUserDevAff</a></li></ul></div>"

		$BITS = $BITS | ConvertTo-Html -Fragment -PreContent "<h2 id='BITS'>Background Intelligent Transfer</h2>" -as List
		$ClientCache = $ClientCache | ConvertTo-Html -Fragment -PreContent "<h2 id='ClientCache'>Client Cache</h2>" -as List
		$CloudServices = $CloudServices | ConvertTo-Html -Fragment -PreContent "<h2 id='CloudServices'>Cloud Services</h2>" -as List
		$ComputerAgent = $ComputerAgent | ConvertTo-Html  -Fragment -PreContent "<h2 id='ComputerAgent'>Computer Agent</h2>" -as List
		$ComputerRestart = $ComputerRestart | ConvertTo-Html  -Fragment -PreContent "<h2 id='ComputerRestart'>Computer Restart</h2>" -as List
		$DOPt = $DOPt | ConvertTo-Html  -Fragment -PreContent "<h2 id='DOpt'>Delivery Optimization</h2>" -as List
		$EndProt = $EndProt | ConvertTo-Html  -Fragment -PreContent "<h2 id='EndProt'>Endpoint protection</h2>" -as List
		$HardInv = $HardInv | ConvertTo-Html  -Fragment -PreContent "<h2 id='HardInv'>Hardware Inventory</h2>" -as List
		$MeteredNetwork = $MeteredNetwork | ConvertTo-Html  -Fragment -PreContent "<h2 id='MeteredNetwork'>Metered Network</h2>" -as List
		$SoftC = $SoftC | ConvertTo-Html  -Fragment -PreContent "<h2 id='SoftC'>Software Center</h2>" -as List
		if($SoftC) {
			$SoftC = $SoftC -replace '<td>&lt;settings','<td><textarea>&lt;settings' 
			$SoftC = $SoftC -replace '/settings&gt;</td>','/settings&gt;</textarea></td>'
		}
		$SoftwareUpdates = $SoftwareUpdates | ConvertTo-Html  -Fragment -PreContent "<h2 id='SoftwareUpdates'>Software Updates</h2>" -as List
		$UserDevAff = $UserDevAff | ConvertTo-Html  -Fragment -PreContent "<h2 id='UserDevAff'>User and Device Affinity</h2>" -as List
		
		$ReportParams = @{
			Body = "$TopicName $ContentTable $BITS $ClientCache $CloudServices $ComputerAgent $ComputerRestart $DOpt $EndProt $HardInv $MeteredNetwork $SoftC $SoftwareUpdates $UserDevAff"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		
		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $ClientSettingsFile
	} else {
		"=== $TitleBITS ===" | Out-File $ClientSettingsFile
		if ($BITS) {
			$BITS | Out-File -Append $ClientSettingsFile
		}
		
		"=== $TitleClientCache ===" | Out-File -Append $ClientSettingsFile
		if ($ClientCache) {
			$ClientCache | Out-File -Append $ClientSettingsFile
		}
		
		"=== $TitleCloudServices ===" | Out-File -Append $ClientSettingsFile
		if ($CloudServices) {
			$CloudServices | Out-File -Append $ClientSettingsFile
			
		}
		"=== $TitleComputerAgent===" | Out-File -Append $ClientSettingsFile
		if ($ComputerAgent) {
			$ComputerAgent | Out-File -Append $ClientSettingsFile
		}
		
		"=== $TitleComputerRestart===" | Out-File -Append $ClientSettingsFile
		if ($ComputerRestart) {
			$ComputerRestart | Out-File -Append $ClientSettingsFile
		}
		
		"=== $TitleDOpt===" | Out-File -Append $ClientSettingsFile
		if ($DOpt) {
			$DOpt | Out-File -Append $ClientSettingsFile
		}
		
		"=== $TitleEndProt===" | Out-File -Append $ClientSettingsFile
		if ($EndProt) {
			$EndProt | Out-File -Append $ClientSettingsFile
		}
		
		"=== $TitleHardInv===" | Out-File -Append $ClientSettingsFile
		if ($HardInv) {
			$HardInv | Out-File -Append $ClientSettingsFile
		}
		
		"=== $TitleMeteredNetwork===" | Out-File -Append $ClientSettingsFile
		if ($MeteredNetwork) {
			$MeteredNetwork | Out-File -Append $ClientSettingsFile
		}
		
		"=== $TitleSoftC===" | Out-File -Append $ClientSettingsFile
		if ($SoftC) {
			$SoftC | Out-File -Append $ClientSettingsFile
		}
			
		"=== $TitleSoftwareUpdates===" | Out-File -Append $ClientSettingsFile
		if ($SoftwareUpdates) {
			$SoftwareUpdates | Out-File -Append $ClientSettingsFile
		}
		
		"=== $TitleUserDevAff===" | Out-File -Append $ClientSettingsFile
		if ($UserDevAff) {
			$UserDevAff | Out-File -Append $ClientSettingsFile
		}
		
		Generate-Footer | Out-File -Append $ClientSettingsFile
	}
	Write-Verbose -Message $OutMsgClientSettings
}

################################################
# Profile Configuration Manager Software Center
################################################
Function Profile-SoftwareCenter {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $SCFileName = "1-SoftwareCenter.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $SCFileName = "1-SoftwareCenter.txt"}
	$SCFile = "${toLocation}\${ChildDir}" + "\" +  $SCFileName
	
	$Title = "Software Center"
	$TitleApp = "Applications"
	$TitleUpdates= "Updates"
	$TitlePkgTskSeq = "Packages and Task Sequences"
	$OutMsgSC = "  *** Profiled - Software Center *** "
	
	# Applications
	$AppInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\ClientSDK:CCM_Application" -Query "SELECT * FROM CCM_Application" | Select-Object Name, FullName, UserUIExperience, Revision, Id, @{Name="Deadline";Expression={($_.Deadline.SubString(0,4), $_.Deadline.SubString(4,2),$_.Deadline.SubString(6,2), $_.Deadline.SubString(8,2), $_.Deadline.SubString(10,2), $_.Deadline.SubString(12,2)) -join "-"}}, @{Name="LastInstallTime";Expression={($_.LastInstallTime.SubString(0,4), $_.LastInstallTime.SubString(4,2),$_.LastInstallTime.SubString(6,2), $_.LastInstallTime.SubString(8,2), $_.LastInstallTime.SubString(10,2), $_.LastInstallTime.SubString(12,2)) -join "-"}}, @{Name="StartTime";Expression={($_.StartTime.SubString(0,4), $_.StartTime.SubString(4,2),$_.StartTime.SubString(6,2), $_.StartTime.SubString(8,2), $_.StartTime.SubString(10,2), $_.StartTime.SubString(12,2)) -join "-"}}, @{Name="EvaluationState";Expression={Interprete-AppEvaluationState($_.EvaluationState)}}, InstallState, ResolvedState, ConfigureState, OverrideServiceWindow, RebootOutsideServiceWindow, @{Name="DeploymentReport";Expression={$AppDepD = Get-AppDeploymentDetail -AppID $_.Id -AppRevision $_.Revision; Format-XML($AppDepD)}}, NotifyUser, EnforcePreference, ErrorCode, EstimatedInstallTime, FileTypes, InformativeUrl, InfoUrlText, InProgressActions, IsMachineTarget, IsPreflightOnly, LastEvalTime, NextUserScheduledTime, PercentComplete, SupersessionState, Type, ApplicabilityState, ApplicationType, Categories, ContentSize, Description, SoftwareVersion, PrivacyUri, Publisher, ReleaseDate, HighImpactDeployment
	$AppCount = ($AppInfo | Measure-Object | Select-Object).Count
	# Updates
	$Updates = Get-WMIObject -ErrorAction SilentlyContinue -namespace "root\ccm\ClientSDK:CCM_SoftwareUpdate" -query "SELECT * From CCM_SoftwareUpdate" | Select-Object -Property ArticleID, Name, Description, UpdateID, UserUIExperience, @{Name="Deadline";Expression={($_.Deadline.SubString(0,4), $_.Deadline.SubString(4,2),$_.Deadline.SubString(6,2), $_.Deadline.SubString(8,2), $_.Deadline.SubString(10,2), $_.Deadline.SubString(12,2)) -join "-"}}, @{Name="StartTime";Expression={($_.StartTime.SubString(0,4), $_.StartTime.SubString(4,2),$_.StartTime.SubString(6,2), $_.StartTime.SubString(8,2), $_.StartTime.SubString(10,2), $_.StartTime.SubString(12,2)) -join "-"}}, EstimatedInstallTime, @{Name="EvaluationState";Expression={Interprete-UpdEvaluationState($_.EvaluationState)}}, ErrorCode, ComplianceState, ContentSize, PercentComplete, Type, NextUserScheduledTime, OverrideServiceWindows, RebootOutsideServiceWindows, RestartDeadline, NotifyUser, ExclusiveUpdate, MaxExecutionTime, IsUpgrade, FullName, IsO365Update, URL, Publisher, BulletinID
	$UpdatesCount = ($Updates | Measure-Object | Select-Object).Count
	# Packages and Task Sequences
	$PkgTskSeq = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\ClientSDK:CCM_Program" -Query "SELECT * FROM CCM_Program" | Select-Object PackageID, PackageName, ProgramID, TaskSequence, RepeatRunBehavior, RestartRequired, FullName, Name, LastRunStatus, LastExitCode, LastRunTime, ErrorCode, Duration, NotifyUser, RequiresUserInput, ActivationTime, AdvertisedDirectly, Categories, CompletionAction, ContentSize, CustomHighImpactHeadline, CustomHighImpactSet, CustomHighImpactWarning, CustomHighImpactWarningInstall, CustomHighImpactWarningTop, Deadline, Dependencies, DependentPackageID, DependentProgramID, Description, DiskSpaceRequired, EstimatedDownloadSizeMB, EstimatedInstallTime, EstimatedRunTimeMinutes, EvaluationState, ExpirationTime, ForceDependencyToRun, HighImpact, HighImpactTaskSequence, Level, LocalizedTaskSequenceDescription, NextUserScheduledTime, PackageLanguage, PercentComplete, Published, Publisher, RunAtLogoff, RunAtLogon, RunDependent, Type, Version
	$PkgTskSeqCount = ($PkgTskSeq | Measure-Object | Select-Object).Count
	
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<div id='mySidenav'><ul><li><a href='#AppInfo'>$TitleApp</a></li><li><a href='#Updates'>$TitleUpdates</a></li><li><a href='#PkgTskSeq'>$TitlePkgTskSeq</a></li></ul></div>"
		
		$AppInfo = $AppInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='AppInfo'>Applications ($AppCount)</h2>"
		if($AppInfo) {
			$AppInfo = $AppInfo -replace '<td>Installed</td>','<td class="GreenStatus">Installed</td>'
			$AppInfo = $AppInfo -replace '<td>NotInstalled</td>','<td class="RedStatus">NotInstalled</td>'
			$AppInfo = $AppInfo -replace '<td>Available</td>','<td class="OrangeStatus">Available</td>'
			$AppInfo = $AppInfo -replace '<td>&lt;ConfigurationItemReport','<td><textarea>&lt;ConfigurationItemReport'
			$AppInfo = $AppInfo -replace '/ConfigurationItemReport&gt;</td>','/ConfigurationItemReport&gt;</textarea></td>'
		}
		
		$Updates = $Updates | ConvertTo-Html -Fragment -PreContent "<h2 id='Updates'>Updates ($UpdatesCount)</h2>"
		if($Updates) {
			$Updates = $Updates -replace '<td>13 - Error</td>','<td class="RedStatus">13 - Error</td>'
		}
		
		$PkgTskSeq = $PkgTskSeq | ConvertTo-Html -Fragment -PreContent "<h2 id='PkgTskSeq'>Packages and Task Sequences ($PkgTskSeqCount)</h2>"
		if($PkgTskSeq) {
			$PkgTskSeq = $PkgTskSeq -replace '<td>Succeeded</td>','<td class="GreenStatus">Succeeded</td>'
			$PkgTskSeq = $PkgTskSeq -replace '<td>Failed</td>','<td class="RedStatus">Failed</td>'
		}
		
		$ReportParams = @{
			Body = "$TopicName $ContentTable $AppInfo $Updates $PkgTskSeq"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		
		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $SCFile
	} else {
		"=== $TitleApp ===" | Out-File $SCFile
		if ($AppInfo) {$AppInfo | Out-File -Append $SCFile}
		
		"=== $TitleUpdates ===" | Out-File -Append $SCFile
		if ($Updates) {$Updates | Out-File -Append $SCFile}
		
		"=== $TitlePkgTskSeq ===" | Out-File -Append $SCFile
		if ($PkgTskSeq) {$PkgTskSeq | Out-File -Append $SCFile}
		
		Generate-Footer | Out-File -Append $SCFile
	}
	Write-Verbose -Message $OutMsgSC
}

#########################################
# Fetch Content Cache information
#########################################
Function Get-ContentCacheInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $ContentCacheInfoFileName = "ContentCache.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $ContentCacheInfoFileName = "ContentCache.txt"}
	$ContentCacheInfoFile = "${toLocation}\${ChildDir}" + "\" +  $ContentCacheInfoFileName
	
	$CacheSizeInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\SoftMgmtAgent:CacheConfig" -Query "SELECT * FROM CacheConfig" | Select-Object ConfigKey, InUse, Location, NextAvailableId, @{Name="Size(M)";Expression={$_.Size}}
	$ContentCacheInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\SoftMgmtAgent:CacheInfoEx" -Query "SELECT * FROM CacheInfoEx" | Select-Object ContentId, CacheId, @{Name="ContentSize(KB)";Expression={$_.ContentSize}}, ContentComplete, ContentType, ContentVer, Location,  ContentFlags, LastReferenced, ContentManifest, DeploymentFlags, ExcludeFileList, PartialContentInfo, PeerCaching, PersistInCache, ReferenceCount   
	
	$Title = "ConfigMgr Client Cache"
	$TitleCacheSize = "Cache Size"
	$TitleContentCache = "Content Cache"
	$OutMsgCacheSize = "  *** Read - ROOT\ccm\SoftMgmtAgent:CacheConfig *** "
	$OutMsgContentCache = "  *** Read - ROOT\ccm\SoftMgmtAgent:CacheInfoEx *** "
	$Count = ($ContentCacheInfo | Measure-Object | Select-Object).Count
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<div id='mySidenav'><ul><li><a href='#CacheSizeInfo'>$TitleCacheSize</a></li><li><a href='#ContentCacheInfo'>$TitleContentCache</a></li></ul></div>"
		
		if ($CacheSizeInfo) {
			$CacheSizeInfo = $CacheSizeInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='CacheSizeInfo'>$TitleCacheSize</h2>"
		}
		
		if ($ContentCacheInfo) {
			$ContentCacheInfo = $ContentCacheInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='ContentCacheInfo'>$Count content cache</h2>"
		}
		
		$ReportParams = @{
			Body = "$TopicName $ContentTable $CacheSizeInfo $ContentCacheInfo"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}

		$Report = ConvertTo-HTML @ReportParams
		$Report = $Report -replace '<td>True</td>','<td class="GreenStatus">True</td>'
		$Report = $Report -replace '<td>False</td>','<td class="RedStatus">False</td>'
		#The command below will generate the report to an HTML file
		$Report | Out-File $ContentCacheInfoFile		
	} else {
		"=== $TitleCacheSize ===" | Out-File $ContentCacheInfoFile
		if ($CacheSizeInfo) {
			$CacheSizeInfo | Out-File -Append $ContentCacheInfoFile
		}
		
		"=== $TitleContentCache - $Count ===" | Out-File -Append $ContentCacheInfoFile
		if ($ContentCacheInfo) {
			$ContentCacheInfo | Out-File -Append $ContentCacheInfoFile
		}
		Generate-Footer | Out-File -Append $ContentCacheInfoFile
	}
	Write-Verbose -Message $OutMsgCacheSize
	Write-Verbose -Message $OutMsgContentCache
}

###################################################################################################################
# Fetch updates assignments CI information
###################################################################################################################
Function Get-UpdateCIAssignment {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $UpdateCIAssignmentFileName = "UpdateCIAssignment.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $UpdateCIAssignmentFileName = "UpdateCIAssignment.txt"}
	$UpdateCIAssignmentFile = "${toLocation}\${ChildDir}" + "\" +  $UpdateCIAssignmentFileName
	
	$UpdateCIAssignment = Get-WmiObject -ErrorAction SilentlyContinue -ComputerName localhost -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Query "SELECT * FROM CCM_UpdateCIAssignment" | Select-Object -Property AssignmentID, @{Name="AssignedCIs";Expression={$_.AssignedCIs -join ';'}}, AssignmentName, NotifyUser, StartTime, OverrideServiceWindows, EnforcementDeadline, ExpirationTime, RebootOutsideOfServiceWindows, AssignmentAction, PersistOnWriteFilterDevices, AssignmentFlags, ConfigurationFlags, DesiredConfigType, DisableMomAlerts, DPLocality, LogComplianceToWinEvent, NonComplianceCriticality, Precedence, RaiseMomAlertsOnFailure, SuppressReboot, UpdateDeadline, SendDetailedNonComplianceStatus, SettingTypes, SoftDeadlineEnabled, UseGMTTimes, StateMessagePriority, UseSiteEvaluation, WoLEnabled, Reserved1, Reserved2, Reserved3, Reserved4 
	
	$Title = "Update Assignment CIs"
	$OutMsg = "  *** Read - ROOT\ccm\Policy\Machine\ActualConfig - CCM_UpdateCIAssignment *** "
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<h3><a href='#UpdateCIAssignment'>$Title</a></h3>"
		
		if ($UpdateCIAssignment) {
			$UpdateCIAssignment = $UpdateCIAssignment | ConvertTo-Html -Fragment
			$UpdateCIAssignment = $UpdateCIAssignment -replace '<td>&lt;\?xml','<td><textarea>&lt;?xml' 
			$UpdateCIAssignment = $UpdateCIAssignment -replace '/CI&gt;</td>','/CI&gt;</textarea></td>'
			$UpdateCIAssignment = $UpdateCIAssignment -replace '/SUMReserved&gt;</td>','/SUMReserved&gt;</textarea></td>'
		}		
		$ReportParams = @{
			Body = "$TopicName $UpdateCIAssignment" 
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}

		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $UpdateCIAssignmentFile
	} else {
		"=== $Title ===" | Out-File $UpdateCIAssignmentFile
		if ($UpdateCIAssignment) {
			$UpdateCIAssignment | Out-File -Append $UpdateCIAssignmentFile
		}
		Generate-Footer | Out-File -Append $UpdateCIAssignmentFile
	}
	Write-Verbose -Message $OutMsg
}

###################################################################################################################
# Fetch CCM_CIAssignment, including deployments of updates, applications, baselines, DCM, etc.
# CCM_TaskSequence - task sequence deployments
# CCM_SoftwareDistribution - Package deployments
###################################################################################################################
Function Get-Deployments {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $DeploymentsFileName = "Deployments.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $DeploymentsFileName = "Deployments.txt"}
	$DeploymentsFile = "${toLocation}\${ChildDir}" + "\" +  $DeploymentsFileName
	
	# 1. All deployments of updates, applications, baselines, etc.
	$CIAssignment = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class CCM_CIAssignment
	
	## 1.1 Updates deployments
	$CIAssigUpd = $CIAssignment | Where-Object {$_.__Class -eq "CCM_UpdateCIAssignment"} | Select-Object -Property AssignmentID, @{Name="AssignedCIs";Expression={$_.AssignedCIs -join ';'}}, AssignmentName, UserUIExperience, NotifyUser, StartTime, OverrideServiceWindows, EnforcementDeadline, ExpirationTime, RebootOutsideOfServiceWindows, AssignmentAction, PersistOnWriteFilterDevices, AssignmentFlags, ConfigurationFlags, DesiredConfigType, DisableMomAlerts, DPLocality, LogComplianceToWinEvent, NonComplianceCriticality, Precedence, RaiseMomAlertsOnFailure, SuppressReboot, UpdateDeadline, SendDetailedNonComplianceStatus, SettingTypes, SoftDeadlineEnabled, UseGMTTimes, StateMessagePriority, UseSiteEvaluation, WoLEnabled, Reserved1, Reserved2, Reserved3, Reserved4              
	
	## 1.2 Application deployments
	$CIAssigApp = $CIAssignment | Where-Object {$_.__Class -eq "CCM_ApplicationCIAssignment"} | Select-Object -Property AssignmentID, @{Name="AssignedCIs";Expression={$_.AssignedCIs -join ';'}}, AssignmentName, UserUIExperience, StartTime, EnforcementDeadline, UpdateDeadline, NotifyUser, OverrideServiceWindows, RebootOutsideOfServiceWindows, AssignmentAction, AssignmentFlags, ConfigurationFlags, DesiredConfigType, DisableMomAlerts, DPLocality, ExpirationTime, LogComplianceToWinEvent, NonComplianceCriticality, PersistOnWriteFilterDevices, Priority, RaiseMomAlertsOnFailure, SendDetailedNonComplianceStatus, SettingTypes, SoftDeadlineEnabled, StateMessagePriority, SuppressReboot, UseGMTTimes, UseSiteEvaluation, WoLEnabled, Reserved1, Reserved2, Reserved3, Reserved4

	## 1.3 Baselines deployments
	$CIAssigBas = $CIAssignment | Where-Object {$_.__Class -eq "CCM_DCMCIAssignment"} | Select-Object -Property AssignmentID, @{Name="AssignedCIs";Expression={$_.AssignedCIs -join ';'}}, AssignmentAction, AssignmentFlags, AssignmentName, DPLocality, EnforcementDeadline, ExpirationTime, StartTime, NotifyUser, OverrideServiceWindows, PersistOnWriteFilterDevices, RaiseMomAlertsOnFailure, RebootOutsideOfServiceWindows, ConfigurationFlags, DesiredConfigType, DisableMomAlerts, SendDetailedNonComplianceStatus, SettingTypes, SoftDeadlineEnabled, StateMessagePriority, SuppressReboot, UpdateDeadline, UseGMTTimes, UseSiteEvaluation, LogComplianceToWinEvent, NonComplianceCriticality, WoLEnabled, Reserved1, Reserved2, Reserved3, Reserved4     
	
	## 1.4 Others, like CoMgmt settings deployments: CoMgmtSettingsPilotAutoEnroll, CoMgmtSettingsProd
	$CIAssigOthers = $CIAssignment | Where-Object {$_.__Class -notin ("CCM_UpdateCIAssignment", "CCM_ApplicationCIAssignment", "CCM_DCMCIAssignment")} | Select-Object -Property AssignmentID, @{Name="AssignedCIs";Expression={$_.AssignedCIs -join ';'}}, AssignmentName, UserUIExperience, NotifyUser, StartTime, OverrideServiceWindows, EnforcementDeadline, ExpirationTime, RebootOutsideOfServiceWindows, AssignmentAction, PersistOnWriteFilterDevices, AssignmentFlags, ConfigurationFlags, DesiredConfigType, DisableMomAlerts, DPLocality, LogComplianceToWinEvent, NonComplianceCriticality, Precedence, RaiseMomAlertsOnFailure, SuppressReboot, UpdateDeadline, SendDetailedNonComplianceStatus, SettingTypes, SoftDeadlineEnabled, UseGMTTimes, StateMessagePriority, UseSiteEvaluation, WoLEnabled, Reserved1, Reserved2, Reserved3, Reserved4              
	
	# 2. All deployments of Packages and Task sequences
	$CCMPkgTsk = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class CCM_SoftwareDistribution
	
	## 2.1 Package deployments
	$CCMPkg = $CCMPkgTsk | Where-Object {$_.__Class -eq "CCM_SoftwareDistribution"} | Select-Object -Property PKG_Name, PKG_PackageID, ADV_AdvertisementID, PRG_ProgramID,PRG_ProgramName, PRG_Requirements, ADV_ExpirationTime, ADV_ExpirationTimeIsGMT, ADV_FirstRunBehavior, ADV_MandatoryAssignments, ADV_ProgramWindowIsGMT, ADV_ProgramWindowStartTime, ADV_ProgramWindowStopTime, ADV_RCF_InstallFromCDOptions, ADV_RCF_InstallFromLocalDPOptions, ADV_RCF_InstallFromRemoteDPOptions, ADV_RCF_PostponeToAC, ADV_RCF_UseMeteredNetwork, ADV_RebootLogoffNotification, ADV_RebootLogoffNotificationCountdownDuration, ADV_RebootLogoffNotificationFinalWindow, ADV_RepeatRunBehavior, ADV_RetryCount, ADV_RetryInterval, ADV_RunNotificationCountdownDuration, PKG_ContentSize, PKG_Language, PKG_Manufacturer, PKG_MIFChecking, PKG_MifFileName, PKG_MIFName, PKG_MIFPublisher, PKG_MIFVersion, PKG_PSF_ContainsSourceFiles, PKG_SourceHash, PKG_SourceVersion, PKG_version, PRG_Category, PRG_CommandLine, PRG_Comment, PRG_CustomLogoffReturnCodes, PRG_CustomRebootReturnCodes, PRG_CustomSuccessReturnCodes, PRG_DependentPolicy, PRG_DependentProgramPackageID, PRG_DependentProgramProgramID, PRG_DiskSpaceReq, PRG_DriveLetter, PRG_ForceDependencyRun, PRG_HistoryLocation, PRG_MaxDuration, PRG_PRF_AfterRunning, PRG_PRF_Disabled, PRG_PRF_InstallsApplication, PRG_PRF_MappedDriveRequired, PRG_PRF_PersistMappedDrive, PRG_PRF_RunNotification, PRG_PRF_RunWithAdminRights, PRG_PRF_ShowWindow, PRG_PRF_UserInputRequired, PRG_PRF_UserLogonRequirement, ADV_ActiveTime, ADV_ActiveTimeIsGMT, ADV_ADF_Published, ADV_ADF_RunNotification, PRG_ReturnCodesSource, PRG_WorkingDirectory
	
	## 2.2 Task sequence deployments
	$CCMTskSeq = $CCMPkgTsk | Where-Object {$_.__Class -eq "CCM_TaskSequence"} | Select-Object -Property PKG_Name, PKG_PackageID, ADV_AdvertisementID, PRG_Requirements, ADV_ActiveTime, ADV_ActiveTimeIsGMT, ADV_ADF_Published, ADV_ADF_RunNotification, ADV_ExpirationTime, ADV_ExpirationTimeIsGMT, ADV_FirstRunBehavior, ADV_MandatoryAssignments, ADV_ProgramWindowIsGMT, ADV_ProgramWindowStartTime, ADV_ProgramWindowStopTime, ADV_RCF_InstallFromCDOptions, ADV_RCF_InstallFromLocalDPOptions, ADV_RCF_InstallFromRemoteDPOptions, ADV_RCF_PostponeToAC, ADV_RCF_UseMeteredNetwork, ADV_RebootLogoffNotification, ADV_RebootLogoffNotificationCountdownDuration, ADV_RebootLogoffNotificationFinalWindow, ADV_RepeatRunBehavior, ADV_RetryCount, ADV_RetryInterval, ADV_RunNotificationCountdownDuration, PKG_ContentSize, PKG_Language, PKG_Manufacturer, PKG_MIFChecking, PKG_MifFileName, PKG_MIFName, PKG_MIFPublisher, PKG_MIFVersion, PKG_PSF_ContainsSourceFiles, PKG_SourceHash, PKG_SourceVersion, PKG_version, PRG_Category, PRG_CommandLine, PRG_Comment, PRG_CustomLogoffReturnCodes, PRG_CustomRebootReturnCodes, PRG_CustomSuccessReturnCodes, PRG_DependentPolicy, PRG_DependentProgramPackageID, PRG_DependentProgramProgramID, PRG_DiskSpaceReq, PRG_DriveLetter, PRG_ForceDependencyRun, PRG_HistoryLocation, PRG_MaxDuration, PRG_PRF_AfterRunning, PRG_PRF_Disabled, PRG_PRF_InstallsApplication, PRG_PRF_MappedDriveRequired, PRG_PRF_PersistMappedDrive, PRG_PRF_RunNotification, PRG_PRF_RunWithAdminRights, PRG_PRF_ShowWindow, PRG_PRF_UserInputRequired, PRG_PRF_UserLogonRequirement, PRG_ProgramID, PRG_ProgramName, PRG_ReturnCodesSource, PRG_WorkingDirectory, Reserved, TS_BootImageID, TS_CustomHighImpactHeadline, TS_CustomHighImpactSet, TS_CustomHighImpactWarning, TS_CustomHighImpactWarningInstall, TS_CustomHighImpactWarningTop, TS_Deadline, TS_EstimatedDownloadSizeMB, TS_EstimatedRunTimeMinutes, TS_HighImpactTaskSequence, TS_LocalizedTaskSequenceDescription, TS_LocalizedTaskSequenceName, TS_MandatoryCountdown, TS_PopupReminderInterval, TS_References, TS_RestartRequired, TS_Sequence, TS_Type, TS_UserNotificationFlags                      
	
	$Title = "Deployments"
	$TitleCIAssignUpd = "Updates"
	$TitleCIAssignApp = "Applications"
	$TitleCIAssignBas = "Baselines"
	$TitleCIAssignOthers = "Others"
	$TitlePkg = "Packages"
	$TitleTskSeq = "Task Sequences"
	
	
	$OutMsgCIAssign = "  *** Read - ROOT\ccm\Policy\Machine\ActualConfig - CCM_CIAssignment *** "
	$OutMsgTskSeq = "  *** Read - ROOT\ccm\Policy\Machine\ActualConfig - CCM_SoftwareDistribution *** "
	
	
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<div id='mySidenav'><ul><li><a href='#CIAssigUpd'>$TitleCIAssignUpd</a></li><li><a href='#CIAssigApp'>$TitleCIAssignApp</a></li><li><a href='#CIAssigBas'>$TitleCIAssignBas</a></li><li><a href='#CCMPkg'>$TitlePkg</a></li><li><a href='#CCMTskSeq'>$TitleTskSeq</a></li><li><a href='#CIAssigOthers'>$TitleCIAssignOthers</a></li></ul></div>"
		
		if ($CIAssigUpd) {
			$CIAssigUpd = $CIAssigUpd | ConvertTo-Html -Fragment -PreContent "<h2 id='CIAssigUpd'>$TitleCIAssignUpd</h2>"
			$CIAssigUpd = $CIAssigUpd -replace '<td>&lt;\?xml','<td><textarea>&lt;?xml' 
			$CIAssigUpd = $CIAssigUpd -replace '/CI&gt;</td>','/CI&gt;</textarea></td>'
			$CIAssigUpd = $CIAssigUpd -replace '/SUMReserved&gt;</td>','/SUMReserved&gt;</textarea></td>'
		}

		if ($CIAssigApp) {
			$CIAssigApp = $CIAssigApp | ConvertTo-Html -Fragment -PreContent "<h2 id='CIAssigApp'>$TitleCIAssignApp</h2>"
			$CIAssigApp = $CIAssigApp -replace '<td>&lt;\?xml','<td><textarea>&lt;?xml' 
			$CIAssigApp = $CIAssigApp -replace '/CI&gt;</td>','/CI&gt;</textarea></td>'
			$CIAssigApp = $CIAssigApp -replace '/SUMReserved&gt;</td>','/SUMReserved&gt;</textarea></td>'
		}
		
		if ($CIAssigBas) {
			$CIAssigBas = $CIAssigBas | ConvertTo-Html -Fragment -PreContent "<h2 id='CIAssigBas'>$TitleCIAssignBas</h2>"
			$CIAssigBas = $CIAssigBas -replace '<td>&lt;\?xml','<td><textarea>&lt;?xml' 
			$CIAssigBas = $CIAssigBas -replace '/CI&gt;</td>','/CI&gt;</textarea></td>'
			$CIAssigBas = $CIAssigBas -replace '/SUMReserved&gt;</td>','/SUMReserved&gt;</textarea></td>'
		}
		
		if ($CIAssigOthers) {
			$CIAssigOthers = $CIAssigOthers | ConvertTo-Html -Fragment -PreContent "<h2 id='CIAssigOthers'>$TitleCIAssignOthers</h2>"
			$CIAssigOthers = $CIAssigOthers -replace '<td>&lt;\?xml','<td><textarea>&lt;?xml' 
			$CIAssigOthers = $CIAssigOthers -replace '/CI&gt;</td>','/CI&gt;</textarea></td>'
			$CIAssigOthers = $CIAssigOthers -replace '/SUMReserved&gt;</td>','/SUMReserved&gt;</textarea></td>'
		}

		if ($CCMPkg) {
			$CCMPkg = $CCMPkg | ConvertTo-Html -Fragment -PreContent "<h2 id='CCMPkg'>$TitlePkg</h2>"
			$CCMPkg = $CCMPkg -replace '<td>&lt;\?xml','<td><textarea>&lt;?xml' 
			$CCMPkg = $CCMPkg -replace '/SWDReserved&gt;</td>','/SWDReserved&gt;</textarea></td>'
		}
		
		if ($CCMTskSeq) {
			$CCMTskSeq = $CCMTskSeq | ConvertTo-Html -Fragment -PreContent "<h2 id='CCMTskSeq'>$TitleTskSeq</h2>"
			$CCMTskSeq = $CCMTskSeq -replace '<td>&lt;\?xml','<td><textarea>&lt;?xml' 
			$CCMTskSeq = $CCMTskSeq -replace '/SWDReserved&gt;</td>','/SWDReserved&gt;</textarea></td>'
		}
		
		$ReportParams = @{
			Body = "$TopicName $ContentTable $CIAssigUpd $CIAssigApp $CIAssigBas $CCMPkg $CCMTskSeq $CIAssigOthers" 
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}

		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $DeploymentsFile
	} else {
		"=== $TitleCIAssignUpd ===" | Out-File $DeploymentsFile
		if ($CIAssigUpd) {
			$CIAssigUpd | Out-File -Append $DeploymentsFile
		}
		
		"=== $TitleCIAssignApp ===" | Out-File $DeploymentsFile
		if ($CIAssigApp) {
			$CIAssigApp | Out-File -Append $DeploymentsFile
		}
		
		"=== $TitleCIAssignBas ===" | Out-File $DeploymentsFile
		if ($CIAssigBas) {
			$CIAssigBas | Out-File -Append $DeploymentsFile
		}
		
		"=== $TitlePkg ===" | Out-File -Append $DeploymentsFile
		if ($TitlePkg) {
			$TitlePkg | Out-File -Append $DeploymentsFile
		}
		
		"=== $TitleTskSeq ===" | Out-File -Append $DeploymentsFile
		if ($CCMTskSeq) {
			$CCMTskSeq | Out-File -Append $DeploymentsFile
		}
		
		"=== $TitleCIAssignOthers ===" | Out-File $DeploymentsFile
		if ($CIAssigOthers) {
			$CIAssigOthers | Out-File -Append $DeploymentsFile
		}
		Generate-Footer | Out-File -Append $DeploymentsFile
	}
	Write-Verbose -Message $OutMsgCIAssign
	Write-Verbose -Message $OutMsgTskSeq
}

#########################################
# Profile Configuration Manager client UI
#########################################
Function Profile-SCCMClient {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][Switch] $Text,
		[Parameter(Mandatory = $false)][String] $ConfigMgrClientFileName = "0-ConfigMgr-Client.html"
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $ConfigMgrClientFileName = "0-ConfigMgr-Client.txt" }
	$ConfigMgrClientFile = ("${toLocation}\${ChildDir}" + "\" + $ConfigMgrClientFileName)
	
	# Define titles
	$Title = "Configuration Manager Client"
	$TitleGeneral = "General"
	$TitleComponents = "Components"
	$TitleSite = "Site"
	$TitleActions = "Actions"
	$TitleNetwork = "Network"
	$TitleCache = "Cache"
	$TitleConfig = "Configurations"
	
	# Get Configuration Manager client information in all tabs
	$SMSClient = New-Object -ComObject "Microsoft.SMS.Client"
	$CCMRegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\CCM'
	$CCMSecurityRegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\CCM\Security'
	$CCMClient = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm" -Class "CCM_Client"
	$SMS_Client = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm" -Class "SMS_Client"
	$ConfigMgrNetwork = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm" -Class "CCM_NetworkProxy" | Select-Object -First 1 -Property Account, Protocol, ProxyBypassList, ProxyList, ReservedString1
		
	# ====== 1. General tab ======
	# 1.1 Assigned management point: to add
	$IsSiteAutoAssignEnabled = $SMS_Client.EnableAutoAssignment
	$CurrentMP = $SMSClient.GetCurrentManagementPoint() # Current management point
	# 1.2. Client certificate:
	$IsClientCertReady = $CCMRegInfo.PKICertReady
	$ClientCert = $NULL
	if ($IsClientCertReady) {$ClientCert = "PKI"} else {$ClientCert = "Self-signed"}
	# 1.3. CoManagement capabilities: and 1.4. CoManagement:
	$CoMgmt = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\InvAgt" -Class "CCM_System"
	$IsCoMgmt = $CoMgmt.CoManaged
	$ComgmtWorkloads = $CoMgmt.ComgmtWorkloads
	$ClientDomain = $CoMgmt.Domain
	$LocalDateTime = $CoMgmt.LocalDateTime
	$SystemRole = $CoMgmt.SystemRole
	$SystemType = $CoMgmt.SystemType
	# 1.5. Connection Type:
	$IsOnInet = $SMSClient.IsClientOnInternet() # Whether the client is on internet
	$ClientAlwaysOnInet = $CCMSecurityRegInfo.ClientAlwaysOnInternet # Whether the client is ALWAYS on internet
	$ConnectionType = $Null
	if ($IsOnInet -and $ClientAlwaysOnInet) {
		$ConnectionType = "Always Internet"
	} elseif ($IsOnInet) {
		$ConnectionType = "Currently Internet"
	} else {
		$ConnectionType = "Currently Intranet"
	}
	# 1.6. Site Code:
	$SiteCode = $SMSClient.GetAssignedSite() # Site Code
	# 1.7. Unique Identifier:
	$ClientGUID = $CCMClient.ClientId # Client GUID
	$ClientGUIDChgDate = $CCMClient.ClientIdChangeDate # GMT time
	$ClientGUIDPre = $CCMClient.PreviousClientId # Previous Client GUID
	# 1.8. Version:
	#$ClientVersion = $SMS_Client.ClientVersion
	$ClientVersion = Get-ClientVersion -Ver $SMS_Client.ClientVersion
	$ClientType = $SMS_Client.ClientType
	
	$PropsGeneral = @{
		"Current management point" = "${CurrentMP}"
		"Client certificate" = "${ClientCert}"
		"Co-management capabilities" = "${ComgmtWorkloads}"
		"Co-management" = "${IsCoMgmt}"
		"Domain" = "${ClientDomain}"
		"Local Date Time" = "${LocalDateTime}"
		"System role" = "${SystemRole}"
		"Connection Type" = "${ConnectionType}"
		"Site code" = "${SiteCode}"
		"Unique identifier" = "${ClientGUID}"
		"Uniduq identifier change date (GMT)" = "${ClientGUIDChgDate}"
		"Previous unique identifier" = "${ClientGUIDPre}"
		"Version" = "${ClientVersion}"
		"Client Type" = "${ClientType}"
	}
	
	$ConfigMgrGeneral = (New-Object PSObject -Property $PropsGeneral)
	$ConfigMgrGeneral = $ConfigMgrGeneral | Select-Object -Property "Current management point", "Client certificate", "Co-management capabilities", "Co-management", "Domain", "Local Date Time", "System role", "Connection Type", "Site code", "Unique identifier", "Uniduq identifier change date (GMT)", "Previous unique identifier", "Version", "Client Type"

	# ====== 2. Components tab ======
	$ConfigMgrComponents = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm" -Class "CCM_InstalledComponent" | Select-Object -Property DisplayName, Name, Version
	$ComponentsCount = ($ConfigMgrComponents | Measure-Object | Select-Object).Count
	
	# ====== 3. Site tab ======
	# $SiteCode = $SMSClient.GetAssignedSite() # Site Code
	$DNSSuffix = $SMSClient.GetDnsSuffix()
	$PropsSite = @{
		"Currently assigned to site code" = "${SiteCode}"
		"DNS suffix" = "${DNSSuffix}"
	}
	
	$ConfigMgrSite = (New-Object PSObject -Property $PropsSite)

	# ====== 4. Actions tab ======
	$ConfigMgrActions = Get-WmiObject -ErrorAction SilentlyContinue -ComputerName localhost -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Query "SELECT * FROM CCM_ClientActions" | Select-Object -Property Name, ActionID, DisplayNameResFilename, DisplayNameResID, Endpoint, @{name="Message";Expression={Format-XML($_.Message)}}
	$ActionsCount = ($ConfigMgrActions | Measure-Object | Select-Object).Count
	
	# ====== 5. Network tab ======
	$InetMP = $SMSClient.GetInternetManagementPointFQDN() # Internet management point if any
	$ProxyServer = $ConfigMgrNetwork.ProxyList
	$ProxyBypassList = $ConfigMgrNetwork.ProxyBypassList
	$ProxyAccount = $ConfigMgrNetwork.Account
	
	$PropsNetwork = @{
		"Internet-based management point (FQDN)" = "${InetMP}"
		"Proxy server" = "${ProxyServer}"
		"ProxyBypassList" = "${ProxyBypassList}"
		"Proxy Account" = "${ProxyAccount}"
	}
	
	$ConfigMgrNetwork = (New-Object PSObject -Property $PropsNetwork)
	
	# ====== 6. Cache tab ======
	#$CacheLocation = $ConfigMgrCache.Location
	#$CacheSize = $ConfigMgrCache.MaxCacheSizeMB
	$ConfigMgrCache = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\SoftMgmtAgent:CacheConfig" -Query "SELECT * FROM CacheConfig" | Select-Object -Property Location, @{Name="MaxCacheSizeMB";Expression={$_.Size}}
	
	# ====== 7. Configuration tab ======
	$ConfigMgrConfig = Get-WmiObject -ErrorAction SilentlyContinue -ComputerName localhost -Namespace "ROOT\ccm\dcm" -Query "SELECT * FROM SMS_DesiredConfiguration" | Select-Object -Property DisplayName, Name, Version, @{Name="Compliance Details";Expression={Format-XML($_.ComplianceDetails)}}, LastComplianceStatus, @{Name="LastEvalTime";Expression={($_.LastEvalTime.SubString(0,4), $_.LastEvalTime.SubString(4,2),$_.LastEvalTime.SubString(6,2), $_.LastEvalTime.SubString(8,2), $_.LastEvalTime.SubString(10,2), $_.LastEvalTime.SubString(12,2)) -join "-"}}, Status
	
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<div id='mySidenav'><ul><li><a href='#ConfigMgrGeneral'>$TitleGeneral</a></li><li><a href='#ConfigMgrComponents'>$TitleComponents</a></li><li><a href='#ConfigMgrSite'>$TitleSite</a></li><li><a href='#ConfigMgrActions'>$TitleActions</a></li></li><li><a href='#ConfigMgrNetwork'>$TitleNetwork</a></li></li><li><a href='#ConfigMgrCache'>$TitleCache</a></li><li><a href='#ConfigMgrConfig'>$TitleConfig</a></li></ul></div>"
		
		# 1. General tab
		$ConfigMgrGeneral = $ConfigMgrGeneral | ConvertTo-Html -Fragment -PreContent "<h2 id='ConfigMgrGeneral'>General</h2>" -as List
		# 2. Components tab
		$ConfigMgrComponents = $ConfigMgrComponents | ConvertTo-Html -Fragment -PreContent "<h2 id='ConfigMgrComponents'>Components ($ComponentsCount)</h2>"
		# 3. Site tab
		$ConfigMgrSite = $ConfigMgrSite | ConvertTo-Html -Fragment -PreContent "<h2 id='ConfigMgrSite'>Site</h2>"
		# 4. Actions tab
		if ($ConfigMgrActions) {
			$ConfigMgrActions = $ConfigMgrActions | ConvertTo-Html -Fragment -PreContent "<h2 id='ConfigMgrActions'>Actions ($ActionsCount)</h2>"
			$ConfigMgrActions = $ConfigMgrActions -replace '<td>&lt;\?xml','<td><textarea>&lt;?xml' 
			$ConfigMgrActions = $ConfigMgrActions -replace '/SoftwareMeteringMessage&gt;</td>','/SoftwareMeteringMessage&gt;</textarea></td>'
			$ConfigMgrActions = $ConfigMgrActions -replace '/UpdateSourceMessage&gt;</td>','/UpdateSourceMessage&gt;</textarea></td>'
			$ConfigMgrActions = $ConfigMgrActions -replace '/InventoryMessage&gt;</td>','/InventoryMessage&gt;</textarea></td>'
			$ConfigMgrActions = $ConfigMgrActions -replace '/CIAssignmentMessage&gt;</td>','/CIAssignmentMessage&gt;</textarea></td>'
			$ConfigMgrActions = $ConfigMgrActions -replace '/SourceUpdateMessage&gt;</td>','/SourceUpdateMessage&gt;</textarea></td>'
			$ConfigMgrActions = $ConfigMgrActions -replace '/FileCollectionMessage&gt;</td>','/FileCollectionMessage&gt;</textarea></td>'
		}
		# 5. Network tab
		$ConfigMgrNetwork = $ConfigMgrNetwork | ConvertTo-Html -Fragment -PreContent "<h2 id='ConfigMgrNetwork'>Network</h2>" -as List
		# 6. Cache
		$ConfigMgrCache = $ConfigMgrCache | ConvertTo-Html -Fragment -PreContent "<h2 id='ConfigMgrCache'>Cache</h2>" -as List
		# 7. Configurations
		$ConfigMgrConfig = $ConfigMgrConfig | ConvertTo-Html -Fragment -PreContent "<h2 id='ConfigMgrConfig'>Configurations</h2>"
		$ConfigMgrConfig = $ConfigMgrConfig -replace '<td>&lt;ConfigurationItemReport','<td><textarea>&lt;ConfigurationItemReport' 
		$ConfigMgrConfig = $ConfigMgrConfig -replace '/ConfigurationItemReport&gt;</td>','/ConfigurationItemReport&gt;</textarea></td>'
		
		$ReportParams = @{
			Body = "$TopicName $ContentTable $ConfigMgrGeneral $ConfigMgrComponents $ConfigMgrSite $ConfigMgrActions $ConfigMgrNetwork $ConfigMgrCache $ConfigMgrConfig"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		
		$Report = ConvertTo-HTML @ReportParams
		
		#The command below will generate the report to an HTML file
		$Report | Out-File $ConfigMgrClientFile
	} else {
		
		"=== $TitleGeneral ===" | Out-File $ConfigMgrClientFile
		$ConfigMgrGeneral | Out-File -Append $ConfigMgrClientFile
		
		"=== $TitleComponents ===" | Out-File $ConfigMgrClientFile
		$ConfigMgrComponents | Out-File -Append $ConfigMgrClientFile

		"=== $TitleSite ===" | Out-File -Append $ConfigMgrClientFile
		$ConfigMgrSite | Out-File -Append $ConfigMgrClientFile
		
		"=== $TitleActions ===" | Out-File -Append $ConfigMgrClientFile
		$ConfigMgrActions | Out-File -Append $ConfigMgrClientFile
		
		"=== $TitleNetwork ===" | Out-File -Append $ConfigMgrClientFile
		$ConfigMgrNetwork | Out-File -Append $ConfigMgrClientFile
		
		"=== $TitleCache ===" | Out-File -Append $ConfigMgrClientFile
		$ConfigMgrCache | Out-File -Append $ConfigMgrClientFile
		
		"=== $TitleConfig ===" | Out-File -Append $ConfigMgrClientFile
		$ConfigMgrConfig | Out-File -Append $ConfigMgrClientFile
		
		Generate-Footer | Out-File -Append $ConfigMgrClientFile
	}
	
	Write-Verbose -Message "  *** Profiled -  Configuration Manager Client *** "
}

#########################################
# Fetch boundary group cache information
#########################################
Function Get-BGInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $BGInfoFileName = "BoundaryGroupInfo.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $BGInfoFileName = "BoundaryGroupInfo.txt"}
	$BGInfoFile = "${toLocation}\${ChildDir}" + "\" +  $BGInfoFileName
	
	$BGInfo = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\LocationServices:BoundaryGroupCache" -Query "SELECT * FROM BoundaryGroupCache" | Select-Object @{Name="BoundaryGroupIDs"; Expression={$_.BoundaryGroupIDs -join ", "}}, @{Name="BoundaryGroupGUIDs"; Expression={$_.BoundaryGroupGUIDs -join ", "}}, IsOnVPN, @{Name="DOINCServers"; Expression={$_.DOINCServers -join ", "}}, CacheToken
	
	$Title = "Boundary Group Cache"
	$OutMsg = "  *** Read - ROOT\ccm\LocationServices:BoundaryGroupCache - BoundaryGroupCache *** "
	if (! $Text) {
		$TopicName = "<h1>$Title </h1>"
		#$ContentTable = "<h3><a href='#BGInfo'>$Title </a></h3>"

		if ($BGInfo) {
			$BGInfo = $BGInfo | ConvertTo-Html -Fragment -as List
		}
		$ReportParams = @{
			Body = "$TopicName $BGInfo"
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		#$Report = ConvertTo-HTML -Body "$TopicName $ContentTable $BGInfo" -Head $header -Title $Title  -PostContent "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $BGInfoFile		
	} else {
		"=== $Title ===" | Out-File $BGInfoFile
		if ($BGInfo) {
			$BGInfo | Out-File -Append $BGInfoFile
		}
		Generate-Footer | Out-File -Append $BGInfoFile
	}
	Write-Verbose -Message $OutMsg
}

##########################################
# Fetch client pending reboot information
##########################################
Function Get-PendingRebootInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $PendingRebootInfoFileName = "PendingReboot.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $PendingRebootInfoFileName = "PendingReboot.txt" }
	$PendingRebootInfoFile = "${toLocation}\${ChildDir}" + "\" +  $PendingRebootInfoFileName
	
	$PendingRebootInfo = Invoke-WmiMethod -ErrorAction SilentlyContinue -ComputerName localhost -Namespace "ROOT\ccm\ClientSDK" -Class "CCM_ClientUtilities" -Name DetermineIfRebootPending | Select-Object -Property RebootPending, RebootDeadline, NotifyUI, InGracePeriod, IsHardRebootPending, DisableHideTime
	
	$Title = "Pending Reboot Information"
	$OutMsg = "  *** Read - ROOT\ccm\ClientSDK *** "
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		#$ContentTable = "<h3><a href='#PendingRebootInfo'>$Title</a></h3>"
		
		if ($PendingRebootInfo) {
			$PendingRebootInfo = $PendingRebootInfo | ConvertTo-Html -Fragment -as List
		}		
		$ReportParams = @{
			Body = "$TopicName $PendingRebootInfo" 
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		#$Report = ConvertTo-HTML -Body "$TopicName $ContentTable $PendingRebootInfo" -Head $header -Title $Title -PostContent "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		$Report = ConvertTo-HTML @ReportParams
		$Report = $Report -replace '<td>RebootPending:</td><td>True</td>','<td>RebootPending:</td><td class="OrangeStatus">True</td>'
		$Report = $Report -replace '<td>RebootPending:</td><td>False</td>','<td>RebootPending:</td><td class="GreenStatus">False</td>'
		$Report = $Report -replace '<td>IsHardRebootPending:</td><td>True</td>','<td>IsHardRebootPending:</td><td class="OrangeStatus">True</td>'
		$Report = $Report -replace '<td>IsHardRebootPending:</td><td>False</td>','<td>IsHardRebootPending:</td><td class="GreenStatus">False</td>'
		#The command below will generate the report to an HTML file
		$Report | Out-File $PendingRebootInfoFile
	} else {
		"=== $Title ===" | Out-File $PendingRebootInfoFile
		if ($PendingRebootInfo) {
			$PendingRebootInfo | Out-File -Append $PendingRebootInfoFile
		}
		Generate-Footer | Out-File -Append $PendingRebootInfoFile
	}
	Write-Verbose -Message $OutMsg
}

##############################################################
# Copy client install logs - ccmsetup.log and client.msi.log
##############################################################
Function Get-ClientInstallLogs {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location)
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# Copy ${ENV:windir}\ccmsetup\Logs, including ccmsetup.log and client.msi.log
	if (Test-Path "${ENV:windir}\ccmsetup\Logs") {
		Copy-Item "${ENV:windir}\ccmsetup\Logs" -Destination "${toLocation}\${ChildDir}\ccmsetup\Logs" -Recurse
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\ccmsetup\Logs *** "
	}
	
	# Copy ${ENV:windir}\smscfg.ini
	if (Test-Path "${ENV:windir}\smscfg.ini") {
		Copy-Item "${ENV:windir}\smscfg.ini" -Destination "${toLocation}\${ChildDir}\smscfg.ini"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\smscfg.ini *** "
	}
}


#####################################################
# Copy client CCM\Logs
#####################################################
Function Get-CCMLogs {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location)
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# Copy ${ENV:windir}\CCM\Logs
	if (Test-Path "${ENV:windir}\CCM\Logs") {
		Copy-Item "${ENV:windir}\CCM\Logs" -Destination "${toLocation}\${ChildDir}\CCM\Logs" -Recurse
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\CCM\Logs *** "
	}
}

##################################################
# Copy Windows logs in case of OS upgrade failure
##################################################
Function Get-WinOSUpgradeLogs {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location)
	)

	if (! (Test-Path "${toLocation}\WinOSUpgrade")) { New-Item -ItemType "Directory" "${toLocation}\WinOSUpgrade" | Out-Null }
	
	$Path = "${ENV:SystemDrive}" + '\$Windows.~BT\Sources\Panther'
	if (Test-Path "${Path}") {
		Copy-Item -ErrorAction SilentlyContinue "${Path}" -Destination ("${toLocation}\WinOSUpgrade" + '\$Windows.~BT\Sources\Panther') -Recurse
		Write-Verbose -Message ("  *** Copied -  ${ENV:SystemDrive}" + '\$Windows.~BT\Sources *** ')
	}

	if (Test-Path "${ENV:windir}\Logs\MoSetup\BlueBox.log") {
		Copy-Item -ErrorAction SilentlyContinue "${ENV:windir}\Logs\MoSetup\BlueBox.log" -Destination "${toLocation}\Logs\MoSetup\BlueBox.log"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\Logs\MoSetup\BlueBox.log *** "
	}
	
	# C:\Windows\setupcomplete.log
	if(Test-Path "${ENV:windir}\setupcomplete.log") {
		Copy-Item -ErrorAction SilentlyContinue "${ENV:windir}\setupcomplete.log" -Destination "${toLocation}\WinOSUpgrade\setupcomplete.log"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\setupcomplete.log *** "
	}
	
	# C:\Windows\debug\netsetup.log
	if(Test-Path "${ENV:windir}\debug\netsetup.log") {
		Copy-Item -ErrorAction SilentlyContinue "${ENV:windir}\debug\netsetup.log" -Destination "${toLocation}\WinOSUpgrade\netsetup.log"
		Write-Verbose -Message "  *** Copied -  ${ENV:windir}\debug\netsetup.log *** "
	}

}

###################################################################################################################
# Fetch bits jobs information
# https://docs.microsoft.com/en-us/windows/client-management/mdm/policy-csp-admx-bits
###################################################################################################################
Function Get-BitsInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $BitsInfoFileName = "BitsInfo.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "BITs"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $BitsInfoFileName = "BitsInfo.txt"}
	$BitsInfoFile = "${toLocation}\${ChildDir}" + "\" +  $BitsInfoFileName
	
	$BGRegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Policies\Microsoft\Windows\BITS' | Select-Object -Property EnableBitsMaxBandwidth, MaxBandwidthValidFrom, MaxBandwidthValidTo, @{Name="MaxTransferRateOnSchedule (Kb/s)";Expression={$_.MaxTransferRateOnSchedule}}, @{Name="MaxTransferRateOffSchedule (Kb/s)";Expression={$_.MaxTransferRateOffSchedule}}, DisableBranchCache, DisablePeerCachingClient, DisablePeerCachingServer, EnablePeercaching, @{Name="MaxCacheSize (% System Disk Size)";Expression={$_.MaxCacheSize}}, @{Name="MaxContentAge (days)";Expression={$_.MaxContentAge}}             
	
	$Title = "Background Intelligent Registry Info and Transfer Jobs"
	$TitleBitsReg = "Bits Registry"
	$TitleBitsJobs = "Bits Jobs"
	$OutMsg = "  *** Fetched - Bits registry and jobs information *** "
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		$ContentTable = "<div id='mySidenav'><ul><li><a href='#BitsRegInfo'>$TitleBitsReg</a></li><li><a href='#BitsJobs'>$TitleBitsJobs</a></li></ul></div>"
		
		BitsAdmin /list /allusers /verbose | Out-File "${toLocation}\${ChildDir}\BitsInfo.txt"
		
		$BGRegInfo = $BGRegInfo| ConvertTo-Html -Fragment -PreContent "<h2 id='BitsRegInfo'>BITS Registry</h2>" -as List
		
		# Create a PowerShell object
		$Props = @{
			File = "${toLocation}\${ChildDir}\BitsInfo.txt"
			Location = "<a href=BitsInfo.txt>${toLocation}\${ChildDir}\BitsInfo.txt</a>"
		}
		$Object = (New-Object PSObject -Property $Props) | ConvertTo-Html -Fragment -PreContent "<h2 id='BitsJobs'>BITS Jobs</h2>" -as List
		$BitsInfo = $Object -replace '&gt;','>' -replace '&lt;','<' -replace '&#39;',"'"		
				
		$ReportParams = @{
			Body = "$TopicName $ContentTable $BGRegInfo $BitsInfo " 
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}

		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $BitsInfoFile
	} else {
		"=== $Title ===" | Out-File $BitsInfoFile
		$BGRegInfo | Out-File -Append $BitsInfoFile
		BitsAdmin /list /allusers /verbose | Out-File -Append $BitsInfoFile
		Generate-Footer | Out-File -Append $BitsInfoFile
	}
	Write-Verbose -Message $OutMsg
}

####################################################################################
# Get hot fixes
####################################################################################
Function Get-HotFixes {
	Param(
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][Switch] $Text,
		[Parameter(Mandatory = $false)][String] $HotFixFileName = "HotFix.html"
	)
	
	$ChildDir = "General"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	if ($Text) { $HotFixFileName = "HotFix.txt" }
	$HotFixResultFile = ("${toLocation}\${ChildDir}" + "\" + $HotFixFileName)
	$HotFixes = (Get-WMIObject -ErrorAction SilentlyContinue -namespace "Root\cimv2" -query "SELECT * From Win32_QuickFixEngineering" | Sort-Object -Property InstalledOn -Descending)
	$Count = ($HotFixes | Measure-Object | Select-Object).Count
	if (! $Text) {
		$TopicName = "<h1>Hot Fixes</h1>"
		$Title = "Hot Fixes"
		$ReportParams = @{
			Body = $TopicName
			Head = $header
			Title = $Title
			#Property = CSName, Description, HotFixID, InstallledBy, InstalledOn, Caption, FixComments
			PreContent =  "<h2>${Count} hot fixes</h2>"
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>"
		}
		$Report = $HotFixes | ConvertTo-HTML @ReportParams -Property CSName, Description, HotFixID, InstallledBy, InstalledOn, Caption, FixComments

		$Report | Out-File $HotFixResultFile
	} else {
		"=== ${Count} hot fixes ===" | Out-File $HotFixResultFile
		$HotFixes | Out-File -Append $HotFixResultFile
		Generate-Footer | Out-File -Append $HotFixResultFile
	}
	Write-Verbose -Message "  *** Fetched -  Hot Fixes *** "
}

#################################################
# Fetch client inbound/outbound firewall rules
#################################################
Function Get-FirewallRules {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $FirewallInfoFileName = "FirewallSettings.html",
		[Parameter(Mandatory = $false)][Switch] $Text
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "Firewall"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	if ($Text) { $FirewallInfoFileName = "FirewallSettings.txt" }
	$FirewallInfoFile = "${toLocation}\${ChildDir}" + "\" +  $FirewallInfoFileName
	
	$FirewallInfo = Get-NetFirewallRule -ErrorAction SilentlyContinue | Select-Object -Property Direction, Name, Action, DisplayName, Enabled, Status, Description, DisplayGroup, Group, Profile, @{Name="Platform"; Expression={$_.Platform -join ", "}}, EdgeTraversalPolicy, LooseSourceMapping, LocalOnlyMapping, Owner, PrimaryStatus, EnforcementStatus, PolicyStoreSource, PolicyStoreSourceType | Sort-Object -Property Direction, DisplayName
	$Count = ($FirewallInfo | Measure-Object | Select-Object).Count
	
	$Title = "Windows Firewall Rules"
	$OutMsg = "  *** Read - Windows Firewall Rules *** "
	if (! $Text) {
		$TopicName = "<h1>$Title</h1>"
		#$ContentTable = "<h3><a href='#FirewallInfo'>$Title</a></h3>"
		
		if ($FirewallInfo) {
			$FirewallInfo = $FirewallInfo | ConvertTo-Html -Fragment -PreContent "<h2 id='FirewallInfo'>$Count rule(s)</h2>"
		}		
		$ReportParams = @{
			Body = "$TopicName $FirewallInfo" 
			Head = $header
			Title = $Title
			PostContent = "<p id='CreationDate'>Creation Date: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss zzz') - $(([System.TimeZone]::CurrentTimeZone | Select-Object StandardName).StandardName) ($( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname))</p>" 
		}
		$Report = ConvertTo-HTML @ReportParams
		#The command below will generate the report to an HTML file
		$Report | Out-File $FirewallInfoFile
	} else {
		"=== $Title ===" | Out-File $FirewallInfoFile
		if ($FirewallInfo) {
			$FirewallInfo | Out-File -Append $FirewallInfoFile
		}
		Generate-Footer | Out-File -Append $FirewallInfoFile
	}
	Write-Verbose -Message $OutMsg
}

########################################################################
# Run FLTMC to list file system drivers
# Look for if Symantec, McAfee, Trend Micro, Sopos, Cylance are present
########################################################################
Function Get-FileSysDrivers {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $FLTMCFileName = "FLTMC.txt"
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "Firewall"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	$FirewallInfoFile = "${toLocation}\${ChildDir}" + "\" +  $FLTMCFileName
	cmd /c FLTMC > $FirewallInfoFile
	
	$OutMsg = "  *** Fetched - File System Drivers *** "
	Write-Verbose -Message $OutMsg
}

##############################################################################################
# Run dsregcmd /status to list file system drivers
# The dsregcmd /status utility must be run as a domain user account.
# https://docs.microsoft.com/en-us/azure/active-directory/devices/troubleshoot-device-dsregcmd
##############################################################################################
Function Get-DeviceState {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false)][String] $dsregcmdFileName = "dsregcmd.txt"
	)
	# Subdirectory to hold the result file(s)
	$ChildDir = "General"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# File location
	$dsregcmdFile = "${toLocation}\${ChildDir}" + "\" +  $dsregcmdFileName
	cmd /c dsregcmd /status /debug /all > $dsregcmdFile
	
	$OutMsg = "  *** Queried - State of the device *** "
	Write-Verbose -Message $OutMsg
}

##################################################
# Get network, SChannel registry, MDM, Tasks
##################################################
Function Get-RegNCertNSChannelNMDM {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location)
	)
	
	$ChildDir = "General"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	$_LOG_DIR = "$toLocation\$ChildDir"
	
	$_MDM_LOG_DIR = "$_LOG_DIR\DeviceManagementAndMDM"
	$_CERT_LOG_DIR ="$_LOG_DIR\CertinfoAndCertenroll"
	$_Schtasks_LOG_DIR = "$_LOG_DIR\ScheduledTasks"
	$_REG_LOG_DIR = "$_LOG_DIR\Registry"
	$_NET_LOG_DIR = "$_LOG_DIR\Network"

	if (! (Test-Path "_MDM_LOG_DIR")) {New-Item -Path $_MDM_LOG_DIR -ItemType Directory | Out-Null}
	if (! (Test-Path "$_CERT_LOG_DIR")) { New-Item -Path $_CERT_LOG_DIR -ItemType Directory | Out-Null}
	if (! (Test-Path "$_Schtasks_LOG_DIR")) {New-Item -Path $_Schtasks_LOG_DIR -ItemType Directory | Out-Null}
	if (! (Test-Path "$_REG_LOG_DIR")) {New-Item -Path $_REG_LOG_DIR -ItemType Directory | Out-Null}
	if (! (Test-Path "$_NET_LOG_DIR")) {New-Item -Path $_NET_LOG_DIR -ItemType Directory | Out-Null}

	Add-Content -Path $_LOG_DIR\Tasklist.txt -Value (tasklist /svc 2>&1) | Out-Null

	Add-Content -Path $_NET_LOG_DIR\DisplayDNS.txt -Value (ipconfig /displaydns 2>&1) | Out-Null
	Add-Content -Path $_NET_LOG_DIR\netstat.txt -Value (netstat -ano 2>&1) | Out-Null
	Add-Content -Path $_NET_LOG_DIR\NetworkLocation.txt -Value (nltest /dsgetdc: /force 2>&1) | Out-Null
	Add-Content -Path $_NET_LOG_DIR\IPConfig.txt -Value (IPConfig /ALL 2>&1) | Out-Null

	# ***Reg Exports***
	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa" /s > $_REG_LOG_DIR\Lsa-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies" /s > $_REG_LOG_DIR\Policies-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\System" /s > $_REG_LOG_DIR\SystemGP-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServer" /s > $_REG_LOG_DIR\Lanmanserver-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanWorkstation" /s > $_REG_LOG_DIR\Lanmanworkstation-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon" /s > $_REG_LOG_DIR\Netlogon-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL" /s > $_REG_LOG_DIR\0-Schannel-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Cryptography" /s > $_REG_LOG_DIR\0-Cryptography-HKLMControl-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography" /s > $_REG_LOG_DIR\0-Cryptography-HKLMSoftware-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Cryptography" /s > $_REG_LOG_DIR\0-Cryptography-HKLMSoftware-Policies-key.txt 2>&1 | Out-Null

	reg query "HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Cryptography" /s > $_REG_LOG_DIR\0-Cryptography-HKCUSoftware-Policies-key.txt 2>&1 | Out-Null
	reg query "HKEY_CURRENT_USER\SOFTWARE\Microsoft\Cryptography" /s > $_REG_LOG_DIR\0-Cryptography-HKCUSoftware-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\SmartCardCredentialProvider" /s > $_REG_LOG_DIR\SCardCredentialProviderGP-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication" /s > $_REG_LOG_DIR\Authentication-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Authentication" /s > $_REG_LOG_DIR\Authentication-key-Wow64.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /s > $_REG_LOG_DIR\Winlogon-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Winlogon" /s > $_REG_LOG_DIR\Winlogon-CCS-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\IdentityStore" /s > $_REG_LOG_DIR\Idstore-Config-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\IdentityCRL" /s >> $_REG_LOG_DIR\Idstore-Config-key.txt 2>&1 | Out-Null
	reg query "HKEY_USERS\.Default\Software\Microsoft\IdentityCRL" /s >> $_REG_LOG_DIR\Idstore-Config-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Kdc" /s > $_REG_LOG_DIR\KDC-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\KPSSVC" /s > $_REG_LOG_DIR\KDCProxy-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\CloudDomainJoin" /s > $_REG_LOG_DIR\RegCDJ-key.txt 2>&1 | Out-Null
	reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\WorkplaceJoin" /s > $_REG_LOG_DIR\Reg-WPJ-key.txt 2>&1 | Out-Null
	reg query "HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\WorkplaceJoin\AADNGC" /s > $_REG_LOG_DIR\RegAADNGC-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\Software\Policies\Windows\WorkplaceJoin" /s > $_REG_LOG_DIR\Reg-WPJ-Policy-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Winbio" /s > $_REG_LOG_DIR\Winbio-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\WbioSrvc" /s > $_REG_LOG_DIR\Wbiosrvc-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Biometrics" /s > $_REG_LOG_DIR\Winbio-Policy-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\EAS\Policies" /s > $_REG_LOG_DIR\Eas-key.txt 2>&1 | Out-Null

	reg query "HKEY_CURRENT_USER\SOFTWARE\Microsoft\SCEP" /s > $_REG_LOG_DIR\Scep-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\SQMClient" /s > $_REG_LOG_DIR\MachineId.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Policies\PassportForWork" /s > $_REG_LOG_DIR\NgcPolicyIntune-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\PassportForWork" /s > $_REG_LOG_DIR\NgcPolicyGp-key.txt 2>&1  | Out-Null
	reg query "HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\PassportForWork" /s > $_REG_LOG_DIR\NgcPolicyGpUser-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Cryptography\Ngc" /s > $_REG_LOG_DIR\NgcCryptoConfig-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\PolicyManager\current\device\DeviceLock" /s > $_REG_LOG_DIR\DeviceLockPolicy-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Policies\PassportForWork\SecurityKey " /s > $_REG_LOG_DIR\FIDOPolicyIntune-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\FIDO" /s > $_REG_LOG_DIR\FIDOGp-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\Rpc" /s > $_REG_LOG_DIR\RpcGP-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NTDS\Parameters" /s > $_REG_LOG_DIR\NTDS-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LDAP" /s > $_REG_LOG_DIR\LdapClient-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\DeviceGuard" /s > $_REG_LOG_DIR\DeviceGuard-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v2.0.50727" > $_REG_LOG_DIR\DotNET-TLS-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\.NETFramework\v4.0.30319" >> $_REG_LOG_DIR\DotNET-TLS-key.txt 2>&1 | Out-Null 
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v4.0.30319" >> $_REG_LOG_DIR\_REG_LOG_DIR-TLS-key.txt 2>&1 | Out-Null 
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\.NETFramework\v2.0.50727" >> $_REG_LOG_DIR\DotNET-TLS-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\SharedPC" > $_REG_LOG_DIR\SharedPC.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\PasswordLess" > $_REG_LOG_DIR\Passwordless.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Authz" /s > $_REG_LOG_DIR\Authz-key.txt 2>&1 | Out-Null

	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\WinHttp" > $_REG_LOG_DIR\WinHttp-TLS-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Internet Settings\WinHttp" >> $_REG_LOG_DIR\WinHttp-TLS-key.txt 2>&1 | Out-Null
	reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\FingerprintLogon\S-1-1-0\" >> $_REG_LOG_DIR\FingerprintLogon.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\Credential Providers" >> $_REG_LOG_DIR\providers.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\UserTile" >> $_REG_LOG_DIR\usertile.txt 2>&1 | Out-Null

	Add-Content -Path $_NET_LOG_DIR\http-show-sslcert.txt -Value (netsh http show sslcert 2>&1) | Out-Null
	Add-Content -Path $_NET_LOG_DIR\http-show-urlacl.txt -Value (netsh http show urlacl 2>&1) | Out-Null

	Add-Content -Path $_NET_LOG_DIR\trustinfo.txt -Value (nltest /DOMAIN_TRUSTS /ALL_TRUSTS /V 2>&1) | Out-Null

	$domain = (Get-WmiObject Win32_ComputerSystem).Domain
	switch ($ProductType)
		{
			"WinNT"
				{
					Add-Content -Path $_NET_LOG_DIR\SecureChannel.txt -Value (nltest /sc_query:$domain 2>&1) | Out-Null
				}
			"ServerNT" 
				{
					Add-Content -Path $_NET_LOG_DIR\SecureChannel.txt -Value (nltest /sc_query:$domain 2>&1) | Out-Null
				}
		}

	# *** Cert enrolment info
	Copy-Item "$($env:windir)\CertEnroll.log" -Destination $_CERT_LOG_DIR\CertEnroll-fromWindir.log -Force 2>&1 | Out-Null

	Copy-Item "$($env:windir)\certmmc.log" -Destination $_CERT_LOG_DIR\CAConsole.log -Force 2>&1 | Out-Null
	Copy-Item "$($env:windir)\certocm.log" -Destination $_CERT_LOG_DIR\ADCS-InstallConfig.log -Force 2>&1 | Out-Null
	Copy-Item "$($env:windir)\certsrv.log" -Destination $_CERT_LOG_DIR\ADCS-Debug.log -Force 2>&1 | Out-Null
	Copy-Item "$($env:windir)\CertUtil.log" -Destination $_CERT_LOG_DIR\CertEnroll-Certutil.log -Force 2>&1 | Out-Null
	Copy-Item "$($env:windir)\certreq.log" -Destination $_CERT_LOG_DIR\CertEnroll-Certreq.log -Force 2>&1 | Out-Null

	Copy-Item "$($env:userprofile)\CertEnroll.log" -Destination $_CERT_LOG_DIR\CertEnroll-fromUserProfile.log -Force 2>&1 | Out-Null
	Copy-Item "$($env:LocalAppData)\CertEnroll.log" -Destination $_CERT_LOG_DIRCertEnroll\CertEnroll-fromLocalAppData.log -Force 2>&1 | Out-Null

	# *** Scheduled tasks info
	Add-Content -Path $_Schtasks_LOG_DIR\Schtasks.query.v.txt -Value (schtasks.exe /query /v 2>&1) | Out-Null
	Add-Content -Path $_Schtasks_LOG_DIR\Schtasks.query.xml.txt -Value (schtasks.exe /query /xml 2>&1) | Out-Null

	# ***MDM***
	reg query "HKEY_LOCAL_MACHINE\Software\Microsoft\Enrollments" /s > $_MDM_LOG_DIR\MDMEnrollments-key.txt 2>&1 | Out-Null
	reg query "HKEY_LOCAL_MACHINE\Software\Microsoft\EnterpriseResourceManager" /s > $_MDM_LOG_DIR\MDMEnterpriseResourceManager-key.txt 2>&1 | Out-Null
	reg query "HKEY_CURRENT_USER\Software\Microsoft\SCEP" /s > $_MDM_LOG_DIR\MDMSCEP-User-key.txt 2>&1 | Out-Null
	reg query "HKEY_CURRENT_USER\S-1-5-18\Software\Microsoft\SCEP" /s > $_MDM_LOG_DIR\MDMSCEP-SystemUser-key.txt 2>&1 | Out-Null

	wevtutil query-events Microsoft-Windows-DeviceManagement-Enterprise-Diagnostics-Provider/Admin /format:text > $_MDM_LOG_DIR\DmEventLog.txt 2>&1 | Out-Null

	#DmEventLog.txt and Microsoft-Windows-DeviceManagement-Enterprise-Diagnostics-Provider-Admin.txt might contain the same content
	$DiagProvierEntries = wevtutil el 
	foreach ($DiagProvierEntry in $DiagProvierEntries)
	{
		$tempProvider = $DiagProvierEntry.Split('/')
		if ($tempProvider[0] -eq "Microsoft-Windows-DeviceManagement-Enterprise-Diagnostics-Provider")
		{
			wevtutil qe $($DiagProvierEntry) /f:text /l:en-us > "$_MDM_LOG_DIR\$($tempProvider[0])-$($tempProvider[1]).txt"   2>&1 | Out-Null
		}
	}

	$OutMsg = "  *** Queried - Registry, certificates, Scheduled tasks, MDM *** "
	Write-Verbose -Message $OutMsg
}

##################################################
# Format file size 
##################################################
Function Format-FileSize() {
	Param (
		[Parameter(Mandatory = $true)][Int] $Size
	)
	If ($Size -gt 1TB) {[string]::Format("{0:0.00} TB", $Size / 1TB)}
	ElseIf ($Size -gt 1GB) {[string]::Format("{0:0.00} GB", $Size / 1GB)}
	ElseIf ($Size -gt 1MB) {[string]::Format("{0:0.00} MB", $Size / 1MB)}
	ElseIf ($Size -gt 1KB) {[string]::Format("{0:0.00} kB", $Size / 1KB)}
	ElseIf ($Size -gt 0) {[string]::Format("{0:0.00} B", $Size)}
	Else {""}
}

##################################################
# Enable/Disable SMS Client Verbose 
##################################################
Function Configure-Verbose {
	Param( 
		[Parameter(Mandatory = $false, ParameterSetName = 'AV')][Switch] $AV,
		[Parameter(Mandatory = $false, ParameterSetName = 'DV')][Switch] $DV
	)
	
	# Enable verbose
	if ($AV) {
		# Enable client/MP verbose
		Set-ItemProperty -ErrorAction SilentlyContinue -Path Registry::HKLM\SOFTWARE\Microsoft\CCM\Logging\@GLOBAL -name LogLevel -value 0
		Set-ItemProperty -ErrorAction SilentlyContinue -Path Registry::HKLM\SOFTWARE\Microsoft\CCM\Logging\@GLOBAL -name LogMaxSize -value 15500000
		Set-ItemProperty -ErrorAction SilentlyContinue -Path Registry::HKLM\SOFTWARE\Microsoft\CCM\Logging\@GLOBAL -name LogMaxHistory -value 5
		New-Item -ErrorAction SilentlyContinue -Path Registry::HKLM\SOFTWARE\Microsoft\CCM\Logging -Name DebugLogging -Force | Out-Null
		Set-ItemProperty -ErrorAction SilentlyContinue -Path Registry::HKLM\SOFTWARE\Microsoft\CCM\Logging\DebugLogging  -Name Enabled -value True
		
		# Print the result
		Write-Verbose -Message "SMS Agent verbose enabled"
	}
	
	# Disable verbose
	if ($DV) {
		# Disable client/MP verbose
		Set-ItemProperty -ErrorAction SilentlyContinue -Path Registry::HKLM\SOFTWARE\Microsoft\CCM\Logging\@GLOBAL -name LogLevel -value 1
		Set-ItemProperty -ErrorAction SilentlyContinue -Path Registry::HKLM\SOFTWARE\Microsoft\CCM\Logging\@GLOBAL -name LogMaxSize -value 250000
		Set-ItemProperty -ErrorAction SilentlyContinue -Path Registry::HKLM\SOFTWARE\Microsoft\CCM\Logging\@GLOBAL -name LogMaxHistory -value 1
		Remove-Item -ErrorAction SilentlyContinue -Path Registry::HKLM\SOFTWARE\Microsoft\CCM\Logging\DebugLogging -Recurse
	
		# Print the result
		Write-Verbose -Message "SMS Agent verbose disabled"
	}
	
	# Print the current verbose settings
	Write-Verbose $(Get-ItemProperty -ErrorAction SilentlyContinue -Path Registry::HKLM\SOFTWARE\Microsoft\CCM\Logging\@GLOBAL | Select-Object -Property LogEnabled, LogLevel, LogMaxHistory, LogMaxSize, PSPath)
}

###############################################################################################################################################
# Main process goes here
###############################################################################################################################################
# Generate a content table for the files in the current directory
Function Construct-ContentTable {
	Param(
		[Parameter(Mandatory = $true)][String] $CurrentLocation
	)
	# Construct the index html
	# index html starting part

	"<html xmlns='http://www.w3.org/1999/xhtml'> <head>$header</head><body>" | Out-File "${CurrentLocation}\0-index.html"
	
	$OverlayDiv = '<div id="peekContent" class="overlay"><a href="javascript:void(0)" class="closebtn" onclick="closePeek()">&times;</a><div class="overlay-content"><iframe id="innerframe"></iframe></div></div>'
	$OverlayDiv | Out-File "${CurrentLocation}\0-index.html" -Append
	
	# Content table head
	"<h1>Content Table</h1>" | Out-File "${CurrentLocation}\0-index.html" -Append
	$TopLevel = Get-ChildItem -Path ${CurrentLocation} | Sort-Object
	
	# Content table content
	$ContentTable = "<div id='mySidenav'><ul>"
	foreach ($Item in $TopLevel) {
		if ($Item.Mode[0] -eq 'd') {
			$ContentTable = $ContentTable + "<li><a href=#$Item>$Item</a></li></li>"
		}
	}
	$ContentTable = $ContentTable + "</ul></div>"
	$ContentTable | Out-File "${CurrentLocation}\0-index.html" -Append
	
	"<div id='index'>" | Out-File "${CurrentLocation}\0-index.html" -Append

	foreach ($Item in $TopLevel) {
		if ($Item.Mode[0] -eq 'd') {
			# Outer table start
			"<table>" | Out-File "${CurrentLocation}\0-index.html" -Append
			"<tr><th id=$Item>$Item</th></tr>" | Out-File "${CurrentLocation}\0-index.html" -Append
			'<tr><td style="vertical-align:top">' | Out-File "${CurrentLocation}\0-index.html" -Append
			# Retrieve the secondary level content 
			$SecondLevel =  Get-ChildItem -Path "${CurrentLocation}\$Item" | Sort-Object
			# Inner table start
			"<table>" | Out-File "${CurrentLocation}\0-index.html" -Append
			foreach ($SecItem in $SecondLevel) {
				$CT = $SecItem.CreationTime
				$Size = Format-FileSize -Size $SecItem.Length
				# Javascript for viewing html or txt files
				$ViewAction = "<span style='font-size:1em;cursor:pointer' onclick=openPeek('" + "./$Item/$SecItem" + "')>&#9776; View</span>"
				if ($SecItem -match "\.html" -or $SecItem -match "\.txt") {
					$Row = "<tr><td> <a href=.\$Item\$SecItem>$SecItem</a> <td>$ViewAction</td> <td>$CT</td><td>$Size</td></tr>" 
				} else {
					$Row = "<tr><td> <a href=.\$Item\$SecItem>$SecItem</a> <td>$ViewAction</td> <td>$CT</td><td>$Size</td></tr>"
				}
				$Row | Out-File "${CurrentLocation}\0-index.html" -Append
			}
			# Inner table end
			"</table>" | Out-File "${CurrentLocation}\0-index.html" -Append
			"</td></tr>" | Out-File "${CurrentLocation}\0-index.html" -Append
			# Outer table end
			"</table>" | Out-File "${CurrentLocation}\0-index.html" -Append
		}
	}

	# index html ending part
	"<p id='CreationDate'>" + $(Generate-Footer) + "</p></body></html>" | Out-File "${CurrentLocation}\0-index.html" -Append
	"</body></html>" | Out-File "${CurrentLocation}\0-index.html" -Append
}

# Generate tag
# Tag, which defaults to date in format - 2012-03-08T11.00.24.4192623-08.00
Function Generate-Tag {
	$Tag = (Get-Date -Format o | foreach {$_ -replace ":", "."}) + "-(" + ( ([System.Net.Dns]::GetHostByName(($env:computerName))).Hostname) + ")"
	Return $Tag
}

# Zip collected files
Function Zip-CollectedFiles {
	Param(
		[Parameter(Mandatory = $true)][String] $CurrentLocation,
		[Parameter(Mandatory = $true, ParameterSetName = 'Common')][String] $Tag,
		[Parameter(Mandatory = $false)][Switch] $OpenDestDir
	)
	
	# Zip the files into ${Tag}.zip to the subdirectory ${CurrentLocation}\..
	Print-Message -150 "  ### Compressing files in -  ${CurrentLocation} ...  "
	Compress-Archive -ErrorAction SilentlyContinue -Path $CurrentLocation -Destination "${CurrentLocation}\..\${Tag}.zip"
	Print-Message -150 "  ### Compressing files completed.  "
	
	# Variable for the result directory or zipped file
	$ResultSize = 0
	
	if (Test-Path "${CurrentLocation}\..\${Tag}.zip") {
		# Remove the unzipped files if the zipped file has been created successfully
		#Remove-Item -ErrorAction SilentlyContinue "${CurrentLocation}" -Recurse
		$ResultSize = Format-FileSize((Get-Item "${CurrentLocation}\..\${Tag}.zip").length)
	} else {
		# If zipping file action failed, calculate the ${Tag} directory size
		Format-FileSize((Get-ChildItem "${CurrentLocation}" -Recurse | Measure-Object -Property length -Sum).Sum)
	}
	
	<## End time
	$EndTime = Get-Date
	$TimeDiff = ($EndTime - $StartTime).TotalSeconds
	# Instruct the customer to get the zipped files
	Print-Message -150 "  @@@ Script completed within ${TimeDiff} ! @@@  " "Magenta"#>
	Print-Message -150 "  ### Please get the file at the following location ###  " "Red"
	if (Test-Path "${CurrentLocation}\..\${Tag}.zip") {
	    Print-Message -150 "  ### --> ${CurrentLocation}.zip, Size ${ResultSize} <-- ###  " "DarkGreen"
	} else {
		Print-Message -150 "  ### --> ${CurrentLocation}, Size ${ResultSize} <-- ###  " "DarkGreen"
	}
	
	# Open the destination directory if required
	if ($OpenDestDir) {Invoke-Item -ErrorAction SilentlyContinue "${CurrentLocation}\.."}
}

Function Collect-ClientInfo {
	<#
	.SYNOPSIS
		This script is is used to:
			collect Windows Update related information, including Windows Update registry info, Windows Update logs, group policy settings and system info.
			collect client install info and sccm client agent info
	.DESCRIPTION

	.PARAMETER
		-Tag: Used for creating a directory with the name specified by this parameter
		-General: Get-Whoami, Get-WUFiles, Get-EvtxLogs, Get-GPResult
		-SMSAgent: Get-ClientInstallLogs, Get-CCMLogs, Get-ClientRegInfo, Get-ClientMyCertInfo, Get-MPInfo, Get-BGInfo, Get-PendingRebootInfo, Get-SUPInfo, Get-ServiceWindowInfo, Get-StateMsgInfo, Profile-SCCMClient, Profile-SoftwareCenter Get-ClientSettings   
		-StateMsg
		-UpdateStore
		-WinOSUpgrade
		-BitsJobs
		-Security
	.EXAMPLE
		Collect-ClientInfo -Tag -General -SMSAgent -StateMsg -UpdateStore  -BitsJobs --Security -WinOSUpgrade
		Collect-ClientInfo -Tag  -General -SMSAgent -StateMsg -UpdateStore -BitsJobs -Security -WinOSUpgrade -Text
		Collect-ClientInfo -Tag  -General
		Collect-ClientInfo -Tag  -General -Text
		Collect-ClientInfo -Tag  -SMSAgent
		Collect-ClientInfo -Tag  -SMSAgent -Text
	#>
	
	[CmdletBinding(DefaultParameterSetName = 'Common')]
	Param(
		# Begin - Define some global parameters
		# Control to get text format or html format content
		[Parameter(Mandatory = $false, ParameterSetName = 'Common')][Switch] $Text,
		# Options to generate WU info or/and client agent info
		[Parameter(Mandatory = $true, ParameterSetName = 'Common')][Switch] $General,
		[Parameter(Mandatory = $false, ParameterSetName = 'Common')][Switch] $SMSAgent,
		[Parameter(Mandatory = $false, ParameterSetName = 'Common')][Switch] $StateMsg,
		[Parameter(Mandatory = $false, ParameterSetName = 'Common')][Switch] $UpdateStore,
		[Parameter(Mandatory = $false, ParameterSetName = 'Common')][Switch] $AppInstalled,
		[Parameter(Mandatory = $false, ParameterSetName = 'Common')][Switch] $ProgInstalled,
		[Parameter(Mandatory = $false, ParameterSetName = 'Common')][Switch] $WinOSUpgrade,
		[Parameter(Mandatory = $false, ParameterSetName = 'Common')][Switch] $BitsJobs,
		[Parameter(Mandatory = $false, ParameterSetName = 'Common')][Switch] $Security,
		[Parameter(Mandatory = $true, ParameterSetName = 'Common')][String] $Tag
		# Set a subdirectory in the current working directory ., by default it is ForMSFT-ClientInfo
		#[Parameter(Mandatory = $false, ParameterSetName = 'Common')][String] $SubDir = "ForMSFT-ClientInfo",
		# Set the current location to the current working directory's subdirectory
		#[Parameter(Mandatory = $false, ParameterSetName = 'Common')][String] $CurrentLocation = ".\${SubDir}\${Tag}",
		#[Parameter(Mandatory = $true, ParameterSetName = 'Common')][String] $CurrentLocation
		# End - Define some global parameters
	)
	
	$SubDir = "ForMSFT-ClientInfo" # Always create this subdirectory in the current working directory to hold the files to be collected
	$CurrentLocation = ".\${SubDir}\${Tag}"
	if (!(Test-Path $CurrentLocation)) { New-Item -ItemType "Directory" -Path $CurrentLocation | Out-Null}
	
	# Turn off progress bar to speed up the script
	#$ProgressPreference = 'SilentlyContinue'
	
	# Start time
	$StartTime = Get-Date
	
	# Declaration
	#Print-Message -150 "  !!! Declaration: This script WILL NOT change anything on your computer. !!!  " "Red"
	Print-Declaration
	Write-Host "  ### <<< All the files collected can be found at the following location ### >>>  "
	Write-Host "  ### <<< ${CurrentLocation} >>>  "
	Write-Host "  @@@ Script running ...... @@@  "
	Start-Sleep -s 3
	# Start to retrieve info
	if ($General) {
		Get-Whoami -toLocation $CurrentLocation
		Get-WUFiles -toLocation $CurrentLocation
		Get-EvtxLogs -toLocation $CurrentLocation
		Get-GPResult -toLocation $CurrentLocation
		Get-FileSysDrivers -toLocation $CurrentLocation
		Get-DeviceState -toLocation $CurrentLocation
		Get-InstalledPkgs -toLocation $CurrentLocation
		Export-Certs -toLocation $CurrentLocation
		Get-RegNCertNSChannelNMDM $CurrentLocation
		if (! $Text) {
			Get-WUReg -toLocation $CurrentLocation
			Check-Connection2WSUS -toLocation $CurrentLocation -TestFromReg
			Get-SysInfo -toLocation $CurrentLocation
			Get-WUHistory -toLocation $CurrentLocation
			Get-RebootHistory -toLocation $CurrentLocation
			Get-ServicesInfo -toLocation $CurrentLocation
			Get-HotFixes -toLocation $CurrentLocation
		} else {
			Get-WUReg -toLocation $CurrentLocation -Text
			Check-Connection2WSUS -toLocation $CurrentLocation -TestFromReg -Text
			Get-SysInfo -toLocation $CurrentLocation -Text
			Get-WUHistory -toLocation $CurrentLocation -Text
			Get-RebootHistory -toLocation $CurrentLocation -Text
			Get-ServicesInfo -toLocation $CurrentLocation -Text
			Get-HotFixes -toLocation $CurrentLocation -Text
		}
	}
	
	if ($SMSAgent) {
		Get-ClientInstallLogs -toLocation $CurrentLocation
		Get-CCMLogs -toLocation $CurrentLocation
		if (! $Text) {
			Get-ClientRegInfo -toLocation $CurrentLocation
			Get-ClientMyCertInfo -toLocation $CurrentLocation
			Get-MPInfo -toLocation $CurrentLocation
			Get-TRKey -toLocation $CurrentLocation
			Get-BGInfo -toLocation $CurrentLocation
			Get-BGBConfig -toLocation $CurrentLocation
			Get-ClientSettings -toLocation $CurrentLocation
			Get-PendingRebootInfo -toLocation $CurrentLocation
			Get-SUPInfo -toLocation $CurrentLocation
			Get-ServiceWindowInfo -toLocation $CurrentLocation
			Get-UpdateCIAssignment -toLocation $CurrentLocation
			Get-Deployments -toLocation $CurrentLocation
			Get-ContentCacheInfo -toLocation $CurrentLocation
			Profile-SoftwareCenter -toLocation $CurrentLocation
			Profile-SCCMClient -toLocation $CurrentLocation
		} else {
			Get-ClientRegInfo -toLocation $CurrentLocation -Text
			Get-ClientMyCertInfo -toLocation $CurrentLocation -Text
			Get-MPInfo -toLocation $CurrentLocation -Text
			Get-TRKey -toLocation $CurrentLocation
			Get-SUPInfo -toLocation $CurrentLocation -Text
			Get-ServiceWindowInfo -toLocation $CurrentLocation -Text
			Get-BGInfo -toLocation $CurrentLocation -Text
			Get-ClientSettings -toLocation $CurrentLocation -Text
			Get-BGBConfig -toLocation $CurrentLocation -Text
			Get-PendingRebootInfo -toLocation $CurrentLocation -Text
			Get-UpdateCIAssignment -toLocation $CurrentLocation -Text
			Get-Deployments -toLocation $CurrentLocation -Text
			Get-ContentCacheInfo -toLocation $CurrentLocation -Text
			Profile-SoftwareCenter -toLocation $CurrentLocation -Text
			Profile-SCCMClient -toLocation $CurrentLocation -Text
		}
	}
	
	if ($StateMsg) {
		if (! $Text) {
			Get-StateMsgInfo -toLocation $CurrentLocation
		} else {
			Get-StateMsgInfo -toLocation $CurrentLocation -Text
		}
	}
	
	if ($UpdateStore) {
		if (! $Text) {
			Query-UpdateStore -toLocation $CurrentLocation
		} else {
			Query-UpdateStore -toLocation $CurrentLocation -Text
		}
	}
	
	if ($WinOSUpgrade) {
			Get-WinOSUpgradeLogs -toLocation $CurrentLocation
	}

	if ($BitsJobs) {
		if (! $Text) {
			Get-BitsInfo -toLocation $CurrentLocation
		} else {
			Get-BitsInfo -toLocation $CurrentLocation -Text
		}
	}
	
	if ($Security) {
		if (! $Text) {
			Get-FirewallRules -toLocation $CurrentLocation
		} else {
			Get-FirewallRules -toLocation $CurrentLocation -Text
		}
	}
}

# ------------------------------------------------------ Client-Info.ps1 ------------------------------------------------------ #


# ------------------------------------------------------ ConfigMgr-RT.ps1 ------------------------------------------------------ #

# Client Settings options menu
$CLSetOptions = @{
	bits    = @{id = "bits";  name = "Background Intelligent Transfer service"; desc = "Background Intelligent Transfer service"; loc = "ROOT\ccm\Policy\Machine\ActualConfig:CCM_Service_BITS2Configuration"}
	cache   = @{id = "cache"; name = "Client Cache";                            desc = "Client Cache";                            loc = "ROOT\ccm\Policy\Machine\ActualConfig:CCM_SuperPeerClientConfig"}
	cloud   = @{id = "cloud"; name = "Cloud Services";                          desc = "Cloud Services";                          loc = "ROOT\ccm\Policy\Machine\ActualConfig:CCM_CloudClientConfig"}
	agent   = @{id = "agent"; name = "Computer Agent";                          desc = "Computer Agent";                          loc = "ROOT\ccm\Policy\Machine\ActualConfig:CCM_ClientAgentConfig"}
	rest    = @{id = "rest";  name = "Computer Restart";                        desc = "Computer Restart";                        loc = "ROOT\ccm\Policy\Machine\ActualConfig:CCM_RebootSettings"}
	dopt    = @{id = "dopt";  name = "Delivery Optimization";                   desc = "Delivery Optimization";                   loc = "ROOT\CCM\Policy\Machine\ActualConfig:CCM_WindowsDOClientConfig"}
	endpt   = @{id = "endpt"; name = "Endpoint Protection";                     desc = "Endpoint Protection";                     loc = "ROOT\ccm\Policy\Machine\ActualConfig:CCM_EndpointProtectionClientConfig"}
	hiv     = @{id = "hiv";   name = "Hardware Inventory";                      desc = "Hardware Inventory";                      loc = "ROOT\ccm\Policy\Machine\ActualConfig:CCM_HardwareInventoryClientConfig"}
	mnet    = @{id = "mnet";  name = "Metered Network";                         desc = "Metered Network";                         loc = "ROOT\ccm\Policy\Machine\ActualConfig:CCM_NetworkSettings"}
	softc   = @{id = "softc"; name = "Software Center";                         desc = "Software Center";                         loc = "ROOT\ccm\Policy\Machine\ActualConfig:CCM_SoftwareCenterClientConfig"}
	upd     = @{id = "upd";   name = "Software Updates";                        desc = "Software Updates";                        loc = "ROOT\ccm\Policy\Machine\ActualConfig:CCM_SoftwareUpdatesClientConfig"}
	usrda   = @{id = "usrda"; name = "User and Device Affinity";                desc = "User and Device Affinity";                loc = "ROOT\CCM\Policy\Machine\ActualConfig:CCM_TargetingSettings"}
}

# Client actions hash table and other actions menu, eg. reset policy, resend state messages, etc.
$CLActions = @{
	hiv = @{id = "hiv"; actionid = "{00000000-0000-0000-0000-000000000001}"; name = "Hardware Inventory Cycle"}
	hfu = @{id = "hfu"; actionid = "{00000000-0000-0000-0000-000000000hfu}"; name = "Full Hardware Inventory Cycle"}
	siv = @{id = "siv"; actionid = "{00000000-0000-0000-0000-000000000002}"; name = "Software Inventory Cycle"}
	ddr = @{id = "ddr"; actionid = "{00000000-0000-0000-0000-000000000003}"; name = "Discovery Data Collection Cycle"}
	ade = @{id = "ade"; actionid = "{00000000-0000-0000-0000-000000000121}"; name = "Application Deployment Evaluation Cycle"}
	mpr = @{id = "mpr"; actionid = "{00000000-0000-0000-0000-000000000021}"; name = "Machine Policy Assignments Request"} # mpL
	mpe = @{id = "mpe"; actionid = "{00000000-0000-0000-0000-000000000022}"; name = "Machine Policy Evaluation"} # mpL
	mpL = @{id = "mpL"; actionid = "{00000000-0000-0000-0000-000000000mpL}"; name = "Machine Policy Retrieval & Evaluation"} # mpL = mpr + mpe
	#urr = @{id = "urr"; actionid = "{00000000-0000-0000-0000-000000000026}"; name = "User Policy Assignments Request"} # urr
	#ure = @{id = "ure"; actionid = "{00000000-0000-0000-0000-000000000027}"; name = "User Policy Evaluation"} # ure
	#usr = @{id = "usr"; actionid = "{00000000-0000-0000-0000-000000000usr}"; name = "User Policy Retrieval & Evaluation"} # usr = mpr + mpe
	sde = @{id = "sde"; actionid = "{00000000-0000-0000-0000-000000000108}"; name = "Software Updates Deployment Evaluation Cycle"}
	ups = @{id = "ups"; actionid = "{00000000-0000-0000-0000-000000000113}"; name = "Software Updates Scan cycle"}
	# Invoke-WMIMethod -Namespace root\ccm -Class SMS_Client -Name ResetPolicy -ArgumentList "1" -Computername "<Computer-Name>"
	# WMIC /Namespace:\\root\ccm path SMS_Client CALL ResetPolicy 1 /NOINTERACTIVE
	rst = @{id = "rst"; actionid = "{00000000-0000-0000-0000-000000000rst}"; name = "Reset Client Policy"} # Faked actionid
	# (New-Object -ComObject Microsoft.CCM.UpdatesStore).RefreshServerComplianceState()
	rfr = @{id = "rfr"; actionid = "{00000000-0000-0000-0000-000000000rfr}"; name = "Refresh Compliance State"} # Faked actionid
	rma = @{id = "rma"; actionid = "{00000000-0000-0000-0000-000000000rma}"; name = "Uninstall Configuration Manager Client"} # Faked actionid
	rmj = @{id = "rmj"; actionid = "{00000000-0000-0000-0000-000000000rmj}"; name = "Remove stuck jobs"} # Faked actionid
	rsw = @{id = "rsw"; actionid = "{00000000-0000-0000-0000-000000000rsw}"; name = "Reset Windows Update Component"} # Faked actionid
}

# ConfigMgr Client UI menu
$ConfigMgrUI = @{
	gen     = @{id = "gen";      name = "Show General tab information"}
	act     = @{id = "act";      name = "Show Actions tab information"}
	comp    = @{id = "comp";     name = "Show Components tab information"}
	site    = @{id = "site";     name = "Show Site tab information"}
	net     = @{id = "net";      name = "Show Network tab information"}
	che     = @{id = "che";      name = "Show Cache tab information"}
	cfg     = @{id = "cfg";      name = "Show Configurations tab information"}
	cache   = @{id = "cache";    name = "Manage content cache"}
}

# Main menu of Welcome interface
$MainMenu = @{
	ip    = @{id = "ip";    name = "Display device IP"}
	dns   = @{id = "dns";   name = "Display device dns information"}
	cmreg = @{id = "cmreg"; name = "Display SMS Agent registry"}
	cache = @{id = "cache"; name = "Manage SMS Agent content cache"}
	agent = @{id = "agent"; name = "Display SMS Agent client UI information"}
	O365  = @{id = "O365";  name = "Display Office 365 App registry"}
	wsus  = @{id = "wsus";  name = "Display WSUS configuration"}
	bgb   = @{id = "bgb";   name = "Display BGB status"}
	app   = @{id = "app";   name = "List deployed applications"}
	upd   = @{id = "upd";   name = "List deployed updates"}
	pkgts = @{id = "pkgts"; name = "List deployed packages/task sequences"}
	dpL   = @{id = "dpL";   name = "List applications/updates deployments"}
	trgac = @{id = "trgac"; name = "Trigger CCM actions and some other operations"}
	stmsg = @{id = "stmsg"; name = "Search for state messages"}
	updst = @{id = "updst"; name = "Serach for updates store"}
	bgrp  = @{id = "bgrp";  name = "Display boundary groups"}
	updhs = @{id = "updhs"; name = "Display windows updates history" }
	svwin = @{id = "svwin"; name = "Display service windows" }
	sup   = @{id = "sup";   name = "Display software update points" }
	trk   = @{id = "trk";   name = "Dispaly trusted root key" }
	cert  = @{id ="cert";   name = "Display certificats" }
	mp    = @{id = "mp";    name = "Display management points" }
	vlog  = @{id = "vlog";  name = "Enable/disable CCM verbose logging" }
	nettr = @{id = "nettr"; name = "Capture network trace" }
	cLset = @{id = "cLset"; name = "Display client settings"}
	rbhis = @{id = "rbhis"; name = "Display reboot history" }
	wulog = @{id = "wulog"; name = "Enable/Disable Windows Update verbose logging" }
	CAPi2 = @{id = "CAPi2"; name = "Enable/Disable CAPI2 event log" }
}

# ------------------------------------------------------ Constant Variables ------------------------------------------------------ #

# Print menu
Function Print-Menu ($Menu, $Title, $IDWidth=6, $NameWidth=50, $FgColr="White", $BgColr="Darkyellow") {
	Write-Output "${Title}:"
	$Count = 1
	foreach ($MItemKey in ($Menu.Keys | Sort-Object)) {
		$FmtStrID = " {0,-$IDWidth}" # The "-$IDWidth" tells the formatter to left-align in a $IDWidth character field
		$ItemID = $FmtStrID -f $Menu[$MItemKey]['id']
		$FmtStrName = " : {0,-$NameWidth}"   # The "-$NameWidth" tells the formatter to left-align in a $NameWidth character field
		$ItemDesc = $FmtStrName -f $Menu[$MItemKey]['name']
		
		Write-Host $ItemID -ForegroundColor $FgColr -BackgroundColor $BgColr -NoNewline; Write-Host $ItemDesc -NoNewline
		if ($Count % 2 -eq 0) { Write-Host "" }
		$Count += 1
	}
	Write-Host ""
}

##################################################
# Capture network trace with netsh trace 
##################################################
Function Capture-NetworkTrace {
	[CmdletBinding(DefaultParameterSetName = 'Common')]
	Param(
		[Parameter(Mandatory = $false, ParameterSetName = 'Common')][String] $toLocation = (Get-Location),
		[Parameter(Mandatory = $false, ParameterSetName = 'Common')][String] $NetshFileName = "netsh-" + $(Get-Date -Format 'yyyy-MM-dd-HH-mm-ss') + ".etl",
		[Parameter(Mandatory = $false, ParameterSetName = 'Stop')][Switch] $Stop # to step capture
	)
	$ChildDir = "General"
	$_LOG_DIR = "$toLocation\$ChildDir"
	$_NET_LOG_DIR = "$_LOG_DIR\Network"
	if ($Stop) { # if stop switch, stop netsh trace and exit the function.
		# *** NETSH CAPTURE STOP ***
		Write-Verbose "`nStopping Network Trace and merging`nThis may take some time depending on the size of the network capture, please wait....`n"
		Start-Process PowerShell -ArgumentList "netsh trace stop ; Read-Host 'Press Enter to exit'"
		break
	}
	
	#if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	# Create subdirectory
	if (! (Test-Path "$_NET_LOG_DIR")) {New-Item -Path $_NET_LOG_DIR -ItemType Directory | Out-Null}
	
	# Get OS info
	$wmiOSObject = Get-WmiObject -class Win32_OperatingSystem
	$OSVersionString = $wmiOSObject.Version
	
	# Start Net Trace
	Write-Verbose "`nStarting Network Trace...`nThis may take some time depending on the performance of the computer, please wait....`n"
	switch -regex ($OSVersionString) {
		# Win7 has different args syntax.
		'^6\.1' { Start-Process PowerShell -ArgumentList "netsh trace start persistent=yes traceFile=$_NET_LOG_DIR\$NetshFileName capture=yes report=no maxsize=2048 ; Read-Host 'Press Enter to exit'" }
		default { Start-Process PowerShell -ArgumentList "netsh trace start persistent=yes traceFile=$_NET_LOG_DIR\$NetshFileName capture=yes report=disabled maxsize=2048 ; Read-Host 'Press Enter to exit'" }
	}
}

#######################################################
# Format string width
# https://ss64.com/ps/syntax-f-operator.html
#######################################################
Function Format-Width ($Str, $Width) {
	$StrFmt = " {0:d$Width}" # The "$Width" tells the formatter to right/left(minus -$Width)-align in a $Width character field
	$OutStr = $StrFmt -f $Str
	Return $OutStr
}

##################################################
# Print indicative msg for a cmd or operation
# Print delimiter line based on $Delim
##################################################
Function Print-CmdMessage($Msg,$Delim=0, $FgColr="White", $BgColr) { 
	$OutMsg = "@ Info: $Msg"
	if ($BgColr) { Write-Host $OutMsg -ForegroundColor $FgColr -BackgroundColor $BgColr } else { Write-Host $OutMsg -ForegroundColor $FgColr }
	$Width = $OutMsg.Length
	if ($Delim) { 1..$Width | foreach{ Write-Host "=" -NoNewline }; Write-Host "" }
}

#################################################################
# Print warning message in case of errors or dangerous operations
#################################################################
Function Print-WarningMessage($Msg) { Write-Host "! Warning: $Msg" -BackgroundColor Red -ForegroundColor White }

####################################################################
# Print leading symbol before Read-Host prompt message
# eg. >> is the leading symbol in >>[Yes to confirm; No to cancel: ]
####################################################################
Function Print-LeadingSymbol($Sym) { Write-Host $Sym -ForegroundColor "White" -BackgroundColor "Darkgreen" -NoNewline }

###################################################################################
# Print section header message for agent, cache, update, application sections, etc.
# eg. ++++++++- SMS Agent Registry -++++++++
###################################################################################
Function Print-SectionHeader($Msg) {
	$OutMsg = "[++++++++++++++++++++++++- $Msg -++++++++++++++++++++++++]"
	$Width = $OutMsg.length
	Write-Host $OutMsg -ForegroundColor "Green" -BackgroundColor "Black"
	1..$Width | foreach{ Write-Host "." -ForegroundColor "Green" -NoNewline }; Write-Host "" 
}

###################################################################################
# Print overall information about a section, eg. total applications, updates, etc.
# eg. You have 88 applications:
###################################################################################
Function Print-Overview($Msg) {
	$OutMsg = "@<<Overview>> $Msg"
	Write-Host $OutMsg #-ForegroundColor "Black" -BackgroundColor "White"
}

############################
# Print subsection header
# eg.
# << Cache Configuration >>
# ==========================
############################
Function Print-SubSectionHeader($Msg) {
	$OutMsg = "`n<< $Msg >>"
    Write-Host $OutMsg
	$Width = $OutMsg.length
	1..$Width | foreach{Write-Host "=" -NoNewline}
	Write-Host ""
}

##############################################################################################################################################################
# Fetch Trusted Root Key
# Locations:
## On site server, MP, DP: Computer\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\SMS\Security: TrustedRootKey
## On the client WMI: ROOT\ccm\LocationServices:TrustedRootKey
## On site server: C:\Program Files\Microsoft Configuration Manager\bin\i386\mobileclient.tcf
# https://docs.microsoft.com/en-us/mem/configmgr/core/plan-design/security/configure-security#pre-provision-a-client-with-the-trusted-root-key-by-using-a-file
###############################################################################################################################################################
Function Query-TRKey {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location)
	)
	
	# Section header
	Print-SectionHeader("Trusted Root Key")
	
	Print-SubSectionHeader("ROOT\ccm\LocationServices:TrustedRootKey")
	$TRKeyInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\LocationServices" -Class TrustedRootKey
	
	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"; if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }
	
	# Export MP signing certificate
	$FileName = "MPSignCert-TRK-" + $TRKeyInfo.MPName
	$CertName = "MPSigningCertificate-TRK-" + $TRKeyInfo.MPName
	$MPSignCertPath = $(Decode-Cert -InputHex $TRKeyInfo.MPCertificate -InputFileName "$FileName.txt" -OutputFileName "$CertName.cer") 
	$TRKeyInfo = $TRKeyInfo| Select-Object MPName, SiteCode, Reserved1, Reserved2, TrustedRootKey, VirtualMP, MPCertificate, @{Name="(SigningCertificate Path)";Expression={$MPSignCertPath}}
	$TRKeyInfo
}

###################################################################################################################################
# Fetch Management Point information
## That SMS_MPInformation and SMS_MPList are populated does not guarantee SMS Agent can work properly
## SMS_MPInformationEx and SMS_MPListEx must be populated for SMS Agent to work properly
## https://sccmpeek.wordpress.com/2022/04/28/sccm-agent-has-only-two-actions-after-installation-with-ccmverifymsgsignature-failed/
###################################################################################################################################
Function Query-MPInfo {
	Param( 
		[Parameter(Mandatory = $false)][String] $toLocation = (Get-Location)
	)
	# Overview goes here - Start
	# Section header
	Print-SectionHeader("Management Point")

	# Subdirectory to hold the result file(s)
	$ChildDir = "SMSAgent"
	if (! (Test-Path "${toLocation}\${ChildDir}")) { New-Item -ItemType "Directory" "${toLocation}\${ChildDir}" | Out-Null }

	# SMS_MPInformationEx
	## Get Management Point Ex information: SMS_MPInformationEx
	Print-SubSectionHeader("ROOT\ccm\LocationServices: SMS_MPInformationEx")
	$MPEx = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\LocationServices" -Class SMS_MPInformationEx	
	$MPEx = $MPEx | Select-Object MP, SiteCode, IsProxy, MPLastRequestTime, MPLastUpdateTime, Reserved1, @{Name="Capabilities";Expression={Format-XML($_.Reserved2)}}, @{Name="Thumbprint1 (MP Signing Cert)";Expression={$_.Thumbprint1}}, @{Name="(MP Signing Certificate)";Expression={if ($_.Thumbprint1) {$FileName = "SMSSigningCertificate-" + $_.MP;	$SMSSignCertPath = $(Decode-Cert -toLocation $toLocation -InputHex $_.Thumbprint1 -InputFileName "$FileName.txt" -OutputFileName "$FileName.cer"); $SMSSignCertPath}}}, @{Name="Thumbprint2 (MP Encryption Cert)";Expression={$_.Thumbprint2}}, @{Name="(MP Encryption Certificate)";Expression={if ($_.Thumbprint2) {$FileName = "SMSEncryptionCertificate-" + $_.MP; $SMSEncryptCertPath = $(Decode-Cert -toLocation $toLocation -InputHex $_.Thumbprint2 -InputFileName "$FileName.txt" -OutputFileName "$FileName.cer");$SMSEncryptCertPath}}}
	$MPExCount = ($MPEx | Measure-Object | Select-Object).Count

	# Overview of SMS_MPInformationEx
	Print-Overview("You have $MPExCount management points (only the first 10 results will be listed. To display all results, enter mpe.):")
	$Idx = 1; $MPEx | Select-Object -First 10 | foreach {$MPName = $_.MP; $SiteCode = $_.SiteCode; $IsProxy = $_.IsProxy; $Index = Format-Width -Str ${Idx} -Width "${MPExCount}".length; Write-Output "${Index}: MP: $MPName SiteCode: $SiteCode IsProxy: $IsProxy"; $Idx = $Idx + 1 }

	# SMS_ActiveMPCandidate
	## Get all available active Management Point(s)
	Print-SubSectionHeader("ROOT\ccm\LocationServices: SMS_ActiveMPCandidate")
	$ActiveMPInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\LocationServices" -Class SMS_ActiveMPCandidate | Select-Object MP, Type, Locality, Version, SiteCode, State, Protocol, MPFallbackTime, MasterSiteCode, Index, @{Name="Capabilities";Expression={$_.Capabilities}}, MPBGRFallbackType, Reserved1, Reserved2
	$ActiveMPInfoCount = ($ActiveMPInfo | Measure-Object | Select-Object).Count

	# Overview of SMS_ActiveMPCandidate
	Print-Overview("You have $ActiveMPInfoCount active management points (only the first 10 results will be listed. To display all results, enter mpa.):")
	$Idx = 1; $ActiveMPInfo | Select-Object -First 10 | foreach {$MPName = $_.MP; $Type = $_.Type; $Version = $_.Version; $Pos = $_.Index; $Index = Format-Width -Str ${Idx} -Width "${ActiveMPInfoCount}".length; Write-Output "${Index}: MP: $MPName SiteCode: $SiteCode IsProxy: $IsProxy"; $Idx = $Idx + 1 }
	# Overview goes here - End
	
	While ($True){
		Print-LeadingSymbol(">>[Managent Points]")
		$Condition = Read-Host -Prompt "[Enter input (mpe:List MPEx; mpa:List active MP; others for search; Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		if ($Condition) {
			switch ($Condition) {
				"mpe" { # List all MPEx
					$Answer = Read-Host -Prompt "[Display ALL $MPExCount MPEx? Yes to confirm; No to cancel > ]"
					if ($Answer -ne "Yes") { "Cancelled displaying all $MPExCount MPEx.";Continue }
					Print-CmdMessage("Displaying MPEx ($MPExCount) >>") -Delim 1
					$Idx = 1; $MPEx | foreach {$MPName = $_.MP; $SiteCode = $_.SiteCode; $IsProxy = $_.IsProxy; $Index = Format-Width -Str ${Idx} -Width "${MPExCount}".length; Write-Output "${Index}: MP: $MPName SiteCode: $SiteCode IsProxy: $IsProxy"; $Idx = $Idx + 1 }
					Print-CmdMessage("Displayed MPEx ($MPExCount) <<") 
				}
				"mpa" { # List all active MP canditates
					$Answer = Read-Host -Prompt "[Display ALL $ActiveMPInfoCount active MP canditates? Yes to confirm; No to cancel > ]"
					if ($Answer -ne "Yes") { "Cancelled displaying all $ActiveMPInfoCount active MP canditates.";Continue }
					Print-CmdMessage("Displaying active MP canditates ($ActiveMPInfoCount) >>") -Delim 1
					$Idx = 1; $ActiveMPInfo | foreach {$MPName = $_.MP; $Type = $_.Type; $Version = $_.Version; $Pos = $_.Index; $Index = Format-Width -Str ${Idx} -Width "${ActiveMPInfoCount}".length; Write-Output "${Index}: MP: $MPName SiteCode: $SiteCode IsProxy: $IsProxy"; $Idx = $Idx + 1 }
					Print-CmdMessage("Displayed active MP canditates ($ActiveMPInfoCount) <<") 
				}
				"trk" { Query-TRKey }
				"opendestdir" { Invoke-Item -ErrorAction SilentlyContinue . }
				Default {
					# Search for MP based on $Condition. If $Condition is ?  all results will be returned.
					$MP = @{MPEx = $MPEx; ActiveMP = $ActiveMPInfo}
					foreach ($Key in $MP.Keys) {
						$QueriedMP = $MP[$Key] | Where-Object { $_.MP -like "*$Condition*" }
						$QueriedMPCount = ($QueriedMP | Measure-Object | Select-Object).Count
						Print-CmdMessage("$Key > Found $QueriedMPCount result >>") -Delim 1
						$Index = 1; $QueriedMP | foreach { Print-CmdMessage("< Result $Index > "); $_; $Index += 1 }
						Print-CmdMessage("$Key > Found $QueriedMPCount result <<")
						Write-Host "`n"
					}
				}
			}
		}
	}

}

# Print ConfigMgr Client UI menu
Function Print-ConfigMgrUIMenu {
	Print-Menu -Menu $ConfigMgrUI -Title "Options" -BgColr "Blue"
	Write-Host "`n@ Note: You can also enter Baseline Name or ID to search for baselines."
}

##################################################
# Pritn SMS Agent information (Profiling UI)
##################################################
Function Print-ConfigMgrClient {
	# Start: CCM Agent UI
	Print-SectionHeader("SMS Agent")

	# Get Configuration Manager client information in all tabs
	$SMSClient = New-Object -ComObject "Microsoft.SMS.Client"
	$CCMRegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\CCM'
	$CCMSecurityRegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\CCM\Security'
	$CCMClient = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm" -Class "CCM_Client"
	$SMS_Client = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm" -Class "SMS_Client"
	$ConfigMgrNetwork = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm" -Class "CCM_NetworkProxy" | Select-Object -First 1 -Property Account, Protocol, ProxyBypassList, ProxyList, ReservedString1
		
	# ====== 1. General tab ======
	# 1.1 Assigned management point: to add
	$IsSiteAutoAssignEnabled = $SMS_Client.EnableAutoAssignment
	$CurrentMP = $SMSClient.GetCurrentManagementPoint() # Current management point
	# 1.2. Client certificate:
	$IsClientCertReady = $CCMRegInfo.PKICertReady
	$ClientCert = $Null
	if ($IsClientCertReady) {$ClientCert = "PKI"} else {$ClientCert = "Self-signed"}
	# 1.3. CoManagement capabilities: and 1.4. CoManagement:
	$CoMgmt = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\InvAgt" -Class "CCM_System"
	$IsCoMgmt = $CoMgmt.CoManaged
	$ComgmtWorkloads = $CoMgmt.ComgmtWorkloads
	$ClientDomain = $CoMgmt.Domain
	$LocalDateTime = $CoMgmt.LocalDateTime
	$SystemRole = $CoMgmt.SystemRole
	$SystemType = $CoMgmt.SystemType
	# 1.5. Connection Type:
	$IsOnInet = $SMSClient.IsClientOnInternet() # Whether the client is on internet
	$ClientAlwaysOnInet = $CCMSecurityRegInfo.ClientAlwaysOnInternet # Whether the client is ALWAYS on internet
	$ConnectionType = $Null
	if ($IsOnInet -and $ClientAlwaysOnInet) {
		$ConnectionType = "Always Internet"
	} elseif ($IsOnInet) {
		$ConnectionType = "Currently Internet"
	} else {
		$ConnectionType = "Currently Intranet"
	}
	# 1.6. Site Code:
	$SiteCode = $SMSClient.GetAssignedSite() # Site Code
	# 1.7. Unique Identifier:
	$ClientGUID = $CCMClient.ClientId # Client GUID
	$ClientGUIDChgDate = $CCMClient.ClientIdChangeDate # GMT time
	$ClientGUIDPre = $CCMClient.PreviousClientId # Previous Client GUID
	# 1.8. Version:
	$ClientVersion = Get-ClientVersion -Ver $SMS_Client.ClientVersion
	$ClientType = $SMS_Client.ClientType

	$PropsGeneral = @{
		"Current management point" = "${CurrentMP}"
		"Client certificate" = "${ClientCert}"
		"Co-management capabilities" = "${ComgmtWorkloads}"
		"Co-management" = "${IsCoMgmt}"
		"Domain" = "${ClientDomain}"
		"Local Date Time" = "${LocalDateTime}"
		"System role" = "${SystemRole}"
		"Connection Type" = "${ConnectionType}"
		"Site code" = "${SiteCode}"
		"Unique identifier" = "${ClientGUID}"
		"Uniduq identifier change date (GMT)" = "${ClientGUIDChgDate}"
		"Previous unique identifier" = "${ClientGUIDPre}"
		"Version" = "${ClientVersion}"
		"Client Type" = "${ClientType}"
	}

	$ConfigMgrGeneral = (New-Object PSObject -Property $PropsGeneral)
	$ConfigMgrGeneral = $ConfigMgrGeneral | Select-Object -Property "Current management point", "Client certificate", "Co-management capabilities", "Co-management", "Domain", "Local Date Time", "System role", "Connection Type", "Site code", "Unique identifier", "Uniduq identifier change date (GMT)", "Previous unique identifier", "Version", "Client Type"

	# ====== 2. Components tab ======
	$ConfigMgrComponents = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm" -Class "CCM_InstalledComponent" | Select-Object -Property DisplayName, Name, Version
	$ComponentsCount = ($ConfigMgrComponents | Measure-Object | Select-Object).Count

	# ====== 3. Site tab ======
	# $SiteCode = $SMSClient.GetAssignedSite() # Site Code
	$DNSSuffix = $SMSClient.GetDnsSuffix()
	$PropsSite = @{
		"Currently assigned to site code" = "${SiteCode}"
		"DNS suffix" = "${DNSSuffix}"
	}

	$ConfigMgrSite = (New-Object PSObject -Property $PropsSite)

	# ====== 4. Actions tab ======
	$ConfigMgrActions = Get-WmiObject -ErrorAction SilentlyContinue -ComputerName localhost -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Query "SELECT * FROM CCM_ClientActions" | Select-Object -Property Name, ActionID, DisplayNameResFilename, DisplayNameResID, Endpoint
	$ActionsCount = ($ConfigMgrActions | Measure-Object | Select-Object).Count

	# ====== 5. Network tab ======
	$InetMP = $SMSClient.GetInternetManagementPointFQDN() # Internet management point if any
	$ProxyServer = $ConfigMgrNetwork.ProxyList
	$ProxyBypassList = $ConfigMgrNetwork.ProxyBypassList
	$ProxyAccount = $ConfigMgrNetwork.Account

	$PropsNetwork = @{
		"Internet-based management point (FQDN)" = "${InetMP}"
		"Proxy server" = "${ProxyServer}"
		"ProxyBypassList" = "${ProxyBypassList}"
		"Proxy Account" = "${ProxyAccount}"
	}

	$ConfigMgrNetwork = (New-Object PSObject -Property $PropsNetwork)

	# ====== 6. Cache tab ======
	#$CacheLocation = $ConfigMgrCache.Location
	#$CacheSize = $ConfigMgrCache.MaxCacheSizeMB
	$ConfigMgrCache = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\SoftMgmtAgent:CacheConfig" -Class CacheConfig | Select-Object -Property Location, @{Name="MaxCacheSizeMB";Expression={$_.Size}}

	# ====== 7. Configuration tab ======
	$ConfigMgrConfig = Get-WmiObject -ErrorAction SilentlyContinue -ComputerName localhost -Namespace "ROOT\ccm\dcm" -Class SMS_DesiredConfiguration | Select-Object -Property DisplayName, Name, Version, @{Name="Compliance Details";Expression={Format-XML($_.ComplianceDetails)}}, LastComplianceStatus, @{Name="LastEvalTime";Expression={($_.LastEvalTime.SubString(0,4), $_.LastEvalTime.SubString(4,2),$_.LastEvalTime.SubString(6,2), $_.LastEvalTime.SubString(8,2), $_.LastEvalTime.SubString(10,2), $_.LastEvalTime.SubString(12,2)) -join "-"}}, Status
	$ConfigMgrConfigCount = ($ConfigMgrConfig | Measure-Object | Select-Object).Count

	# Print CCM Agent UI information
	Print-SubSectionHeader("1. General"); $ConfigMgrGeneral #| Format-List
	Print-SubSectionHeader("2. Components ($ComponentsCount)"); $ConfigMgrComponents #| Format-Table -AutoSize
	Print-SubSectionHeader("3. Site"); $ConfigMgrSite #| Format-List
	Print-SubSectionHeader("4. Actions ($ActionsCount)"); $ConfigMgrActions #| Format-Table -AutoSize
	Print-SubSectionHeader("5. Network"); $ConfigMgrNetwork #| Format-List
	Print-SubSectionHeader("6. Cache"); $ConfigMgrCache #| Format-List
	Print-SubSectionHeader("7. Configurations ($ConfigMgrConfigCount)")
	Print-CmdMessage("Only the first 10 will be displayed. To show all results, enter config.")
	$Idx = 1; $ConfigMgrConfig | Select-Object -First 10 | foreach {$ConfigID = $_.Name; $DispName = $_.DisplayName; $LastCompStatus = $_.LastComplianceStatus; $Index = Format-Width -Str ${Idx} -Width "${ConfigMgrConfigCount}".length; Write-Output "${Index}: ID: $ConfigID Name: $DispName LastComplianceStatus: $LastCompStatus"; $Idx = $Idx + 1 }
	# End: CCM Agent UI
	
	# Here goes the search 
	While ($True) {
		Print-LeadingSymbol(">>[ConfigMgr Client UI]"); $Option = Read-Host -Prompt "[Enter your option (?: Show options; Q:exit) > ]" 
		$Option = $Option.Trim()
		if ($Option -eq "?") { Print-ConfigMgrUIMenu -Menu $ConfigMgrUI -Title "Options" -BgColr "Blue"; Continue }
		if ($Option -eq "Q") { break }
		if ($Option) {
			switch ($Option) {
				"gen"    {Print-SubSectionHeader("General"); $ConfigMgrGeneral}
				"act"    {Print-SubSectionHeader("Actions"); $ConfigMgrActions}
				"comp"   {Print-SubSectionHeader("Components"); $ConfigMgrComponents}
				"site"   {Print-SubSectionHeader("Site"); $ConfigMgrSite}
				"net"    {Print-SubSectionHeader("Network"); $ConfigMgrNetwork}
				"che"    {Print-SubSectionHeader("Cache"); $ConfigMgrCache}
				"cache"    {Query-ContentCache}
				"cfg"    {Print-SubSectionHeader("Configurations"); $Idx = 1; $ConfigMgrConfig | foreach {$ConfigID = $_.Name; $DispName = $_.DisplayName; $LastCompStatus = $_.LastComplianceStatus; $Index = Format-Width -Str ${Idx} -Width "${ConfigMgrConfigCount}".length; Write-Output "${Index}: ID: $ConfigID Name: $DispName LastComplianceStatus: $LastCompStatus"; $Idx = $Idx + 1 }}
				Default  {
						$ResFound = $ConfigMgrConfig | Where-Object { ($_.DisplayName -like "*$Option*") -or ($_.Name -like "*$Option*")}
						$ResCount = ($ResFound | Measure-Object | Select-Object).Count
						Print-CmdMessage("Found $ResCount result >>") -Delim 1
						$Index = 1; $ResFound | foreach { Print-CmdMessage("< Result $Index > "); $_; $Index += 1 }
						Print-CmdMessage("Found $ResCount result <<")
				}
			}
		}
	}
}

##################################################
# Print SMS Agent registry
##################################################
Function Print-CCMReg {
	# CCM Registry
	Print-SectionHeader("SMS Agent Registry")
	
	Print-SubSectionHeader("HKLM\SOFTWARE\Microsoft\CCM")
	$CCM = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\CCM'
	$CCM
	
	Print-SubSectionHeader("HKLM\SOFTWARE\Microsoft\CCM\Security")
	$CCMSec = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\CCM\Security'
	if ($CCMSec.SigningCertificate) {
		$FileName = "SiteServerSigningCertificate"
		$SiteSignCertPath = $(Decode-Cert -InputHex $CCMSec.SigningCertificate -InputFileName "$FileName.txt" -OutputFileName "$FileName.cer")
	}
	$CCMSec | Select-Object "Certificate Store", "Certificate Issuers", "Certificate Selection Criteria", "Select First Certificate", "PKICertOptions", "ClientAlwaysOnInternet", "Hash Algorithm", "Hash Algorithm Id", "Encryption Algorithm", "Encryption Algorithm Id", @{Name="SigningCertificate (Site Server Signing Certificate)";Expression={$_.SigningCertificate}}, @{Name="(Site Server Signing Certificate)";Expression={$SiteSignCertPath}}, PSPath
	
	Print-SubSectionHeader("HKLM\Software\Microsoft\SMS\Client\Internet Facing")
	$CCMInetFacingRegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\Software\Microsoft\SMS\Client\Internet Facing'
	$CCMInetFacingRegInfo
	
	Print-SubSectionHeader("HKLM\SOFTWARE\Microsoft\SMS\Mobile Client")
	$SMSMCRegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\SMS\Mobile Client'
	$SMSMCRegInfo
	
	Print-SubSectionHeader("HKLM\SOFTWARE\Microsoft\CCMSetup")
	$CCMSetupInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\CCMSetup'
	$CCMSetupInfo
}

Function Print-O365 {
	Print-SectionHeader("Office 365 App Registry")
	Print-SubSectionHeader("HKCR\CLSID\{B7F1785F-D69B-46F1-92FC-D2DE9C994F13}\InProcServer32")
	$O365CLSIDInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKCR\CLSID\{B7F1785F-D69B-46F1-92FC-D2DE9C994F13}\InProcServer32'
	$O365CLSIDInfo
	Print-SubSectionHeader("HKLM\SOFTWARE\Microsoft\Office\ClickToRun\Configuration")
	$O365ConfigInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\Office\ClickToRun\Configuration'
	$O365ConfigInfo
}

# Run PowerShell command
Function Run-PoShCmd ($ParamStr) {
	if ($ParamStr) {
		Print-CmdMessage -Msg "Result of the command - $ParamStr >>" -Delim 1
		$Res = Invoke-Expression $ParamStr
		$Res
		Print-CmdMessage -Msg "Result of the command - $ParamStr <<"
	} else { Print-WarningMessage("Command input empty!") }
}

# Enable CAPI2 log
Function Configure-CAPI2Log {
	Param( 
		[Parameter(Mandatory = $false, ParameterSetName = 'AL')][Switch] $AL,
		[Parameter(Mandatory = $false, ParameterSetName = 'DL')][Switch] $DL
	)
	
	# Enable CAPI2 log
	if ($AL) {
		$LogName = "Microsoft-Windows-CAPI2/Operational"
		$Log = New-Object System.Diagnostics.Eventing.Reader.EventLogConfiguration $LogName
		$Log.IsEnabled=$true
		$Log.SaveChanges()
	}
	
	# Disable CAPI2 log
	if ($DL) {
		$LogName = "Microsoft-Windows-CAPI2/Operational"
		$Log = New-Object System.Diagnostics.Eventing.Reader.EventLogConfiguration $LogName
		$Log.IsEnabled=$false
		$Log.SaveChanges()
	}
}

# Enter the mode of enabling/disbling CAPI2 event log
Function Enter-CAPI2LogSetting {
	Print-SectionHeader("CAPI2 Event Log")
	While ($True) {
		Print-LeadingSymbol(">>[CAPI2 Event Log]")
		$Condition = Read-Host -Prompt "[Enter your option (A: Enable CAPI2 event log; D: Disable CAPI2 event log; Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		switch ($Condition) {
			"A"        { Configure-CAPI2Log -AL; Print-CmdMessage("CAPI2 event log enabled.") }
			"D"        { Configure-CAPI2Log -DL; Print-CmdMessage("CAPI2 event log disabled.") }
			"eventvwr" { cmd.exe /c eventvwr }
		}
	}
}

##################################################
# Remove content cache 
##################################################
Function Remove-ContentCache($QueriedCntCache) {
	if ($QueriedCntCache) {
		# Remove content cache
		$ResMan = New-Object -ComObject "UIResource.UIResourceMgr"
		$CacheInfo = $ResMan.GetCacheInfo()
		#$CacheObj = $CacheInfo.GetCacheElements()
		$CacheCount = ($QueriedCntCache | Measure-Object | Select-Object).Count
		# Give a warning and ask for confirmation
		Print-WarningMessage("You about to delete $CacheCount content cache.")
		Print-LeadingSymbol(">>[Content Cache]"); $Answer = Read-Host -Prompt "[Yes to confirm; No to cancel > ]"
		$Answer = $Answer.Trim()
		# if yes, remove content. Otherwise, cancel content removal.
		if ($Answer -eq "Yes") {
			$QueriedCntCache | foreach {$CacheElemID = "{" + $_.CacheID + "}"; $CacheInfo.DeleteCacheElement($CacheElemID)}; Print-CmdMessage("Deleted $CacheCount content cache."); Write-Output "`n" }
		else { Print-CmdMessage("Cache deletion cancelled."); Write-Output "`n"; break }
	} else {
		Print-WarningMessage("Query content cache first before removal!"); Write-Output "`n"
	}
}

##################################################
# Get cache configuration information
##################################################
Function Get-CacheConfigInfo {
	# Create resource manager for cache
	$ResMan = New-Object -ComObject "UIResource.UIResourceMgr"
	$CacheInfo = $ResMan.GetCacheInfo()
	$CacheInfo | Select-Object Location, @{Name="TotalSize(M)";Expression={$_.TotalSize}}, @{Name="FreeSize(M)";Expression={$_.FreeSize}}, @{Name="TombStoneDuration(min)";Expression={$_.TombStoneDuration}}, @{Name="MaxCacheDuration(min)";Expression={$_.MaxCacheDuration}}
}

##################################################
# Get cache content
##################################################
Function Get-CacheContent {
	# Get cache content
	$ContentCacheInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\SoftMgmtAgent" -Class CacheInfoEx | Select-Object ContentId, CacheId, @{Name="ContentSize(KB)";Expression={$_.ContentSize}}, ContentComplete, ContentType, ContentVer, Location,  ContentFlags, LastReferenced, ContentManifest, DeploymentFlags, ExcludeFileList, PartialContentInfo, PeerCaching, PersistInCache, ReferenceCount
	Return $ContentCacheInfo
}

##################################################
# Query SMS content cache
##################################################
Function Query-ContentCache {
	# Overview goes here - Start
	Print-SectionHeader("Content Cache")
	# Print cache configuraiton
	Print-SubSectionHeader("Cache Configuration")
	
	# Get cache configuration info
	Get-CacheConfigInfo 

	# Get content cache info
	$ContentCacheInfo = Get-CacheContent
	$TotalCacheCount = ($ContentCacheInfo | Measure-Object | Select-Object).Count

	# Overview of downloaded content in the cache
	Print-Overview("You have $TotalCacheCount content cache (only the first 10 results will be listed. To display all results, enter L.):")
	$Idx = 1; $ContentCacheInfo | Select-Object -First 10 | foreach {$CntId = $_.ContentID; $CacheID = $_.CacheId; $CntComplete = $_.ContentComplete; $CntSize = $_."ContentSize(KB)"; $Visibility = $_.UserUIExperience; $Index = Format-Width -Str ${Idx} -Width "${TotalCacheCount}".length; Write-Output "${Index}: ContentId: $CntId CacheId: $CacheID Complete?: $CntComplete Size(KB): $CntSize"; $Idx = $Idx + 1 }
	# Overview goes here - End
	
	# Define a function scope variable for queried content cache
	$ResFound = $Null
	While ($True) {	
		Print-LeadingSymbol(">>[Content Cache]")
		$Condition = Read-Host -Prompt "[Enter ContentId or CacheId to search for cache (L: list all cache; D: remove cache; Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		
		if ($Condition) {
			switch ($Condition) {
				"L" 
				{	# List all content cach if confirmed
					$Answer = Read-Host -Prompt "[List ALL $TotalCacheCount content cache? Yes to confirm; No to cancel > ]"
					if ($Answer -ne "Yes") { "Cancelled listing all content cache.";Continue }
					Print-CmdMessage("$TotalCacheCount content cache >>") -Delim 1
					$Idx = 1; $ContentCacheInfo | foreach {$CntId = $_.ContentID; $CacheID = $_.CacheId; $CntComplete = $_.ContentComplete; $CntSize = $_."ContentSize(KB)"; $Visibility = $_.UserUIExperience; $Index = Format-Width -Str ${Idx} -Width "${TotalCacheCount}".length; Write-Output "${Index}: ContentId: $CntId CacheId: $CacheID Complete?: $CntComplete Size(KB): $CntSize"; $Idx = $Idx + 1 }
					Print-CmdMessage("$TotalCacheCount content cache <<")
					$ResFound = $ContentCacheInfo
				}
				"D" { Remove-ContentCache($ResFound); $ResFound = $Null; $ContentCacheInfo = Get-CacheContent; $TotalCacheCount = ($ContentCacheInfo | Measure-Object | Select-Object).Count }
				Default
				{
					$ResFound = $ContentCacheInfo | Where-Object { ($_.ContentID -like "*$Condition*") -or ($_.CacheId -like "*$Condition*")}
					$ResCount = ($ResFound | Measure-Object | Select-Object).Count
					Print-CmdMessage("Found $ResCount result >>") -Delim 1
					$Index = 1; $ResFound | foreach { Print-CmdMessage("< Result $Index > "); $_; $Index += 1 }
					Print-CmdMessage("Found $ResCount result <<")
				}
			}
		}
	}
}

##################################################
# Print WSUS config
##################################################
Function Print-WSUS {
	Print-SectionHeader("WSUS Configuration")
	Print-SubSectionHeader("Windows Update: HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate")
	$WURegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate' | Select-Object -Property WUServer, WUStatusServer, DisableDualScan, DisableWindowsUpdateAccess, @{Name="RegPath";Expression={($_.PSPath -split "::")[1]}}
	$WURegInfo
	
	Print-SubSectionHeader("Windows Update SusClient: HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate")
	$WUSusClientInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate' | Select-Object -Property SusClientId, LastDownloadsPurgeTime, LastTaskOperationHandle, UpdateDesiredVisibility, @{Name="SusClientIdValidation";Expression={$_.SusClientIdValidation -join ""}}, @{Name="RegPath";Expression={($_.PSPath -split "::")[1]}}
	$WUSusClientInfo
	
	Print-SubSectionHeader("Windows Update AU: HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate\AU")
	$WUAURegInfo = Get-ItemProperty -ErrorAction SilentlyContinue 'Registry::HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate\AU' | Select-Object -Property IncludeRecommendedUpdates, @{Name="NoAutoUpdate";Expression={switch ($_.NoAutoUpdate) {0 {"0 - Automatic Updates is enabled (default)"}; 1 {"1 - Automatic Updates is disabled"}}}}, @{Name="AUOptions";Expression={switch ($_.AUOptions) {1 {"1 - Keep my computer up to date is disabled in Automatic Updates"}; 2 {"2 - Notify of download and installation"}; 3 {"3 - Automatically download and notify of installation"}; 4 {"4 - Automatically download and scheduled installation"}}}}, ScheduledInstallDay, ScheduledInstallTime, UseWUServer, @{Name="RegPath";Expression={($_.PSPath -split "::")[1]}}
	
	Print-SubSectionHeader("Dual Scan Check")
	$MUSM = New-Object -ComObject "Microsoft.Update.ServiceManager"
	$DuanScanCheck = $MUSM.Services | select Name, IsDefaultAUService, ServiceID, ServiceUrl
	$DuanScanCheck
}

##################################################
# Print BGB status
##################################################
Function Print-BGB {
	Print-SectionHeader("BGB Status")
	
	# Get BGB client configuration
	Print-SubSectionHeader("ROOT\ccm\Policy\Machine\ActualConfig:CCM_BGBClientConfig")
	$BGBCLIConfig = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class CCM_BGBClientConfig #| Select-Object -Property ComponentName, Enabled
	$BGBCLIConfig
	
	# Get BGB communication configuration
	Print-SubSectionHeader("ROOT\ccm\Policy\Machine\ActualConfig:CCM_BGBCommunicationConfig")
	$BGBComConfig = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class CCM_BGBCommunicationConfig #| Select-Object -Property EnableHttpListener, EnableTcpListener, HttpKeepAliveInterval, TcpKeepAliveInterval, TcpPortNumber
	$BGBComConfig
}

######################################################
# Query deployed applications
# $Condition can be application name or application ID
######################################################
Function Query-Applications {
	# Overview goes here - Start
	Print-SectionHeader("Applications")
	# Get all deployed applications based on $Condition. If $Condition is ?  all results will be returned.
	$AppInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\ClientSDK" -Class CCM_Application | Select-Object Name, FullName, UserUIExperience, Revision, Id, @{Name="Deadline";Expression={($_.Deadline.SubString(0,4), $_.Deadline.SubString(4,2),$_.Deadline.SubString(6,2), $_.Deadline.SubString(8,2), $_.Deadline.SubString(10,2), $_.Deadline.SubString(12,2)) -join "-"}}, @{Name="LastInstallTime";Expression={($_.LastInstallTime.SubString(0,4), $_.LastInstallTime.SubString(4,2),$_.LastInstallTime.SubString(6,2), $_.LastInstallTime.SubString(8,2), $_.LastInstallTime.SubString(10,2), $_.LastInstallTime.SubString(12,2)) -join "-"}}, @{Name="StartTime";Expression={($_.StartTime.SubString(0,4), $_.StartTime.SubString(4,2),$_.StartTime.SubString(6,2), $_.StartTime.SubString(8,2), $_.StartTime.SubString(10,2), $_.StartTime.SubString(12,2)) -join "-"}}, @{Name="EvaluationState";Expression={Interprete-AppEvaluationState($_.EvaluationState)}}, ApplicabilityState, InstallState, ResolvedState, ConfigureState, OverrideServiceWindow, RebootOutsideServiceWindow, @{Name="DeploymentReport";Expression={$AppDepD = Get-AppDeploymentDetail -AppID $_.Id -AppRevision $_.Revision; Format-XML($AppDepD)}}, NotifyUser, EnforcePreference, ErrorCode, EstimatedInstallTime, FileTypes, InformativeUrl, InfoUrlText, InProgressActions, IsMachineTarget, IsPreflightOnly, LastEvalTime, NextUserScheduledTime, PercentComplete, SupersessionState, Type, ApplicationType, Categories, ContentSize, Description, SoftwareVersion, PrivacyUri, Publisher, ReleaseDate, HighImpactDeployment
	$TotalAppCount = ($AppInfo | Measure-Object | Select-Object).Count

	# Overview of deployed applications
	Print-Overview("You have $TotalAppCount applications (only the first 10 results will be listed. To display all results, hit Enter key.):")
	$Idx = 1; $AppInfo | Select-Object -First 10 | foreach {$AppName = $_.Name; $AppId = $_.Id; $Visibility = $_.UserUIExperience; $Index = Format-Width -Str ${Idx} -Width "${TotalAppCount}".length; Write-Output "${Index}: $AppId (visible: $Visibility) ApplicationName: $AppName"; $Idx = $Idx + 1 }
	# Overview goes here - End
	
	While ($True) {
		Print-LeadingSymbol(">>[Applications]")
		$Condition = Read-Host -Prompt "[Enter application name or ID to search (Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		
		if ($Condition) {
			switch ($Condition) {
				"dpL" { Query-Deployments }
				Default 
				{
					# Search for applications based on $Condition. If $Condition is ?  all results will be returned.
					$QueriedApp = $AppInfo | Where-Object {($_.Name -like "*$Condition*") -or ($_.ID -like "*$Condition*") -or ($_.DeploymentReport -like "*$Condition*") }
					$QueriedAppCount = ($QueriedApp | Measure-Object | Select-Object).Count
					Print-CmdMessage("Found $QueriedAppCount result >>") -Delim 1
					$Index = 1; $QueriedApp | foreach { Print-CmdMessage("< Result $Index > "); $_; $Index += 1 }
					Print-CmdMessage("Found $QueriedAppCount result <<")
				}
			}
		} else { # Show all applications if confirmed
			$Answer = Read-Host -Prompt "[List ALL $TotalAppCount applications? Yes to confirm; No to cancel > ]"
			if ($Answer -ne "Yes") { "Cancelled listing all applications.";Continue }
			Print-CmdMessage("Displaying Applications ($TotalAppCount): ROOT\ccm\ClientSDK:CCM_Application >>") -Delim 1
			$Idx = 1; $AppInfo | foreach {$AppName = $_.Name; $AppId = $_.Id; $Visibility = $_.UserUIExperience; $Index = Format-Width -Str ${Idx} -Width "${TotalAppCount}".length; Write-Output "${Index}: $AppId (visible: $Visibility) ApplicationName: $AppName"; $Idx = $Idx + 1 } | Out-Host -Paging
			Print-CmdMessage("Displayed Applications ($TotalAppCount): ROOT\ccm\ClientSDK:CCM_Application <<")
		}
	}
}

###################################################################
# Query deployed updates
# $Condition can be update ArticleID, Name, UpdateID or Description 
###################################################################
Function Query-Updates {
	# Overview goes here - Start
	Print-SectionHeader("Software Updates")
	# Get all deployed updates
	$Updates = Get-WMIObject -ErrorAction SilentlyContinue -namespace "Root\ccm\ClientSDK" -Class CCM_SoftwareUpdate | Select-Object -Property ArticleID, Name, Description, UpdateID, UserUIExperience, @{Name="Deadline";Expression={($_.Deadline.SubString(0,4), $_.Deadline.SubString(4,2),$_.Deadline.SubString(6,2), $_.Deadline.SubString(8,2), $_.Deadline.SubString(10,2), $_.Deadline.SubString(12,2)) -join "-"}}, @{Name="StartTime";Expression={($_.StartTime.SubString(0,4), $_.StartTime.SubString(4,2),$_.StartTime.SubString(6,2), $_.StartTime.SubString(8,2), $_.StartTime.SubString(10,2), $_.StartTime.SubString(12,2)) -join "-"}}, EstimatedInstallTime, @{Name="EvaluationState";Expression={Interprete-UpdEvaluationState($_.EvaluationState)}}, ErrorCode, ComplianceState, ContentSize, PercentComplete, Type, NextUserScheduledTime, OverrideServiceWindows, RebootOutsideServiceWindows, RestartDeadline, NotifyUser, ExclusiveUpdate, MaxExecutionTime, IsUpgrade, FullName, IsO365Update, URL, Publisher, BulletinID
	$TotalUpdatesCount = ($Updates | Measure-Object | Select-Object).Count

	# Overview of deployed updates
	Print-Overview("You have $TotalUpdatesCount updates (only the first 10 results will be listed. To display all results, hit Enter key.):")
	$Idx = 1; $Updates | Select-Object -First 10 | foreach {$ArticleID = $_.ArticleID; $UpdID = $_.UpdateID; $Visibility = $_.UserUIExperience; $UpdName = $_.Name; $Index = Format-Width -Str ${Idx} -Width "${TotalUpdatesCount}".length; Write-Output "${Index}: $ArticleID $UpdID (visible: $Visibility) -> $UpdName"; $Idx = $Idx + 1 }
	# Overview goes here - End
	
	While ($True) {
		Print-LeadingSymbol(">>[Software Updates]")
		$Condition = Read-Host -Prompt "[Enter update ArticleID, UpdateID, Name to search (Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		
		if ($Condition) {
			switch ($Condition) {
				"dpL"   { Query-Deployments }
				"updhs" { Query-WUHist }
				Default 
				{
					# Search for updates based on $Condition. If $Condition is ?  all results will be returned.
					$QueriedUpdates = $Updates | Where-Object {($_.ArticleID -like "*$Condition*") -or ($_.Name -like "*$Condition*") -or ($_.UpdateID -like "*$Condition*") }
					$QueriedUpdCount = ($QueriedUpdates | Measure-Object | Select-Object).Count
					Print-CmdMessage("Found $QueriedUpdCount result >>") -Delim 1
					$Index = 1; $QueriedUpdates | foreach { Print-CmdMessage("< Result $Index > "); $_; $Index += 1 }
					Print-CmdMessage("Found $QueriedUpdCount result <<")
				}
			}
		} else { # Show all updates if confirmed
			$Answer = Read-Host -Prompt "[List ALL $TotalUpdatesCount updates? Yes to confirm; No to cancel > ]"
			if ($Answer -ne "Yes") { "Cancelled listing all updates.";Continue }
			Print-CmdMessage("Displaying Updates ($TotalUpdatesCount): Root\ccm\ClientSDK:CCM_SoftwareUpdate >>") -Delim 1
			$Idx = 1; $Updates | foreach {$ArticleID = $_.ArticleID; $UpdID = $_.UpdateID; $Visibility = $_.UserUIExperience; $UpdName = $_.Name; $Index = Format-Width -Str ${Idx} -Width "${TotalUpdatesCount}".length; Write-Output "${Index}: $ArticleID $UpdID (visible: $Visibility) --> $UpdName"; $Idx = $Idx + 1 } | Out-Host -Paging
			Print-CmdMessage("Displayed Updates ($TotalUpdatesCount): Root\ccm\ClientSDK:CCM_SoftwareUpdate <<")
		}
	}
}

##################################################
# List packages and task sequences
##################################################
Function Query-PkgTskSeq {
	# Overvier goes here - Start
	Print-SectionHeader("Packages and Task sequences")
	# Get all deployed packages and task sequences
	$PkgTskSeq = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\ClientSDK" -Class CCM_Program | Select-Object PackageID, PackageName, ProgramID, RepeatRunBehavior, RestartRequired, FullName, Name, LastRunStatus, LastExitCode, LastRunTime, ErrorCode, Duration, NotifyUser, RequiresUserInput, ActivationTime, AdvertisedDirectly, Categories, CompletionAction, ContentSize, CustomHighImpactHeadline, CustomHighImpactSet, CustomHighImpactWarning, CustomHighImpactWarningInstall, CustomHighImpactWarningTop, Deadline, Dependencies, DependentPackageID, DependentProgramID, Description, DiskSpaceRequired, EstimatedDownloadSizeMB, EstimatedInstallTime, EstimatedRunTimeMinutes, EvaluationState, ExpirationTime, ForceDependencyToRun, HighImpact, HighImpactTaskSequence, Level, LocalizedTaskSequenceDescription, NextUserScheduledTime, PackageLanguage, PercentComplete, Published, Publisher, RunAtLogoff, RunAtLogon, RunDependent, TaskSequence, Type, Version
	$TotalPkgTskSeqCount = ($PkgTskSeq | Measure-Object | Select-Object).Count

	# Overview of deployed packages and task sequences
	Print-Overview("You have $TotalPkgTskSeqCount packages and task sequences (only the first 10 results will be listed. To display all results, hit Enter key.):")
	$Idx = 1; $PkgTskSeq | Select-Object -First 10 | foreach {$PkgID = $_.PackageID; $PkgName = $_.PackageName; $IsTskSeq = $_.TaskSequence; $Index = Format-Width -Str ${Idx} -Width "${TotalPkgTskSeqCount}".length; Write-Output "${Index}: PackageID: $PkgID (Task sequence?: $IsTskSeq) PackageName: $PkgName"; $Idx = $Idx + 1 }
	# Overview goes here - End
	
	While ($True) {
		Print-LeadingSymbol(">>[Packages/TaskSequences]")
		$Condition = Read-Host -Prompt "[Enter package ID or name, task sequence ID or name to search (Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		
		if ($Condition) {
			switch ($Condition) {
				dpL {Query-Deployments}
				Default
				{
					# Search for packages, task sequences based on $Condition. If $Condition is ?  all results will be returned.
					$QueriedPkgTskSeq = $PkgTskSeq | Where-Object {($_.PackageID -like "*$Condition*") -or ($_.PackageName -like "*$Condition*") }
					$QueriedPkgTskSeqCount = ($QueriedPkgTskSeq | Measure-Object | Select-Object).Count
					Print-CmdMessage("Found $QueriedPkgTskSeqCount result >>") -Delim 1
					$Index = 1; $QueriedPkgTskSeq | foreach { Print-CmdMessage("< Result $Index > "); $_; $Index += 1 }
					Print-CmdMessage("Found $QueriedPkgTskSeqCount result <<")
				}
			}
		} else { # Show all packages and task sequences if confirmed
			$Answer = Read-Host -Prompt "[List ALL $TotalPkgTskSeqCount packages and task sequences? Yes to confirm; No to cancel > ]"
			if ($Answer -ne "Yes") { "Cancelled listing all packages and task sequences.";Continue }
			Print-CmdMessage("Displaying Packages & Task sequences ($TotalPkgTskSeqCount): ROOT\ccm\ClientSDK:CCM_Program >>") -Delim 1
			$Idx = 1; $PkgTskSeq | foreach {$PkgID = $_.PackageID; $PkgName = $_.PackageName; $IsTskSeq = $_.TaskSequence; $Index = Format-Width -Str ${Idx} -Width "${TotalPkgTskSeqCount}".length; Write-Output "${Index}: PackageID: $PkgID (Task sequence?: $IsTskSeq) PackageName: $PkgName"; $Idx = $Idx + 1 } | Out-Host -Paging
			Print-CmdMessage("Displayed Packages & Task sequences ($TotalPkgTskSeqCount): ROOT\ccm\ClientSDK:CCM_Program <<")
		}
	}
}


################################################################################################################
# Run action with action ID
# Note that this function, when called in Trigger-Actions, cannot work as expected due to unknow reason for now
################################################################################################################
Function Run-Action($ActionID, $ActionName) {
	Write-Host "@ Message: Running $ActionDesc..." -BackgroundColor White -ForegroundColor Black
	([wmiclass]'root\ccm:SMS_Client').TriggerSchedule($ActionID)
	Write-Host "@ Message: $ActionDesc completed." -BackgroundColor White -ForegroundColor Black
}

####################################################################################################################################################
# Trigger actions
# https://docs.microsoft.com/en-us/mem/configmgr/develop/reference/core/clients/client-classes/triggerschedule-method-in-class-sms_client#parameters
# eg. policy retrieval, hardware inventory, software update scan, etc. actions in Actions of SMS Agent UI
# eg. reset policy, resend state messages, etc.
####################################################################################################################################################
Function Trigger-Actions {
	Print-SectionHeader("Trigger Actions")
	While ($True) {	
		Print-LeadingSymbol(">>[Trigger Actions]"); $Option = Read-Host -Prompt "[Enter your option (?: Show options; Q:exit) > ]" 
		$Option = $Option.Trim()
		if ($Option -eq "?") { Print-Menu -Menu $CLActions -Title "Options" -BgColr "Blue"; Continue }
		if ($Option -eq "Q") { break }
		switch ($Option) {
			"hiv" { Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['hiv']['actionid']; $ActName = $CLActions['hiv']['name']; Print-CmdMessage("$ActName completed.") } # Hardware Inventory Cycle
			"hfu" {
					Get-WmiObject -Namespace root\ccm\invagt -Class inventoryactionstatus | Where-Object {$_.inventoryactionid -eq "{00000000-0000-0000-0000-000000000001}"} | Remove-WmiObject
					Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule "{00000000-0000-0000-0000-000000000001}"  
					$ActName = $CLActions['hfu']['name']; Print-CmdMessage("$ActName completed.") 
				  } # Hardware Inventory Cycle
			"siv" { Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['siv']['actionid']; $ActName = $CLActions['siv']['name']; Print-CmdMessage("$ActName completed.") } # Software Inventory Cycle
			"ddr" { Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['ddr']['actionid']; $ActName = $CLActions['ddr']['name']; Print-CmdMessage("$ActName completed.") } # Discovery Data Collection Cycle
			"ade" { Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['ade']['actionid']; $ActName = $CLActions['ade']['name']; Print-CmdMessage("$ActName completed.") } # Application Deployment Evaluation Cycle
			"mpr" { Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['mpr']['actionid']; $ActName = $CLActions['mpr']['name']; Print-CmdMessage("$ActName completed.") } # Machine Policy Assignments Request
			"mpe" { Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['mpe']['actionid']; $ActName = $CLActions['mpe']['name']; Print-CmdMessage("$ActName completed.") } # Machine Policy Evaluation
			"mpL" { 
					# Machine Policy Retrieval & Evaluation Cycle
					Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['mpr']['actionid'] # Machine Policy Assignments Request
					Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['mpe']['actionid'] # Machine Policy Evaluation
					$ActName = $CLActions['mpL']['name']; Print-CmdMessage("$ActName completed.")
				  }
			<#"urr" { Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['urr']['actionid']; $ActName = $CLActions['urr']['name']; Print-CmdMessage("$ActName completed.") } # User Policy Assignments Request
			"ure" { Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['ure']['actionid']; $ActName = $CLActions['ure']['name']; Print-CmdMessage("$ActName completed.") } # User Policy Evaluation
			"usr" { 
					# User Policy Retrieval & Evaluation Cycle
					Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['urr']['actionid'] # User Policy Assignments Request
					Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['ure']['actionid'] # User Policy Evaluation
					$ActName = $CLActions['usr']['name']; Print-CmdMessage("$ActName completed.")
				  }#>
			"sde" { Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['sde']['actionid']; $ActName = $CLActions['sde']['name']; Print-CmdMessage("$ActName completed.") } # Software Updates Deployment Evaluation Cycle
			"ups" { Invoke-WMIMethod -Namespace root\ccm -Class SMS_CLIENT -Name TriggerSchedule $CLActions['ups']['actionid']; $ActName = $CLActions['ups']['name']; Print-CmdMessage("$ActName completed.") } # Software Updates Scan Cycle
			"rst" { Invoke-WMIMethod -Namespace root\ccm -Class SMS_Client -Name ResetPolicy -ArgumentList "1"; $ActName = $CLActions['rst']['name']; Print-CmdMessage("$ActName completed.") }
			"rfr" { (New-Object -ComObject Microsoft.CCM.UpdatesStore).RefreshServerComplianceState(); $ActName = $CLActions['rfr']['name']; Print-CmdMessage("$ActName completed.") }
			"rma" { Remove-AgentInfo; $ActName = $CLActions['rma']['name']; Print-CmdMessage("$ActName completed.") }
			"rmj" { Remove-StuckJobs; $ActName = $CLActions['rmj']['name']; Print-CmdMessage("$ActName completed.") }
			"rsw" { Reset-WUComponent; $ActName = $CLActions['rsw']['name']; Print-CmdMessage("$ActName has been launched. Continue and monitor the progress in the popup window.") } # A new cmd window will pop up to run this method. Monitor the progress in that cmd window.
		}
	}
}

############################################################################################
# Query: CIAssignments, that is Deployments
# Deployments of updates, applications, baselines, CoMgmt settings, etc. have CIAssignments
# Query:
# CCM_TaskSequence - task sequence deployments
# CCM_SoftwareDistribution - Packages and task seqences deployments
############################################################################################
Function Query-Deployments {
	# Overview goes here - Start
	Print-SectionHeader("Deployments of Updates/Applications/Baselines")
	# 1. Get all deployments of updates, applications, baselines, CoMgmt settings, etc.
	$CIAssignments = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class CCM_CIAssignment | Select-Object -Property AssignmentID, @{Name="AssignedCIs";Expression={$_.AssignedCIs -join ';'}}, AssignmentName, NotifyUser, StartTime, OverrideServiceWindows, EnforcementDeadline, ExpirationTime, RebootOutsideOfServiceWindows, AssignmentAction, PersistOnWriteFilterDevices, AssignmentFlags, ConfigurationFlags, DesiredConfigType, DisableMomAlerts, DPLocality, LogComplianceToWinEvent, NonComplianceCriticality, Precedence, RaiseMomAlertsOnFailure, SuppressReboot, UpdateDeadline, SendDetailedNonComplianceStatus, SettingTypes, SoftDeadlineEnabled, UseGMTTimes, StateMessagePriority, UseSiteEvaluation, WoLEnabled, Reserved1, Reserved2, Reserved3, Reserved4 
	$TotalCIAsmnts = ($CIAssignments | Measure-Object | Select-Object).Count

	# 2. All deployments of Packages and Task sequences
	$CCMPkgTsk = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class CCM_SoftwareDistribution
	$TotalCCMPkgTsk = ($CCMPkgTsk | Measure-Object | Select-Object).Count

	# Overview of all deployments of updates, applications, baselines, CoMgmt settings, etc.
	Print-Overview("You have $TotalCIAsmnts deployments of updates, applications, baselines, etc. (only the first 10 results will be listed. To display all results, hit Enter key.):")
	$Idx = 1; $CIAssignments | Select-Object -First 10 | foreach {$DepID = $_.AssignmentID; $DepName = $_.AssignmentName; $Index = Format-Width -Str ${Idx} -Width "${TotalCIAsmnts}".length; Write-Output "${Index}: DeploymentID: $DepID AssignmentName: $DepName"; $Idx = $Idx + 1 }
	
	# Overview of all deployments of task sequences and packages.
	Print-Overview("You have $TotalCCMPkgTsk deployments of task sequence and packages, etc. (only the first 10 results will be listed. To display all results, hit Enter key.):")
	$Idx = 1; $CCMPkgTsk | Select-Object -First 10 | foreach {$DepID = $_.ADV_AdvertisementID; $PkgName = $_.PKG_Name; $Index = Format-Width -Str ${Idx} -Width "${TotalCIAsmnts}".length; Write-Output "${Index}: DeploymentID: $DepID Name: $PkgName"; $Idx = $Idx + 1 }
	# Overview goes here - End
	
	While ($True) {
		Print-LeadingSymbol(">>[Deployments]")
		$Condition = Read-Host -Prompt "[Enter DeploymentID, AssignmentName, UpdateID/UpdateName/KBNumber, ApplicationID, BaselineID, Package/Task Sequence ID/Name to search (Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		
		if ($Condition) {
			# 1. Search in $CIAssignments for deployments based on $Condition. If $Condition is ?  all results will be returned.
			$QueriedAsmnts = $CIAssignments | Where-Object {($_.AssignmentID -like "*$Condition*") -or ($_.AssignedCIs -like "*$Condition*") -or ($_.AssignmentName -like "*$Condition*") }
			$QueriedAsmntCount = ($QueriedAsmnts | Measure-Object | Select-Object).Count
			Print-CmdMessage("Found $QueriedAsmntCount result of updates/applications/baselines etc. >>") -Delim 1
			$Index = 1; $QueriedAsmnts | foreach { Print-CmdMessage("< Result $Index > "); $_; $Index += 1 }
			Print-CmdMessage("Found $QueriedAsmntCount result of updates/applications/baselines etc. <<")
			
			# 1. Search in $CCMPkgTsk for deployments based on $Condition. If $Condition is ?  all results will be returned.
			$QueriedSoftDist = $CCMPkgTsk | Where-Object {($_.ADV_AdvertisementID -like "*$Condition*") -or ($_.PKG_PackageID -like "*$Condition*") -or ($_.PKG_Name -like "*$Condition*") }
			$QueriedSoftDistCount = ($QueriedSoftDist | Measure-Object | Select-Object).Count
			Print-CmdMessage("Found $QueriedSoftDistCount result of packages/task sequences, etc. >>") -Delim 1
			$Index = 1; $QueriedSoftDist | foreach { Print-CmdMessage("< Result $Index > "); $_; $Index += 1 }
			Print-CmdMessage("Found $QueriedSoftDistCount result of packages/task sequences, etc. <<")
		} else { # Show all deployments if confirmed
			$TotalDeps = $TotalCIAsmnts + $TotalCCMPkgTsk
			$Answer = Read-Host -Prompt "[List ALL $TotalDeps deployments? Yes to confirm; No to cancel > ]"
			if ($Answer -ne "Yes") { "Cancelled listing all state messages.";Continue }
			# 1. Display all deployments of updates, applications, baselines, CoMgmt settings, etc. 
			Print-CmdMessage("Displaying Deployments ($TotalCIAsmnts): ROOT\ccm\Policy\Machine\ActualConfig:CCM_CIAssignment >>") -Delim 1
			$Idx = 1; $CIAssignments | foreach {$DepID = $_.AssignmentID; $DepName = $_.AssignmentName; $Index = Format-Width -Str ${Idx} -Width "${TotalCIAsmnts}".length; Write-Output "${Index}: DeploymentID: $DepID AssignmentName: $DepName"; $Idx = $Idx + 1 } | Out-Host -Paging
			Print-CmdMessage("Displayed Deployments ($TotalCIAsmnts): ROOT\ccm\Policy\Machine\ActualConfig:CCM_CIAssignment <<")
			
			# 2. all deployments of task sequences and packages, etc.
			Print-CmdMessage("Displaying Deployments ($TotalCCMPkgTsk): ROOT\ccm\Policy\Machine\ActualConfig:CCM_SoftwareDistribution >>") -Delim 1
			$Idx = 1; $CCMPkgTsk | foreach {$DepID = $_.ADV_AdvertisementID; $PkgName = $_.PKG_Name; $Index = Format-Width -Str ${Idx} -Width "${TotalCIAsmnts}".length; Write-Output "${Index}: DeploymentID: $DepID Name: $PkgName"; $Idx = $Idx + 1 } | Out-Host -Paging
			Print-CmdMessage("Displayed Deployments ($TotalCCMPkgTsk): ROOT\ccm\Policy\Machine\ActualConfig:CCM_SoftwareDistribution <<")
		}
	}
}

#####################################################
# Query state messages
# State messages of updates, applications, baselines
#####################################################
Function Query-StateMessages {
	# Overview goes here - Start
	Print-SectionHeader("State Messages")
	# Get all state messages
	$StatMsgInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\StateMsg:CCM_StateMsg" -Query "SELECT * FROM CCM_StateMsg" | Select-Object TopicID, TopicType, StateID, TopicIDType, MessageSent, @{Name="MessageTime"; Expression={($_.MessageTime.SubString(0,4), $_.MessageTime.SubString(4,2),$_.MessageTime.SubString(6,2), $_.MessageTime.SubString(8,2), $_.MessageTime.SubString(10,2), $_.MessageTime.SubString(12)) -join "-"}}, UserSID, User,UserFlags, Criticality, ParamCount, Priority,Reserved1, Reserved2, Reserved3, @{Name="StateDetails";Expression={Format-XML($_.StateDetails)}}, StateDetailsType, UserParameters | Sort-Object -Property MessageTime -Descending  
	$TotalStateMsg = ($StatMsgInfo | Measure-Object | Select-Object).Count

	# Overview of all state messages
	Print-Overview("You have $TotalStateMsg state messages.")
	#Overview goes here - End
	
	While ($True) {	
		Print-LeadingSymbol(">>[State Messages]")
		$Condition = Read-Host -Prompt "[Enter DeploymentID, UpdateID, ApplicationID/DeploymentTypeID, BaselineID to search (Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		
		if ($Condition) {
			# Search for state messages based on $Condition. If $Condition is ?  all results will be returned.
			$QueriedStateMsg = $StatMsgInfo | Where-Object { ($_.TopicID -like "*$Condition*") -or ($_.StateDetails -like "*$Condition*") }
			$QueriedStMsgCount = ($QueriedStateMsg | Measure-Object | Select-Object).Count
			Print-CmdMessage("Found $QueriedStMsgCount result >>") -Delim 1
			$Index = 1; $QueriedStateMsg | foreach { Print-CmdMessage("< Result $Index > "); $_; $Index += 1 }
			Print-CmdMessage("Found $QueriedStMsgCount result <<")
		} else { # Show all state messages if confirmed
			$Answer = Read-Host -Prompt "[List ALL $TotalStateMsg state messages? Yes to confirm; No to cancel > ]"
			if ($Answer -ne "Yes") { "Cancelled listing all state messages.";Continue }
			Print-CmdMessage("Displaying State Messages ($TotalStateMsg): ROOT\ccm\StateMsg:CCM_StateMsg >>") -Delim 1
			$StatMsgInfo | Out-Host -Paging
			Print-CmdMessage("Displayed State Messages ($TotalStateMsg): ROOT\ccm\StateMsg:CCM_StateMsg <<")
		}
	}
}

#####################
# Query updates store
#####################
Function Query-UpdatesStore {
	# Overview goes here -  Start
	Print-SectionHeader("Updates Store")
	# Get all updates store
	$UPSInfo =Get-WMIObject -ErrorAction SilentlyContinue -namespace "ROOT\ccm\SoftwareUpdates\UpdatesStore" -query "SELECT * FROM CCM_UpdateStatus" | Select-Object Title, UniqueId, RevisionNumber, Status, SourceType, @{Name="Sources"; Expression={$_.Sources.SourceUniqueId}}, ScanTime, UpdateClassification, ProductID  | Sort-Object -Property Status -Descending  
	$TotalUps = ($UPSInfo | Measure-Object | Select-Object).Count
	
	# Overview of all state messages
	Print-Overview("You have $TotalUps update store messages.")
	# Overview goes here - End
		
	While ($True) {
		Print-LeadingSymbol(">>[Updates Store]")
		$Condition = Read-Host -Prompt "[Enter UpdateID, UpdateTitle to search (Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		
		if ($Condition) {
			# Search for updates store based on $Condition. If $Condition is ?  all results will be returned.
			$QueriedUpdS = $UPSInfo | Where-Object { ($_.UniqueId -like "*$Condition*") -or ($_.Title -like "*$Condition*") }
			$QueriedUpdSCount = ($QueriedUpdS | Measure-Object | Select-Object).Count
			Print-CmdMessage("Found $QueriedUpdSCount result >>") -Delim 1
			$Index = 1; $QueriedUpdS | foreach { Print-CmdMessage("< Result $Index > "); $_; $Index += 1 }
			Print-CmdMessage("Found $QueriedUpdSCount result <<")
		} else { # Show all updates store if confirmed
			$Answer = Read-Host -Prompt "[List ALL $TotalUps updates store? Yes to confirm; No to cancel > ]"
			if ($Answer -ne "Yes") { "Cancelled listing all updates store.";Continue }
			Print-CmdMessage("Displaying Updates Store ($TotalUps): ROOT\ccm\SoftwareUpdates\UpdatesStore >>") -Delim 1
			$UPSInfo | Out-Host -Paging
			Print-CmdMessage("Displayed Upstates Store ($TotalUps): ROOT\ccm\SoftwareUpdates\UpdatesStore <<")
		}
	}
}

###########################
# Print boundary group
###########################
Function Print-BoundaryGroup {
	Print-SectionHeader("Boundary Group")
	Print-SubSectionHeader("ROOT\ccm\LocationServices:BoundaryGroupCache")
	$BGInfo = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\LocationServices:BoundaryGroupCache" -Class BoundaryGroupCache | Select-Object @{Name="BoundaryGroupIDs"; Expression={$_.BoundaryGroupIDs -join ", "}}, @{Name="BoundaryGroupGUIDs"; Expression={$_.BoundaryGroupGUIDs -join ", "}}, IsOnVPN, @{Name="DOINCServers"; Expression={$_.DOINCServers -join ", "}}, CacheToken
	$BGInfo
	$BGIDs = $BGInfo.BoundaryGroupIDs
	if ($BGIDs) {Print-CmdMessage("To get boundary groups details, run in PowerShell from ConfigMgr console: Get-CMBoundaryGroup -Id $BGIDs")}
}


# Display Client Settings
Function Print-ClientSettings {
	Print-SectionHeader("Client Settings")
	# BITs service
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#background-intelligent-transfer-service-bits
	$BITS = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_Service_BITS2Configuration" | Select-Object -Property @{Name="Limit the maximum network bandwidth for BITS background transfers";Expression={$_.EnableBitsMaxBandwidth}}, @{Name="Throttling window start time";Expression={$_.MaxBandwidthValidFrom}}, @{Name="Throttling window end time";Expression={$_.MaxBandwidthValidTo}}, @{Name="Maximum transfer rate outside the throttling window (Kbps)";Expression={$_.MaxTransferRateOffSchedule}}, @{Name="Maximum transfer rate during throttling window (Kbps)";Expression={$_.MaxTransferRateOnSchedule}}, Reserved1, Reserved2, Reserved3

	# Client Cache
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#client-cache-settings
	$SoftDistClientConfig = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_SoftwareDistributionClientConfig"
	$TombMinDuration = $SoftDistClientConfig.CacheTombstoneContentMinDuration
	$ClientCache = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_SuperPeerClientConfig" | Select-Object -Property @{Name="Enable BranchCache";Expression={$_.BranchCacheEnabled}}, @{Name="Configure BranchCache";Expression={$_.ConfigureBranchCache}}, @{Name="Maximum BranchCache cache size (percentage of disk)";Expression={$_.MaxBranchCacheSizePercent}}, @{Name="Minimum duration before the client can remove cached content (seconds)";Expression={$TombMinDuration}}, @{Name="Configure Client Cache Size";Expression={$_.ConfigureCacheSize}}, @{Name="Maximum cache size (MB)";Expression={$_.MaxCacheSizeMB}}, @{Name="Maximum cache size (percentage of disk)";Expression={$_.MaxCacheSizePercent}}, @{Name="Enable as peer cache source";Expression={$_.CanBeSuperPeer}}, @{Name="Port for initial network broadcast";Expression={$_.BroadcastPort}}, CachePartialContent, ComponentName, Enabled, HttpPort, HttpsEnabled, MaxAvgDiskQueueLength, MaxConnectionCountOnClients, MaxConnectionCountOnServers, MaxPercentProcessorTime, RejectWhenBatteryLow, Reserved1, Reserved2, Reserved3, SiteSettingsKey, UsePartialSource
	
	# Cloud Services
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#cloud-services
	$CloudServices = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_CloudClientConfig" | Select-Object -Property AADAuthFlags, AllowCloudDP, AllowCMG, AutoAADJoin, AutoMDMEnrollment, CoManagementFlags, ComponentName, Enabled, Reserved1, Reserved2, Reserved3, SiteSettingsKey
	
	# Computer Agent
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#computer-agent
	$ComputerAgent = Get-WmiObject -ErrorAction SilentlyContinue -ComputerName localhost -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class CCM_ClientAgentConfig | Select-Object -Property @{Name="Organization name displayed in Software Center"; Expression={$_.BrandingTitle}}, ComponentName, @{Name="Deployment deadline less than 24 hours, remind user every (seconds)"; Expression={$_.DayReminderInterval}}, DevicesHealthCollectionEnabled, @{Name="Show notifications for new deployments"; Expression={$_.DisplayNewProgramNotification}}, Enabled, EnableHealthAttestation, @{Name="Additional software manages the deployment of applications and software updates"; Expression={$_.EnableThirdPartyOrchestration}}, @{Name="Grace period for enforcement after deployment deadline (hours)"; Expression={$_.GracePeriodHours}}, @{Name="Deployment deadline less than 1 hour, remind user every (seconds)"; Expression={$_.HourReminderInterval}}, @{Name="Install permissions"; Expression={$_.InstallRestriction}}, OnPremHAServiceUrl, OSDBrandingSubTitle, @{Name="PowerShell Execution Polity";Expression={switch ($_.PowerShellExecutionPolicy) {0 {"0 - All Signed"}; 1 {"1 - Bypass"}; 2 {"2 - Restricted"}}}}, @{Name="Deployment deadline greater than 24 hours, remind user every (seconds)"; Expression={$_.ReminderInterval}}, Reserved1, Reserved2, Reserved3, SiteSettingsKey, SUMBrandingSubTitle, SuspendBitLocker, SWDBrandingSubTitle, SystemRestartTurnaroundTime, UseNewSoftwareCenter, UseOnPremHAService
	
	# Computer Restart
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/device-restart-notifications#client-settings
	$ComputerRestart = Get-WmiObject -ErrorAction SilentlyContinue -ComputerName localhost -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class CCM_RebootSettings | Select-Object -Property @{Name="Specify the frequency of reminder notifications to the user (minutes)"; Expression={$_.CountdownSnoozeInterval}}, @{Name="Configuration Manager can force a device to restart"; Expression={$_.NoEnforcement}}, @{Name="Specify the amount of time after the deadline before a device gets restarted (seconds)"; Expression={$_.RebootCountdown}}, @{Name="Specify the amount of time that a user is presented a final countdown notification before a device gets restarted (seconds)"; Expression={$_.RebootCountdownFinalWindow}}, @{Name="When a deployment requires a restart, show a dialog window to the user instead of a toast notification"; Expression={$_.RebootNotificationsDialog}}, @{Name="When a deployment requires a restart, allow low-rights users to restart a device running Windows Server";Expression={$_.LowRightsServerReboot}}, SiteSettingsKey
	
	# Delivery Optimization
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#delivery-optimization
	$DOpt = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\CCM\Policy\Machine\ActualConfig" -Class "CCM_WindowsDOClientConfig" | Select-Object -Property CollectDODownloadData, DODataCollectionInterval, Enabled, @{Name="Use Configuration Manager Boundary Groups for Delivery Optimization Group ID";Expression={$_.EnableWindowsDO}}, Reserved1, Reserved2, Reserved3, @{Name="Enable devices managed by Configuration Manager to use Delivery Optimization In-Network Cache servers for content download";Expression={$_.StampDOINC}}, SiteSettingsKey
	
	# Endpoint protection
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#endpoint-protection
	$EndProt = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_EndpointProtectionClientConfig" | Select-Object -Property Enabled, DisableFirstSignatureUpdate, @{Name="Manage Endpoint Protection client on client computers";Expression={$_.EnableEP}}, @{Name="Allowed period of time users can postpone a required restart to complete the Endpoint Protection installation (hours)";Expression={$_.ForceRebootPeriod}}, InstallRetryPeriod, @{Name="Install Endpoint Protection client on client computers";Expression={$_.InstallSCEPClient}}, @{Name="Allow Endpoint Protection client installation and restarts outside maintenance windows. Maintenance windows must be at least 30 minutes long for client installation";Expression={$_.OverrideMaintenanceWindow}}, @{Name="For Windows Embedded devices with write filters, commit Endpoint Protection client installation (requires restarts)";Expression={$_.PersistInstallation}}, PolicyEnforcePeriod, @{Name="Disable alternate sources (such as Microsoft Windows Update, Microsoft Windows Server Update Services, or UNC shares) for the initial security intelligence update on client computers";Expression={$_.Remove3rdParty}}, @{Name="Suppress any required computer restarts after the Endpoint Protection client is installed";Expression={$_.SuppressReboot}}, SiteSettingsKey
	
	# Hardware Inventory
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#hardware-inventory
	$HardInv = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_HardwareInventoryClientConfig" | Select-Object -Property Enabled, Reserved1, Reserved2, Reserved3, SiteSettingsKey
	
	# Metered Network
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#metered-internet-connections
	$MeteredNetwork = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_NetworkSettings" | Select-Object -Property @{Name="Client communication on metered internet connections";Expression={Interprete-MeteredNetworkUsage($_.MeteredNetworkUsage)}}, Reserved, SiteSettingsKey
	
	# Software Center
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#software-center
	$SoftC = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class "CCM_SoftwareCenterClientConfig" | Select-Object -Property ComponentName, Enabled, SCBrandingColor, SCBrandingString, SCLogo, SCShowApplicationsTab, SCShowComplianceTab, SCShowInstallationTab, SCShowOptionsTab, SCShowOSDTab, SCShowUpdatesTab, @{Name="Select these new settings to specify company information";Expression={$_.SCUseOldBranding}}, @{Name="Select the user portal";Expression={$_.SCUserPortal}}, @{Name="Software Center settings";Expression={Format-XML($_.SettingsXml)}},SiteSettingsKey
	
	# Software Updates
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#software-updates
	$SoftwareUpdates = Get-WmiObject -ErrorAction SilentlyContinue -ComputerName localhost -Namespace "ROOT\ccm\Policy\Machine\ActualConfig" -Class CCM_SoftwareUpdatesClientConfig | Select-Object -Property ComponentName, @{Name="Enable software updates on clients"; Expression={$_.Enabled}}, @{Name="Enable Dynamic Update for feature updates"; Expression={$_.DynamicUpdateOption}}, @{Name="Allow clients to download delta content when available"; Expression={$_.EnableExpressUpdates}}, @{Name="Enable third party software updates"; Expression={$_.EnableThirdPartyUpdates}}, @{Name="Port that clients use to receive requests for delta content"; Expression={$_.ExpressUpdatesPort}}, @{Name="Software update scan schedule";Expression={$_."Scan Schedule"}}, @{Name="Schedule deployment re-evaluation";Expression={$_.EvaluationSchedule}}, @{Name="Enforce TLS certificate pinning for Windows Update client for detecting updates";Expression={$_.EnableWSUSCertPinning}}, @{Name="Allow user proxy for software update scans";Expression={$_.WUAUserProxy}}, @{Name="If content is unavailable from distribution points in the current boundary group, immediately fallback to a neighbor or the site default";Expression={$_.DeltaDPFallback}}, @{Name="Enable management of the Office 365 Client Agent";Expression={"Refer to Reserved2"}}, @{Name="Enable update notifications from Microsoft 365 Apps";Expression={$_.EnableO365UpdateNotification}}, ExpressVersion, ContentDownloadTimeout, ContentLocationTimeout, DayReminderInterval, GroupPolicyNotificationTimeout, HourReminderInterval, MaxScanRetryCount, @{Name="Specify thread priority for feature updates";Expression={$_.NEOPriorityOption}}, PerDPInactivityTimeout, ReminderInterval, WUfBEnabled, Reserved1, @{Name="Reserved2";Expression={Format-XML($_.Reserved2)}}, Reserved3, ScanRetryDelay, @{Name="Enable installation of software updates in All deployments maintenance window when Software Update maintenance window is available";Expression={$_.ServiceWindowManagement}}, SiteSettingsKey, WSUSLocationTimeout, AssignmentBatchingTimeout, BrandingTitle, BrandingSubTitle, UserJobPerDPInactivityTimeout, UserJobTotalInactivityTimeout, TotalInactivityTimeout
	
	# User and Device Affinity
	# https://docs.microsoft.com/en-us/mem/configmgr/core/clients/deploy/about-client-settings#user-and-device-affinity
	$UserDevAff = Get-WmiObject -ErrorAction SilentlyContinue -Namespace "ROOT\CCM\Policy\Machine\ActualConfig" -Class "CCM_TargetingSettings" | Select-Object -Property @{Name="Allow user to define their primary devices";Expression={$_.AllowUserAffinity}}, AllowUserAffinityAfterMinutes, @{Name="Automatically configure user device affinity from usage data";Expression={$_.AutoApproveAffinity}}, ComponentName, @{Name="User device affinity usage threshold (minutes)";Expression={$_.ConsoleMinutes}}, Enabled, @{Name="User device affinity usage threshold (days)";Expression={$_.IntervalDays}}, Reserved1, Reserved2, Reserved3, SiteSettingsKey
	
	While ($True) {
		Print-LeadingSymbol(">>[Client Settings]");$Condition = Read-Host -Prompt "[Enter your options (?: Show options; Q:exit) > ]"
		$Condition = $Condition.Trim()
		if ($Condition -eq "?") {Print-Menu -Menu $CLSetOptions -Title "Options" -BgColr "Blue"; Continue}
		if ($Condition -eq "Q") { break }
		
		if ($Condition -and ($Condition -in $CLSetOptions.Keys)) {
			$SubSecHeader = $CLSetOptions[$Condition]['desc'] + " - " + $CLSetOptions[$Condition]['loc']
			Print-SubSectionHeader($SubSecHeader)
			switch ($Condition) {
				"bits"  { $BITS }
				"cache" { $ClientCache }
				"cloud" { $CloudServices }
				"agent" { $ComputerAgent }
				"rest"  { $ComputerRestart }
				"dopt"  { $DOpt }
				"endpt" { $EndProt }
				"hiv"   { $HardInv }
				"mnet"  { $MeteredNetwork }
				"softc" { $SoftC }
				"upd"   { $SoftwareUpdates }
				"usrda" { $UserDevAff }
			}
		}
	}
}

#####################################################################################################
# Get Windows Update History
# Modified based on https://gallery.technet.microsoft.com/scriptcenter/Show-Windows-Update-c7ee69bd
#####################################################################################################
Function Query-WUHist {
	# Overview goes here - Start
	Print-SectionHeader("Updates History")
	# Get all deployed updates
	$objSession = new-object -com "Microsoft.Update.Session" 
	$objSearcher = $objSession.CreateupdateSearcher() 
	$intCount = $objSearcher.GetTotalHistoryCount() # Total update history count
	$colHistory = $objSearcher.QueryHistory(0, $intCount)
	$colHistory = $colHistory | Select-Object -Property Title, @{Label = "HResult"; Expression = {$_.HResult}} , @{Label = "Status"; Expression = {if ($_.HResult -eq 0) {return "Successfully installed"} elseif ($_.HResult -eq -2145116140) {return "Pending Reboot"} else {if (($_.Date).AddMonths(1) -gt (Get-Date)) {return "Failed to install (Error:" + $($_.HResult).ToString('X8') + ")"}}}}, @{Label = "Installation Date (GMT)"; Expression = {$_.Date}}, Description, ClientApplicationID, ServiceID, SupportURL
	$TotalWUHistCount = ($colHistory | Measure-Object | Select-Object).Count

	# Overview of windows updates history
	Print-Overview("You have $TotalWUHistCount updates (only the first 10 results will be listed. To display all results, hit Enter key.):")
	$Idx = 1; $colHistory | Select-Object -First 10 | foreach {$Title = $_.Title; $HResult = $_.HResult; $Status = $_.Status; $InstDate = $_."Installation Date (GMT)"; $ClnAppID = $_.ClientApplicationID; $Index = Format-Width -Str ${Idx} -Width "${TotalWUHistCount}".length; Write-Output "${Index}: Title: $Title HResult: $HResult Status: $Status InstallDate: $InstDate ClientAppID: $ClnAppID"; $Idx = $Idx + 1 }
	# Overview goes here - End
	
	While ($True) {
		Print-LeadingSymbol(">>[Updates History]")
		$Condition = Read-Host -Prompt "[Enter KBNumber, update name to search (Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		
		if ($Condition) {
			switch ($Condition) {
				"dpL" { Query-Deployments }
				"upd" { Query-Updates }
				Default 
				{
					# Search for updates based on $Condition. If $Condition is ?  all results will be returned.
					$QueriedUpdates = $colHistory | Where-Object { $_.Title -like "*$Condition*" }
					$QueriedUpdCount = ($QueriedUpdates | Measure-Object | Select-Object).Count
					Print-CmdMessage("Found $QueriedUpdCount result >>") -Delim 1
					$Index = 1; $QueriedUpdates | foreach { Print-CmdMessage("< Result $Index > "); $_; $Index += 1 }
					Print-CmdMessage("Found $QueriedUpdCount result <<")
				}
			}
		} else { # Show all updates history if confirmed
			$Answer = Read-Host -Prompt "[List ALL $TotalWUHistCount updates history? Yes to confirm; No to cancel > ]"
			if ($Answer -ne "Yes") { "Cancelled listing all updates history.";Continue }
			Print-CmdMessage("Displaying Updates History ($TotalWUHistCount) >>") -Delim 1
			$Idx = 1; $colHistory | foreach {$Title = $_.Title; $HResult = $_.HResult; $Status = $_.Status; $InstDate = $_."Installation Date (GMT)"; $ClnAppID = $_.ClientApplicationID; $Index = Format-Width -Str ${Idx} -Width "${TotalWUHistCount}".length; Write-Output "${Index}: Title: $Title HResult: $HResult Status: $Status InstallDate: $InstDate ClientAppID: $ClnAppID"; $Idx = $Idx + 1 } | Out-Host -Paging
			Print-CmdMessage("Displayed Updates History ($TotalWUHistCount) <<")
		}
	}
}

##################################################################
# Display Software Update Point information and last scan history
##################################################################
Function Print-SoftwareUpdatePoint {
	Print-SectionHeader("Sofware Update Point")
	# SUP Info
	Print-SubSectionHeader("ROOT\ccm\ScanAgent:CCM_SUPLocationList")
	$SUPInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\ScanAgent" -Class CCM_SUPLocationList | Select-Object CurrentScanPath, FirstScanFailTime, KeepSupAffinity, LastSuccessScanPath, ScanMethod, StartOver, SUPLocations
	$SUPInfo
	
	# Last scan history
	Print-SubSectionHeader("ROOT\ccm\ScanAgent:CCM_ScanUpdateSourceHistory")
	$SUPScanHistInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\ScanAgent" -Class CCM_ScanUpdateSourceHistory | Select-Object UpdateSourceID, UpdateSourceVersion, ScanMethod, @{Name="LastCompletionTime (GMT)"; Expression={($_.LastCompletionTime.SubString(0,4), $_.LastCompletionTime.SubString(4,2),$_.LastCompletionTime.SubString(6,2), $_.LastCompletionTime.SubString(8,2), $_.LastCompletionTime.SubString(10,2), $_.LastCompletionTime.SubString(12)) -join "-"}}, ScanContentType, ChangeSUP, Valid, ValidTTL, PerformedCatScanLast
	$SUPScanHistInfo
}

# Display certificates in MY, ROOT, SMS store
Function Query-Certificates {
	# Overview goes here -  Start
	Print-SectionHeader("Certificates")
	
	# Stores: Root, MY, SMS
	$Stores = @('ROOT','MY','SMS')
	Foreach ($Store in $Stores) {
		Print-SubSectionHeader("$Store")
		# Get certs in Stores
		$Certs = $(Get-ChildItem -Path "Cert:\LocalMachine\${Store}")
		$CertsCount = ($Certs | Measure-Object | Select-Object).Count
		
		Print-Overview("You have $CertsCount certificates in $Store (only the first 10 results will be listed. To display all results, enter $Store.):")
		$Idx = 1; $Certs | Select-Object -First 10 | foreach {$ThumbID = $_.Thumbprint; $Subject = $_.Subject; $FrdName = $_.FriendlyName; $NotAft = $_.NotAfter; $NotBef = $_.NotBefore; $Index = Format-Width -Str ${Idx} -Width "${CertsCount}".length; Write-Output "${Index}: Thumbprint: $ThumbID NotAfter: $NotAft NotBefore: $NotBef Subject: $Subject FriendlyName: $FrdName"; $Idx = $Idx + 1 }
	}
	
	While ($True) {
		Print-LeadingSymbol(">>[Certificates]")
		$Condition = Read-Host -Prompt "[Enter Subject, Thumbprint, FriendlyName to search (E: export certificates; Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		if ($Condition) {
			if ($Condition -in $Stores) { # If $Condition is in Root, MY, SMS, try to list certificates in the store and continue the loop
				$Certs = $(Get-ChildItem -Path "Cert:\LocalMachine\$Condition")
				$CertsCount = ($Certs | Measure-Object | Select-Object).Count
				$Answer = Read-Host -Prompt "[List ALL $CertsCount $Condition certificates? Yes to confirm; No to cancel > ]"
				if ($Answer -ne "Yes") { "Cancelled listing all $Condition certificates.";Continue }
				Print-CmdMessage("Displaying $Condition certificates ($CertsCount): Cert:\LocalMachine\$Condition >>") -Delim 1
				$Idx = 1; $Certs | foreach {$ThumbID = $_.Thumbprint; $Subject = $_.Subject; $FrdName = $_.FriendlyName; $NotAft = $_.NotAfter; $NotBef = $_.NotBefore; $Index = Format-Width -Str ${Idx} -Width "${CertsCount}".length; Write-Output "${Index}: Thumbprint: $ThumbID NotAfter: $NotAft NotBefore: $NotBef Subject: $Subject FriendlyName: $FrdName"; $Idx = $Idx + 1 } | Out-Host -Paging
				Print-CmdMessage("Displayed $Condition certificates ($CertsCount): Cert:\LocalMachine\$Condition <<")
				
				Continue # Continue the loop
			}
			# Otherwise, proceed with the following branch.
			switch ($Condition) {
				"E" { Print-CmdMessage("Exporting certificates in ROOT, MY, SMS stores..."); Export-Certs; Print-CmdMessage("Certificates exported.") }
				"opendestdir" { Invoke-Item -ErrorAction SilentlyContinue . }
				Default {
					# Search for certificates based on $Condition. If $Condition is ?  all results will be returned.
					$StoresStr = $Stores -join ", "
					Print-CmdMessage("Searching in $StoresStr ...")
					foreach ($Store in $Stores) {
						$Certs = $(Get-ChildItem -Path "Cert:\LocalMachine\${Store}")
						$QueriedCerts = $Certs | Where-Object { ($_.Thumbprint -like "*$Condition*") -or ($_.Subject -like "*$Condition*") -or ($_.FriendlyName -like "*$Condition*") }
						if(! ($QueriedCerts)) { Continue } # If no result in the current, continue
						$QueriedCertsCount = ($QueriedCerts | Measure-Object | Select-Object).Count
						Print-CmdMessage("$Store store > Found $QueriedCertsCount result >>") -Delim 1
						$Index = 1; $QueriedCerts | Select-Object -Property * | foreach { Print-CmdMessage("< Result $Index > "); $_; $Index += 1 }
						Print-CmdMessage("$Store store > Found $QueriedCertsCount result <<")
						Write-Host "`n"
					}
					Print-CmdMessage("Searching in $StoresStr completed.")
				}
			}
		}
	}
}

#########################
# Display service windows
#########################
Function Print-ServiceWindow {
	Print-SectionHeader("Service Window")
	$SVCWinInfo = Get-WmiObject -ErrorAction SilentlyContinue  -Namespace "ROOT\ccm\ClientSDK:CCM_ServiceWindow" -Class CCM_ServiceWindow | Select-Object @{Name="StartTime"; Expression={($_.StartTime.SubString(0,4), $_.StartTime.SubString(4,2),$_.StartTime.SubString(6,2), $_.StartTime.SubString(8,2), $_.StartTime.SubString(10,2), $_.StartTime.SubString(12)) -join "-"}}, @{Name="EndTime"; Expression={($_.EndTime.SubString(0,4), $_.EndTime.SubString(4,2),$_.EndTime.SubString(6,2), $_.EndTime.SubString(8,2), $_.EndTime.SubString(10,2), $_.EndTime.SubString(12)) -join "-"}}, Duration, @{Name="Type";Expression={Interprete-ServiceWindowType($_.Type)}}, ID
	Print-SubSectionHeader("ROOT\ccm\ClientSDK:CCM_ServiceWindow:CCM_ServiceWindow")
	$SVCWinInfo
}



###########################
# Print main menu
###########################
Function Print-MainMenu {
	Print-Menu -Menu $MainMenu -Title "Usage" -BgColr "Black"
	Write-Host "`n@ Note: You can also enter whatever PowerShell or batch command, eg. `n  Get-Service | Where-Object {`$_.Status -eq 'Stopped'}`n  tasklist`n  Services.msc"
	#Write-Host "+------------------------------------------------------------------------------------------------------------------+" -ForegroundColor Cyan
}

# Enter the mode of enabling/disbling verbose logging
Function Enter-VLogSetting {
	Print-SectionHeader("CCM Verbose Logging")
	While ($True) {
		Print-LeadingSymbol(">>[CCM Verbose Logging]")
		$Condition = Read-Host -Prompt "[Enter your option (A: Enable verbose logging; D: Disable verbose logging; Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		switch ($Condition) {
			"A"       { Configure-Verbose -AV; Print-CmdMessage("CCM verbose logging enabled.") }
			"D"       { Configure-Verbose -DV; Print-CmdMessage("CCM verbose logging disabled.") }
			"regedit" {cmd.exe /c regedit }
		}
	}
}

# Capture network trace with netsh trace
Function Enter-NetCapture {
	Print-SectionHeader("Network Capture")
	While ($True) {
		Print-LeadingSymbol(">>[Network Capture]")
		$Condition = Read-Host -Prompt "[Enter your option (st: Start capture; sp: Stop capture; Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		switch ($Condition) {
			"st" { Print-CmdMessage("Network trace starting...."); Capture-NetworkTrace; Print-CmdMessage("Network trace started.") }
			"sp"  { Print-CmdMessage("Network trace stopping..."); Capture-NetworkTrace -Stop; Print-CmdMessage("Network trace stopped.") }
		}
	}
}

# Get reboot history
Function Print-RebootHistory {
	Print-SectionHeader("Reboot History")
	$Res = Get-WinEvent -FilterHashtable @{logname='System'; id=(1074, 6005, 6006, 6008)}  | ForEach-Object {
		$rv = New-Object PSObject | Select-Object Date, User, Action, Process, Reason, ReasonCode, Comment, Message
		$rv.Date = $_.TimeCreated # This is local time
		$rv.User = $_.Properties[6].Value
		$rv.Process = $_.Properties[0].Value
		$rv.Action = $_.Properties[4].Value
		$rv.Reason = $_.Properties[2].Value
		$rv.ReasonCode = $_.Properties[3].Value
		$rv.Comment = $_.Properties[5].Value
		$rv.Message = $_.Message
		$rv
	}
	$RbHisCount = ($Res | Measure-Object | Select-Object).Count
	Print-SubSectionHeader("System Event Log")
	Print-CmdMessage("Found $RbHisCount reboot history >>") -Delim 1
	$Res | Out-Host -Paging
	Print-CmdMessage("Found $RbHisCount reboot history <<")
}

# Verify if ccm is installed
Function IsCCMInstalled {
	# Check if CcmExec service is still there. If yes, that indicates CCM is still installed.
	$CcmExecSvc = Get-Service -ErrorAction SilentlyContinue CcmExec
	# Check if ROOT\ccm wmi namespace exists. If yes, that means CcmExec has not yet been uninstalled.
	$CcmWmiNsp = Get-WMIObject -Class "__Namespace" -Namespace Root | Where-Object {$_.Name -eq "ccm"}
	Return ($CcmExecSvc -and $CcmWmiNsp)
}

# Uninstall CCM and Remove registry and folders
Function Remove-AgentInfo {
	# Ask for confirmation to proceed with ccm uninstall
	$Answer = Read-Host -Prompt "[Are you sure to uninstall Configuration Manager Client? Yes to confirm; No to cancel > ]"
	if ($Answer -ne "Yes") { "Cancelled uninstalling Configuration Manager Client."; break} else {"Proceed to uninstall Configuration Manager Client."}
	# Uninstall sms agent
	if (IsCCMInstalled) {
		if (Test-Path 'C:\Windows\ccmsetup\ccmsetup.exe') {
			Print-CmdMessage("Uninstalling Configurationi Manager Client...")
			Print-CmdMessage("This can take a while. Please be patient.")
			Invoke-Expression 'C:\Windows\ccmsetup\ccmsetup.exe /uninstall'
			Start-Sleep -Seconds 10
			# Check if uninstall process Ccmsetup.exe is still running. Wait-Process can also be used: Wait-Process -Name ccmsetup
			#$Running = Get-Process | Where-Object{$_.ProcessName -eq "ccmsetup"} 
			#While ($Running) {Start-Sleep -Seconds 1; $Running = Get-Process | Where-Object{$_.ProcessName -eq "ccmsetup"}}
			Wait-Process -Name ccmsetup
			Start-Sleep -Seconds 60 # Wait for 1 minutes for the process to stop completely
			Print-CmdMessage("Uninstalled Configurationi Manager Client.")
		} else {
			Print-WarningMessage("C:\Windows\ccmsetup\ccmsetup.exe doesn't exist. Uninstall it manually and try again this option to clean up remnant information.")
			break
		}
	}
	
	# Check again if ROOT\ccm wmi namespace exists. If yes, that means CcmExec has not yet been uninstalled.
	if (IsCCMInstalled) {
		Print-WarningMessage("Make sure Configuration Manager Client has been uninstalled before trying to remove its remnant information.")
		Print-CmdMessage("If Configuration Manager Client has been uninstalled, reboot your computer.")
		break
	}
	# Start removing remnant information
	Print-CmdMessage("Starting to clean up Configuration Manager Client folders and registry..."); Start-Sleep -Seconds 5
	Stop-Service bits
	if (Test-Path "C:\Windows\ccm") {Remove-Item "C:\Windows\ccm" -Exclude "C:\Windows\CCM\ScriptStore" -Recurse -Force -Confirm:$false -Verbose}
	if (Test-Path "C:\Windows\ccmsetup") {Remove-Item "C:\Windows\ccmsetup" -Recurse -Force -Confirm:$false -Verbose}
	if (Test-Path "C:\Windows\ccmcache") {Remove-Item "C:\Windows\ccmcache" -Recurse -Force -Confirm:$false -Verbose}
	if (Test-Path "C:\Windows\smscfg.ini") {Remove-Item "C:\Windows\smscfg.ini" -Force -Confirm:$false -Verbose}
	if (Test-Path "Cert:LocalMachine\SMS") {Get-ChildItem "Cert:LocalMachine\SMS" | Remove-Item -Recurse -Force -Confirm:$false -Verbose}
	if (Test-Path "HKLM:\Software\Microsoft\SystemCertificates\SMS\Certificates") {Remove-Item -Path 'HKLM:\Software\Microsoft\SystemCertificates\SMS\Certificates\*' -Force -Confirm:$false -Verbose}
	if (Test-Path "C:\Windows\sms*.mif") {Remove-Item "C:\Windows\sms*.mif" -Force -Confirm:$false -Verbose}
	if (Test-Path "HKLM\software\Microsoft\ccm") {Remove-Item -Path "Registry::HKLM\software\Microsoft\ccm" -Recurse -Force -Confirm:$false -Verbose}
	if (Test-Path "HKLM\software\Microsoft\CCMSETUP") {Remove-Item -Path "Registry::HKLM\software\Microsoft\CCMSETUP" -Recurse -Force -Confirm:$false -Verbose}
	if (Test-Path "HKLM\software\Microsoft\SMS") {Remove-Item -Path "Registry::HKLM\software\Microsoft\SMS" -Recurse -Force -Confirm:$false -Verbose}

	# Remove the service from "Services"
	if (Test-Path "HKLM:\SYSTEM\CurrentControlSet\Services\CcmExec") {Remove-Item -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\CcmExec' -Force -Recurse -Confirm:$false -Verbose}
	if (Test-Path "HKLM:\SYSTEM\CurrentControlSet\Services\ccmsetup") {Remove-Item -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\ccmsetup' -Force -Recurse -Confirm:$false -Verbose}

	Get-WmiObject -query "SELECT * FROM __Namespace WHERE Name='CCM'" -Namespace "Root" | Remove-WmiObject -Verbose
	Get-WmiObject -query "SELECT * FROM __Namespace WHERE Name='sms'" -Namespace "root\cimv2" | Remove-WmiObject -Verbose
	Get-WmiObject -query "Select * From __Namespace Where Name='CCMVDI'" -Namespace "root" | Remove-WmiObject -Verbose
	Get-WmiObject -query "Select * From __Namespace Where Name='SmsDm'" -Namespace "root" | Remove-WmiObject -Verbose
	
	# Remove scheduled tasks
	If ( Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\Microsoft\Configuration Manager" ) {
		$TS = New-Object -ComObject Schedule.Service
		$TS.Connect($env:COMPUTERNAME)
		$TaskFolder = $TS.GetFolder("\Microsoft\Configuration Manager")
		$Tasks = $TaskFolder.GetTasks(1)
		foreach($Task in $Tasks){ $TaskFolder.DeleteTask($Task.Name,0) } 
	} 
	Start-Service bits
	Print-CmdMessage("Cleanup of Configuration Manager Client folders and registry completed.")
}

# Remove stuck jobs
Function Remove-StuckJobs {
	# Ask for confirmation to proceed with stuck jobs removal
	$Answer = Read-Host -Prompt "[Proceed with stuck jobs removal? Yes to confirm; No to cancel > ]"
	if ($Answer -ne "Yes") { "Cancelled removal of stuck jobs."; break} else {"Proceed to remove stuck jobs."}
	# Stop CcmExec
	Print-CmdMessage("Stopping CcmExec...")
	Stop-Service CcmExec
	Wait-Process -Name CcmExec
	Print-CmdMessage("CcmExec service stopped.")

	# Remove jobs
	Print-CmdMessage("Removing stuck application CI tasks..")
	Get-WmiObject -Namespace "Root\CCM" -Class SMS_MaintenanceTaskRequests | Remove-WmiObject -Verbose
	Get-WmiObject -Namespace "Root\CCM\xmlstore" -Class xmldocument | Remove-WmiObject -Verbose
	Get-WmiObject -Namespace "Root\CCM\CITasks" -Class CCM_CITask | Remove-WmiObject -Verbose
	Print-CmdMessage("Removing stuck application CI tasks completed.")

	Print-CmdMessage("Removing stuck update jobs...")
	Get-WmiObject -Namespace "Root\CCM\SoftwareUpdates\DeploymentAgent" -Class CCM_AssignmentJobEx1 | Remove-WmiObject -Verbose
	Get-WmiObject -Namespace "Root\CCM\SoftwareUpdates\DeploymentAgent" -Class CCM_UpdatesJob | Remove-WmiObject -Verbose
	Get-WmiObject -Namespace "Root\CCM\DataTransferService" -Class CCM_DTS_JobEx | Remove-WmiObject -Verbose
	Get-WmiObject -Namespace "Root\CCM\DataTransferService" -Class CCM_DTS_JobItemEx | Remove-WmiObject -Verbose
	Print-CmdMessage("Removing stuck update jobs completed.")

	Print-CmdMessage("Starting ccmexec service...")
	Start-Service CcmExec
	While ((Get-Service -Name CcmExec).Status -ne "Running") {Continue}
	Print-CmdMessage("CcmExec service started.")
}

# Reset Windows Update Component
# Only applies to Windows 10 and later, including Windows Server 2016 and later
Function Reset-WUComponent {
	# Ask for confirmation to proceed with Windows Update Component reset
	Print-CmdMessage("Note that this action only applies to Windows 10 and later, including Windows Server 2016 and newer.")
	$Answer = Read-Host -Prompt "[Preceed to reset Windows Update Component? Yes to confirm; No to cancel > ]"
	if ($Answer -ne "Yes") { "Cancelled resetting Windows Update Component."; break} else {"Proceed to reset Windows Update Component."}
$Script = @"
@ECHO OFF
Title Reset Windows Update Component
echo .
echo Simple Script to reset Windows updates components - credits to Shawn Brink for the commands.
echo .
PAUSE
echo .
set b=0

:bits
set /a b=%b%+1
if %b% equ 3 (
   goto end1
) 
net stop bits
echo Checking the bits service status.
sc query bits | findstr /I /C:"STOPPED" 
if not %errorlevel%==0 ( 
    goto bits 
) 
goto loop2

:end1
cls
echo.
echo Failed to reset Windows Update due to bits service failing to stop
echo Please run the script as administartor by right clicking the WuReset file or your BITS service isn't responding.
echo.
pause
goto Start


:loop2
set w=0

:wuauserv
set /a w=%w%+1
if %w% equ 3 (
   goto end2
) 
net stop wuauserv
echo Checking the wuauserv service status.
sc query wuauserv | findstr /I /C:"STOPPED" 
if not %errorlevel%==0 ( 
    goto wuauserv 
) 
goto loop3

:end2
cls
echo.
echo Failed to reset Windows Update due to wuauserv service failing to stop.
echo.
pause
goto Start



:loop3
set app=0

:appidsvc
set /a app=%app%+1
if %app% equ 3 (
   goto end3
) 
net stop appidsvc
echo Checking the appidsvc service status.
sc query appidsvc | findstr /I /C:"STOPPED" 
if not %errorlevel%==0 ( 
    goto appidsvc 
) 
goto loop4

:end3
cls
echo.
echo Failed to reset Windows Update due to appidsvc service failing to stop.
echo.
pause
goto Start


:loop4
set c=0

:cryptsvc
set /a c=%c%+1
if %c% equ 3 (
   goto end4
) 
net stop cryptsvc
echo Checking the cryptsvc service status.
sc query cryptsvc | findstr /I /C:"STOPPED" 
if not %errorlevel%==0 ( 
    goto cryptsvc 
) 
goto Reset

:end4
cls
echo.
echo Failed to reset Windows Update due to cryptsvc service failing to stop.
echo.
pause
goto Start


:Reset
Ipconfig /flushdns
del /s /q /f "%ALLUSERSPROFILE%\Microsoft\Network\Downloader\qmgr*.dat"
del /s /q /f "%ALLUSERSPROFILE%\Application Data\Microsoft\Network\Downloader\qmgr*.dat" 



cd /d %windir%\system32

if exist "%SYSTEMROOT%\winsxs\pending.xml.bak" del /s /q /f "%SYSTEMROOT%\winsxs\pending.xml.bak" 
if exist "%SYSTEMROOT%\winsxs\pending.xml" ( 
    takeown /f "%SYSTEMROOT%\winsxs\pending.xml" 
    attrib -r -s -h /s /d "%SYSTEMROOT%\winsxs\pending.xml" 
    ren "%SYSTEMROOT%\winsxs\pending.xml" pending.xml.bak 
) 
  
if exist "%SYSTEMROOT%\SoftwareDistribution.bak" rmdir /s /q "%SYSTEMROOT%\SoftwareDistribution.bak"
if exist "%SYSTEMROOT%\SoftwareDistribution" ( 
    attrib -r -s -h /s /d "%SYSTEMROOT%\SoftwareDistribution" 
    ren "%SYSTEMROOT%\SoftwareDistribution" SoftwareDistribution.bak 
) 
 
if exist "%SYSTEMROOT%\system32\Catroot2.bak" rmdir /s /q "%SYSTEMROOT%\system32\Catroot2.bak" 
if exist "%SYSTEMROOT%\system32\Catroot2" ( 
    attrib -r -s -h /s /d "%SYSTEMROOT%\system32\Catroot2" 
    ren "%SYSTEMROOT%\system32\Catroot2" Catroot2.bak 
) 
  
if exist "%SYSTEMROOT%\WindowsUpdate.log.bak" del /s /q /f "%SYSTEMROOT%\WindowsUpdate.log.bak" 
if exist "%SYSTEMROOT%\WindowsUpdate.log" ( 
    attrib -r -s -h /s /d "%SYSTEMROOT%\WindowsUpdate.log" 
    ren "%SYSTEMROOT%\WindowsUpdate.log" WindowsUpdate.log.bak 
) 
  
sc.exe sdset bits D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;AU)(A;;CCLCSWRPWPDTLOCRRC;;;PU)
sc.exe sdset wuauserv D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;AU)(A;;CCLCSWRPWPDTLOCRRC;;;PU)

regsvr32.exe /s atl.dll 
regsvr32.exe /s urlmon.dll 
regsvr32.exe /s mshtml.dll 
regsvr32.exe /s shdocvw.dll 
regsvr32.exe /s browseui.dll 
regsvr32.exe /s jscript.dll 
regsvr32.exe /s vbscript.dll 
regsvr32.exe /s scrrun.dll 
regsvr32.exe /s msxml.dll 
regsvr32.exe /s msxml3.dll 
regsvr32.exe /s msxml6.dll 
regsvr32.exe /s actxprxy.dll 
regsvr32.exe /s softpub.dll 
regsvr32.exe /s wintrust.dll 
regsvr32.exe /s dssenh.dll 
regsvr32.exe /s rsaenh.dll 
regsvr32.exe /s gpkcsp.dll 
regsvr32.exe /s sccbase.dll 
regsvr32.exe /s slbcsp.dll 
regsvr32.exe /s cryptdlg.dll 
regsvr32.exe /s oleaut32.dll 
regsvr32.exe /s ole32.dll 
regsvr32.exe /s shell32.dll 
regsvr32.exe /s initpki.dll 
regsvr32.exe /s wuapi.dll 
regsvr32.exe /s wuaueng.dll 
regsvr32.exe /s wuaueng1.dll 
regsvr32.exe /s wucltui.dll 
regsvr32.exe /s wups.dll 
regsvr32.exe /s wups2.dll 
regsvr32.exe /s wuweb.dll 
regsvr32.exe /s qmgr.dll 
regsvr32.exe /s qmgrprxy.dll 
regsvr32.exe /s wucltux.dll 
regsvr32.exe /s muweb.dll 
regsvr32.exe /s wuwebv.dll
regsvr32 /s wudriver.dll
netsh winsock reset
netsh winsock reset proxy

:Start
net start bits
net start wuauserv
net start appidsvc
net start cryptsvc
echo Task completed sucessfully!Please restart your computer and check for the updates again.
PAUSE
"@

	# Create a temp bat file in temp directory
	$Script | Out-File -Encoding 'ascii' $Env:Temp\ResetWUComponent10.bat
	# Launch a new cmd process to run the bat file
	Start-Process PowerShell -ArgumentList "cmd.exe /c $Env:Temp\ResetWUComponent10.bat"

}

# Windows update verbose. Applies only to Windows 10 or later, including Windows Server 2016 or newer.
Function Configure-WUVerbose {
	Param( 
		[Parameter(Mandatory = $false, ParameterSetName = 'Start')][Switch] $Start,
		[Parameter(Mandatory = $false, ParameterSetName = 'Stop')][Switch] $Stop
	)
$Script = @'
@echo off
Title Configure Windows Update Verbose Logging
setlocal

if "%~1"=="" (
    goto USAGE
)

if "%~1"=="/?" (
    goto USAGE
)

REM Check for admin permission
FOR /f "usebackq" %%f IN (`whoami /priv`) DO IF "%%f"=="SeTakeOwnershipPrivilege" GOTO :IS_ADMIN
ECHO CreateObject("Shell.Application").ShellExecute Chr(34) ^& "%WINDIR%\System32\cmd.exe" ^& Chr(34), "/K " ^& Chr(34) ^& "%~dpfx0 %*" ^& Chr(34), "", "runas", 1 >"%TEMP%\RunAs.vbs"
WScript.exe "%TEMP%\RunAs.vbs"
pause
GOTO :EOF

:IS_ADMIN
set _ETLPATH=%systemdrive%\WindowsUpdateVerbose.etl
set _TRACEREGKEY=HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Trace
set _TRACEREGVALUE=WPPLogDisabled

REM OS Version checks
for /f "skip=1 tokens=2 delims=[]" %%G in ('ver') Do (
  for /f "tokens=2,3,4 delims=. " %%x in ("%%G") Do (
    set _major=%%x& set _minor=%%y& set _build=%%z 
  )
)

IF %_major% LSS 10 (
    echo This script is for Windows 10 or later only.
    pause		
    goto :EOF
)

:ARGLOOP
if /I "%~1"=="/start" (
    echo Starting verbose tracing for Windows Update Agent ...
    goto START
    
) else if /I "%~1"=="/stop" (
    echo Stopping verbose tracing ...
    goto STOP   
)

shift
goto ARGLOOP

:START
@echo.
reg add %_TRACEREGKEY% /v %_TRACEREGVALUE% /d 1 /t REG_DWORD /f
net stop usosvc
net stop wuauserv
logman start WindowsUpdateLOGPS1 -ets -o %_ETLPATH% -ft 00:00:05 -nb 2 24 -bs 128 -p {0b7a6f19-47c4-454e-8c5c-e868d637e4d8} 8380415 5

@echo.
echo Verbose tracing will be output to: %_ETLPATH%.
echo Make sure to run %~nx0 /stop later.
pause
goto :EOF

:STOP
@echo.
reg delete %_TRACEREGKEY% /v %_TRACEREGVALUE% /f
net stop usosvc
net stop wuauserv
logman stop WindowsUpdateLOGPS1 -ets

@echo.
echo Done! Verbose ETL file is at %_ETLPATH%
pause
goto :EOF

:USAGE
@echo.
echo %~nx0 [/start] [/stop]
@echo.
echo Enable verbose Windows Update Agent tracing on Windows 10.
@echo.
echo Options:
echo    /start    Start verbose tracing.
echo    /stop     Stop and flush verbose tracing.
@echo.
pause
goto :EOF
'@

	# Create a temp bat file in temp directory
	$Script | Out-File -Encoding 'ascii' $Env:Temp\VerboseWin10.bat
	# Launch a new cmd process to run the bat file
	if ($Start) {Start-Process PowerShell -ArgumentList "cmd.exe /c $Env:Temp\VerboseWin10.bat /Start"}
	if ($Stop)  {Start-Process PowerShell -ArgumentList "cmd.exe /c $Env:Temp\VerboseWin10.bat /Stop"}

}

# Enter the interface to configure Windows Update verbose logging
Function Enter-ConfigureWUVerbose {
	Print-SectionHeader("Configure Windows Update Verbose Logging")
	While ($True) {
		Print-LeadingSymbol(">>[Windows Update Verbose Logging]")
		$Condition = Read-Host -Prompt "[Enter your option (st: Enable verbose logging; sp: Disable verbose logging; Q:exit) > ]" 
		$Condition = $Condition.Trim()
		if ($Condition -eq "Q") { break }
		switch ($Condition) {
			"st" { Configure-WUVerbose -Start; Print-CmdMessage("Windows Update verbose logging being enabled. Continue and monitor the progress in the popup window.") }
			"sp" { Configure-WUVerbose -Stop; Print-CmdMessage("Windows UPdate verbose being logging disabled. Continue and monitor the progress in the popup window.") }
		}
	}

}

###########################
# Enter interactive mode
###########################
Function Enter-InteractiveMode {
	Write-Host "+------------------------------------------------------------------------------------------------------------------+" -ForegroundColor Cyan
	Write-Host "<<++++++++++++++++++++++++++++++++++++ Configuration Manager Interactive Mode ++++++++++++++++++++++++++++++++++++>>" -ForegroundColor Cyan
	Write-Host "+------------------------------------------------------------------------------------------------------------------+" -ForegroundColor Cyan
	While ($True) {
		1..50 | foreach{ Write-Host "." -ForegroundColor "Green" -BackgroundColor "Black" -NoNewline }; Write-Host ""
		Write-Host " ? " -ForegroundColor "White" -BackgroundColor "Blue" -NoNewline; Write-Host ": Put in ? to get available commands and usage"
		Write-Host " Q " -ForegroundColor "Yellow" -BackgroundColor "Red" -NoNewline; Write-Host ": To quit interactive mode"
		1..50 | foreach{ Write-Host "." -ForegroundColor "Green" -BackgroundColor "Black" -NoNewline }; Write-Host ""
		if (! (IsCCMInstalled)) { Print-WarningMessage("Configuration Manager client agent is NOT installed on this computer.")}
		Print-LeadingSymbol(">>[Welcome]"); $CMDStr = Read-Host -Prompt "~~ [Enter your command > ]" 
		$CMDStr = $CMDStr.Trim()
		if     ($CMDStr -eq "Q") { Write-Host "Exiting interactive mode..."; Break } 
		elseif ($CMDStr -eq "?") { Print-MainMenu } 
		else {
			switch ( $CMDStr ) {
				"ip"    { cmd.exe /c ipconfig /all }
				"dns"   { cmd.exe /c ipconfig /displaydns }
				"cmreg" { Print-CCMReg }
				"O365"  { Print-O365 }
				"agent" { Print-ConfigMgrClient }
				"bgrp"  { Print-BoundaryGroup }
				"cache" { Query-ContentCache }
				"wsus"  { Print-WSUS }
				"bgb"   { Print-BGB }
				"app"   { Query-Applications }
				"upd"   { Query-Updates}
				"pkgts" {Query-PkgTskSeq}
				"dpL"   { Query-Deployments }
				"trgac" { Trigger-Actions }
				"stmsg" { Query-StateMessages }
				"updst" { Query-UpdatesStore }
				"updhs" { Query-WUHist }
				"svwin" { Print-ServiceWindow }
				"sup"   { Print-SoftwareUpdatePoint }
				"trk"   { Query-TRKey }
				"mp"    { Query-MPInfo }
				"vlog"  { Enter-VLogSetting }
				"nettr" { Enter-NetCapture }
				"cert"  { Query-Certificates }
				"cLset" { Print-ClientSettings }
				"rbhis" { Print-RebootHistory }
				"wulog" { Enter-ConfigureWUVerbose }
				"CAPi2" { Enter-CAPI2LogSetting }
				Default { Run-PoShCmd($CMDStr) | Out-Host -Paging }
			}
		}

	}
}

# $Global:NeedPWD: a global scope variable to check if password is still needed.
# Password is needed only at first access
Set-Variable -Name "NeedPWD" -Value $True -Scope Global

# This function does not work on some platforms. Not used for the moment.
Function Check-Auth0 {
	# Secure string of the true password
	# To get secure string: Read-Host -Prompt "Enter password" -AsSecureString | ConvertFrom-SecureString
	$SecureString0 = "01000000d08c9ddf0115d1118c7a00c04fc297eb01000000c81bf9e16c8452428ea031b9bbc8bdd40000000002000000000003660000c000000010000000a49ec5e3d4fa8b49aba7fa1dd2cca0640000000004800000a000000010000000f115ab12f8d9a2e7e464b632be38f4bc200000001d1b5f6e579214d723a415335914a4b0d4deced41a1b84e73d3f049ea9c251b5140000003d7e315a1a03e0511b360cce1191248e38b4e20c"  | ConvertTo-SecureString
	$BSTR0 = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecureString0)
	$PlainPassword0 = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR0)
	While ($True) {
		$SecurePassword1 = Read-Host -Prompt ">> Enter password to proceed > " -AsSecureString
		$BSTR1 = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecurePassword1)
		$PlainPassword1 = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR1)
		if ($PlainPassword1 -eq $PlainPassword0) { $Global:NeedPWD = $False; break }
	}
}

Function Check-Auth1 {	
	While ($True) {
		$SecurePwd = Read-Host -Prompt ">> Enter password to proceed > " -AsSecureString
		$PlainPwd =[Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecurePwd))
		if ($PlainPwd -eq "lega@msft.com") { $Global:NeedPWD = $False; break }
	}
}

Function Check-Auth {	
	While ($True) {
		$SecurePwd = Read-Host -Prompt ">> Enter password to proceed > " -AsSecureString
		$PlainPwd =[Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecurePwd))
		$MonDay = $(Get-Date -Format 'MMdd') # eg. 0622,1226
		if ($PlainPwd -eq $MonDay) { $Global:NeedPWD = $False; break }
	}
}

Function MainFunc-ConfigMgr-RT {
	Clear-Host
	Print-Declaration
	if ($Global:NeedPWD) { Check-Auth }
	#$VerbosePreference = "Continue"
	Enter-InteractiveMode
}

#MainFunc-ConfigMgr-RT

# ------------------------------------------------------ ConfigMgr-RT.ps1 ------------------------------------------------------ #

##-------------------- Main Function  --------------------##
Function MainFunc {
	$VerbosePreference = "Continue"
	While ($True) {
		Write-Host "<<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ OPTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~>>" -ForegroundColor Cyan
		Write-Host "---------------------------------------------------------------------------------------------"
		
		Write-Host " G " -ForegroundColor "DarkCyan" -BackgroundColor "Yellow" -NoNewline
		Write-Host ": Collect general information. Used when the client is NOT managed by SCCM.          >>"
		
		Write-Host " S " -ForegroundColor "DarkCyan" -BackgroundColor "Magenta" -NoNewline
		Write-Host ": Collect SMS Client Agent information. Used when the client is managed by SCCM.     >>"
		
		Write-Host " O " -ForegroundColor "White" -BackgroundColor "DarkGreen" -NoNewline
		Write-Host ": Collect OS upgrade information. Used in case of client OS upgrade failure via SCCM.>>"
		
		Write-Host " i " -ForegroundColor "White" -BackgroundColor "DarkBlue" -NoNewline
		Write-Host ": Interactive mode for real-time troubleshooting. Password needed for access.        >>"
		
		Write-Host " A/D " -ForegroundColor "Magenta" -BackgroundColor "Gray" -NoNewline
		Write-Host ": A is for enabling SCCM client verbose; D is for disabling SCCM client verbose.   >>"
		
		Write-Host " Q " -ForegroundColor "Black" -BackgroundColor "White" -NoNewline
		Write-Host ": To quit                                                                            >>"
		
		$Option = Read-Host -Prompt "~~ [Enter your option: ]" 
		$Option = $Option.Trim()
		if ($Option -eq "Q") { 
			Write-Output "Exiting..."; Break
		} else {
			$Tag = Generate-Tag
			switch ( $Option )
			{
				"G" { Collect-ClientInfo -Tag $Tag -General -BitsJobs -Security; Construct-ContentTable -CurrentLocation ".\ForMSFT-ClientInfo\${Tag}"; Zip-CollectedFiles -CurrentLocation ".\ForMSFT-ClientInfo\${Tag}" -Tag $Tag }
				"S" { Collect-ClientInfo -Tag $Tag -General -SMSAgent -StateMsg -UpdateStore -AppInstalled -ProgInstalled -BitsJobs -Security; Construct-ContentTable -CurrentLocation ".\ForMSFT-ClientInfo\${Tag}"; Zip-CollectedFiles -CurrentLocation ".\ForMSFT-ClientInfo\${Tag}" -Tag $Tag }
				"O" { Collect-ClientInfo -Tag $Tag -General -SMSAgent -StateMsg -UpdateStore -AppInstalled -ProgInstalled -BitsJobs -WinOSUpgrade -Security; Construct-ContentTable -CurrentLocation ".\ForMSFT-ClientInfo\${Tag}"; Zip-CollectedFiles -CurrentLocation ".\ForMSFT-ClientInfo\${Tag}" -Tag $Tag  }
				"i" { MainFunc-ConfigMgr-RT }
				"A" { Configure-Verbose -AV }
				"D" { Configure-Verbose -DV }
				Default {Write-Host "  Your selection is invalid. Please enter the right option." -BackgroundColor Red -ForegroundColor White }
			}
		}

	}
}

##-------------------- Main Command START  --------------------##
MainFunc
##-------------------- Main Command END  --------------------##